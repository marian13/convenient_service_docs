"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[2184],{3810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>a,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var s=t(4848),i=t(8453);const r={slug:"/guides/testing/how_to_test_service_with_steps",sidebar_position:2,title:"How to test a service with steps?"},c=void 0,d={id:"guides/testing/how_to_test_service_with_steps",title:"How to test a service with steps?",description:"Consider a simple service with steps - ReadFileContent.",source:"@site/docs/guides/testing/how_to_test_service_with_steps.mdx",sourceDirName:"guides/testing",slug:"/guides/testing/how_to_test_service_with_steps",permalink:"/guides/testing/how_to_test_service_with_steps",draft:!1,unlisted:!1,editUrl:"https://github.com/marian13/convenient_service_docs/blob/main/docs/guides/testing/how_to_test_service_with_steps.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{slug:"/guides/testing/how_to_test_service_with_steps",sidebar_position:2,title:"How to test a service with steps?"},sidebar:"docs",previous:{title:"How to test a regular service?",permalink:"/guides/testing/how_to_test_regular_service"},next:{title:"Debugging",permalink:"/category/debugging"}},o={},l=[{value:"How to test a service with steps using RSpec?",id:"how-to-test-a-service-with-steps-using-rspec",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Consider a simple service with steps - ",(0,s.jsx)(n.code,{children:"ReadFileContent"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Services with steps are often called organizers."})}),"\n",(0,s.jsxs)(n.p,{children:["As its name states, it reads the content from a file with a specific ",(0,s.jsx)(n.code,{children:"path"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'class ReadFileContent\n  include ConvenientService::Standard::Config\n\n  attr_reader :path\n\n  step :validate_path, in: :path\n  step AssertFileExists, in: :path\n  step AssertFileNotEmpty, in: :path\n  step :result, in: :path, out: :content\n\n  def initialize(path:)\n    @path = path\n  end\n\n  def result\n    success(content: ::File.read(path))\n  end\n\n  private\n\n  def validate_path\n    return error("Path is `nil`") if path.nil?\n    return error("Path is empty") if path.empty?\n\n    success\n  end\nend\n'})}),"\n",(0,s.jsx)(n.p,{children:"It has four steps, each of which may provide different results depending on the input arguments."}),"\n",(0,s.jsx)(n.p,{children:"They are executed sequentially, from the top to the bottom."}),"\n",(0,s.jsxs)(n.p,{children:["When all of them are successful, the whole ",(0,s.jsx)(n.code,{children:"ReadFileContent"})," service returns the ",(0,s.jsx)(n.code,{children:"success"})," result from its last step."]}),"\n",(0,s.jsxs)(n.p,{children:["When any intermediate step is NOT successful, then the rest of the steps are skipped, and the ",(0,s.jsx)(n.code,{children:"ReadFileContent"})," organizer returns that first ",(0,s.jsx)(n.code,{children:"failure"})," or ",(0,s.jsx)(n.code,{children:"error"})," step result."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the first step is a method step called ",(0,s.jsx)(n.code,{children:"validate_path"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When the path is ",(0,s.jsx)(n.code,{children:"nil"})," or empty, it returns the ",(0,s.jsx)(n.code,{children:"error"})," result."]}),"\n",(0,s.jsxs)(n.p,{children:["Consequently, the following ",(0,s.jsx)(n.code,{children:"AssertFileExists"}),", ",(0,s.jsx)(n.code,{children:"AssertFileNotEmpty"}),", and ",(0,s.jsx)(n.code,{children:"result"})," steps are not even evaluated."]}),"\n",(0,s.jsxs)(n.p,{children:["The whole ",(0,s.jsx)(n.code,{children:"ReadFileContent"})," service returns that same ",(0,s.jsx)(n.code,{children:"error"})," result created by the ",(0,s.jsx)(n.code,{children:"validate_path"})," step."]}),"\n",(0,s.jsxs)(n.p,{children:["Now, for the sake of completeness, let's also have ",(0,s.jsx)(n.code,{children:"AssertFileExists"}),", and ",(0,s.jsx)(n.code,{children:"AssertFileNotEmpty"})," implementations in front of our eyes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'class AssertFileExists\n  include ConvenientService::Standard::Config\n\n  attr_reader :path\n\n  def initialize(path:)\n    @path = path\n  end\n\n  def result\n    return error("Path is `nil`") if path.nil?\n    return error("Path is empty") if path.empty?\n\n    return failure("File with path `#{path}` does NOT exist") unless ::File.exist?(path)\n\n    success\n  end\nend\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'class AssertFileNotEmpty\n  include ConvenientService::Standard::Config\n\n  attr_reader :path\n\n  def initialize(path:)\n    @path = path\n  end\n\n  def result\n    return error("Path is `nil`") if path.nil?\n    return error("Path is empty") if path.empty?\n\n    return failure("File with path `#{path}` is empty") if ::File.zero?(path)\n\n    success\n  end\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"how-to-test-a-service-with-steps-using-rspec",children:"How to test a service with steps using RSpec?"}),"\n",(0,s.jsx)(n.p,{children:"We are already aware of the service specs boilerplate, so we will just copy it from the previous guide."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe ReadFileContent do\n  include ConvenientService::RSpec::Matchers::Results\n\n  example_group "class methods" do\n    describe ".result" do\n      context "when `ReadFileContent` is NOT successful" do\n\n      end\n\n      context "when `ReadFileContent` is successful" do\n\n      end\n    end\n  end\nend\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The process of writing ",(0,s.jsx)(n.code,{children:"it"})," examples for the method steps is very similar to what we do with regular services."]}),"\n",(0,s.jsxs)(n.p,{children:["We also apply ",(0,s.jsx)(n.code,{children:"be_success"}),", ",(0,s.jsx)(n.code,{children:"be_failure"}),", ",(0,s.jsx)(n.code,{children:"be_error"})," matchers and their chainings like ",(0,s.jsx)(n.code,{children:"with_data"}),", ",(0,s.jsx)(n.code,{children:"and_data"}),", ",(0,s.jsx)(n.code,{children:"with_message"}),", ",(0,s.jsx)(n.code,{children:"and_message"}),", ",(0,s.jsx)(n.code,{children:"with_code"}),", ",(0,s.jsx)(n.code,{children:"and_code"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's add specs for the ",(0,s.jsx)(n.code,{children:"validate_path"})," step."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe ReadFileContent do\n  include ConvenientService::RSpec::Matchers::Results\n\n  example_group "class methods" do\n    describe ".result" do\n      let(:result) { described_class.result(path: path) }\n\n      context "when `ReadFileContent` is NOT successful" do\n        context "when `path` is `nil`" do\n          let(:path) { nil }\n\n          it "returns `error` with `message`" do\n            expect(result).to be_error.with_message("Path is `nil`").of_step(:validate_path)\n          end\n        end\n\n        context "when `path` is empty" do\n          let(:path) { "" }\n\n          it "returns `error` with `message`" do\n            expect(result).to be_error.with_message("Path is empty").of_step(:validate_path)\n          end\n        end\n      end\n\n      context "when `ReadFileContent` is successful" do\n\n      end\n    end\n  end\nend\n'})}),"\n",(0,s.jsxs)(n.p,{children:["They look familiar but with one new addition - the ",(0,s.jsx)(n.code,{children:"of_step"})," chaining."]}),"\n",(0,s.jsx)(n.p,{children:"It allows us to confirm that the returned result originates from the concrete step."}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Regular services does not have steps."}),(0,s.jsxs)(n.p,{children:["To emphasize that in specs ",(0,s.jsx)(n.code,{children:"without_step"})," chaining can be used."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'context "when `AssertFileNotEmpty` is successful" do\n  # ...\n\n  it "returns `success`" do\n    expect(result).to be_success.without_data.without_step\n  end\nend\n'})})]}),"\n",(0,s.jsxs)(n.p,{children:["In turn, the process of writing ",(0,s.jsx)(n.code,{children:"it"})," examples for the service steps is different from what we do with regular services."]}),"\n",(0,s.jsx)(n.p,{children:"Why? Because we can rely on the fact the corresponding step service already has its own specs."}),"\n",(0,s.jsx)(n.p,{children:"What does it give us in practice? We can change our focus."}),"\n",(0,s.jsxs)(n.p,{children:["Let's demonsrate it with the ",(0,s.jsx)(n.code,{children:"AssertFileExists"})," step."]}),"\n",(0,s.jsxs)(n.p,{children:["From the ",(0,s.jsx)(n.code,{children:"ReadFileContent"})," point of view, it is redundant to verify every single possible result, data, message, and code variation for the ",(0,s.jsx)(n.code,{children:"AssertFileExists"})," step."]}),"\n",(0,s.jsxs)(n.p,{children:["The corresponding ",(0,s.jsx)(n.code,{children:"AssertFileExists"})," service already has its dedicated and comprehensive specs that we developed in the previous article."]}),"\n",(0,s.jsx)(n.p,{children:"So it is not efficient to duplicate them in multiple places."}),"\n",(0,s.jsxs)(n.p,{children:["Instead, we need to pay attention to what is specific from the ",(0,s.jsx)(n.code,{children:"ReadFileContent"})," perspective:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.code,{children:"AssertFileExists"})," service is NOT successful, then the flow is stopped."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Otherwise, it is continued with the next step."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's reflect that behaviour in the specs."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe ReadFileContent do\n  include ConvenientService::RSpec::Matchers::Results\n\n  example_group "class methods" do\n    describe ".result" do\n      let(:result) { described_class.result(path: path) }\n\n      context "when `ReadFileContent` is NOT successful" do\n        context "when `path` is `nil`" do...\n        end\n\n        context "when `path` is empty" do...\n        end\n\n        # highlight-start\n        context "when `AssertFileExists` is NOT successful" do\n          let(:path) { "not_existing_path" }\n\n          it "returns intermediate step result" do\n            expect(result).to be_not_success.of_step(AssertFileExists)\n          end\n        end\n        # highlight-end\n      end\n\n      context "when `ReadFileContent` is successful" do\n\n      end\n    end\n  end\nend\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, we just took a path that passes the ",(0,s.jsx)(n.code,{children:"verify_path"})," step but makes the ",(0,s.jsx)(n.code,{children:"AssertFileExists"})," step not succeed."]}),"\n",(0,s.jsxs)(n.p,{children:["Also, we used the ",(0,s.jsx)(n.code,{children:"be_not_success"})," matcher and ",(0,s.jsx)(n.code,{children:"of_step"})," chaining to verify the returned result."]}),"\n",(0,s.jsxs)(n.p,{children:["It is NOT actually important for the organizer if that result is a ",(0,s.jsx)(n.code,{children:"failure"})," or ",(0,s.jsx)(n.code,{children:"error"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"But it is essential for it to know whether to proceed with the flow."}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"be_not_failure"})," and ",(0,s.jsx)(n.code,{children:"be_not_error"})," matchers also exist, but they are used in very rare cases."]})}),"\n",(0,s.jsxs)(n.p,{children:["For the ",(0,s.jsx)(n.code,{children:"AssertFileNotEmpty"})," service step the new spec is very similar."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe ReadFileContent do\n  include ConvenientService::RSpec::Matchers::Results\n\n  example_group "class methods" do\n    describe ".result" do\n      let(:result) { described_class.result(path: path) }\n\n      context "when `ReadFileContent` is NOT successful" do\n        context "when `path` is `nil`" do...\n        end\n\n        context "when `path` is empty" do...\n        end\n\n        context "when `AssertFileExists` is NOT successful" do...\n        end\n\n        # highlight-start\n        context "when `AssertFileNotEmpty` is NOT successful" do\n          let(:temfile) { Tempfile.new }\n          let(:path) { temfile.path }\n\n          it "returns intermediate step result" do\n            expect(result).to be_not_success.of_step(AssertFileNotEmpty)\n          end\n        end\n        # highlight-end\n      end\n\n      context "when `ReadFileContent` is successful" do\n\n      end\n    end\n  end\nend\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Input path is taken in a way to pass the ",(0,s.jsx)(n.code,{children:"validate_path"})," and ",(0,s.jsx)(n.code,{children:"AssertFileExist"})," steps, but to stop the flow in ",(0,s.jsx)(n.code,{children:"AssertFileNotEmpty"})," step."]}),"\n",(0,s.jsxs)(n.admonition,{type:"danger",children:[(0,s.jsx)(n.p,{children:"The idea of switching the focus and omitting duplicated specs only makes sense when the step-corresponding service is fully tested by its own specs."}),(0,s.jsx)(n.p,{children:"Otherwise, it becomes the organizer's responsibility to verify all its internal results."}),(0,s.jsxs)(n.p,{children:["That violates the ",(0,s.jsx)(n.a,{href:"https://thoughtbot.com/blog/tell-dont-ask",children:'"Tell, Don\'t Ask"'})," principle, making the organizer specs significantly harder to maintain."]})]}),"\n",(0,s.jsxs)(n.p,{children:["And finally, the ",(0,s.jsx)(n.code,{children:"success"})," case."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'require "spec_helper"\n\nRSpec.describe ReadFileContent do\n  include ConvenientService::RSpec::Matchers::Results\n\n  example_group "class methods" do\n    describe ".result" do\n      let(:result) { described_class.result(path: path) }\n\n      context "when `ReadFileContent` is NOT successful" do\n        context "when `path` is `nil`" do...\n        end\n\n        context "when `path` is empty" do...\n        end\n\n        context "when `AssertFileExists` is NOT successful" do...\n        end\n\n        context "when `AssertFileNotEmpty` is NOT successful" do...\n        end\n      end\n\n      context "when `ReadFileContent` is successful" do\n        # highlight-start\n        let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&:close) }\n        let(:path) { temfile.path }\n        let(:content) { "some content" }\n\n        it "returns `success` with content" do\n          expect(result).to be_success.with_data(content: content).of_step(:result)\n        end\n        # highlight-end\n      end\n    end\n  end\nend\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As a summary, once you learn of how to properly define and utilize the ",(0,s.jsx)(n.code,{children:'"returns intermediate step result"'}),' specs, the testing of services with steps becomes an ordinary "boring" day-to-day activity.']})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>d});var s=t(6540);const i={},r=s.createContext(i);function c(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);