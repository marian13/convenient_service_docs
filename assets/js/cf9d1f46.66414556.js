"use strict";(self.webpackChunkconvenient_service_docs=self.webpackChunkconvenient_service_docs||[]).push([[1844],{8419:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>c});var t=s(4848),i=s(8453);const r={slug:"/guides/usage/how_to_use_steps",sidebar_position:3,title:"How to use service steps?"},a=void 0,d={id:"guides/usage/how_to_use_steps",title:"How to use service steps?",description:"Which types of steps are available?",source:"@site/docs/guides/usage/how_to_use_steps.mdx",sourceDirName:"guides/usage",slug:"/guides/usage/how_to_use_steps",permalink:"/guides/usage/how_to_use_steps",draft:!1,unlisted:!1,editUrl:"https://github.com/marian13/convenient_service_docs/blob/main/docs/guides/usage/how_to_use_steps.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{slug:"/guides/usage/how_to_use_steps",sidebar_position:3,title:"How to use service steps?"},sidebar:"docs",previous:{title:"How to use service results?",permalink:"/guides/usage/how_to_use_results"},next:{title:"Testing",permalink:"/category/testing"}},l={},c=[{value:"Which types of steps are available?",id:"which-types-of-steps-are-available",level:2},{value:"How to define a service step?",id:"how-to-define-a-service-step",level:2},{value:"How to define a method step?",id:"how-to-define-a-method-step",level:2},{value:"What is the result of a service with steps?",id:"what-is-the-result-of-a-service-with-steps",level:2},{value:"What is an organizer?",id:"what-is-an-organizer",level:2},{value:"How to pass arguments to steps?",id:"how-to-pass-arguments-to-steps",level:2},{value:"How to access step result data?",id:"how-to-access-step-result-data",level:2},{value:"How to create a step input alias?",id:"how-to-create-a-step-input-alias",level:2},{value:"How to create a step output alias?",id:"how-to-create-a-step-output-alias",level:2},{value:"How to pass a dynamic value as a step input?",id:"how-to-pass-a-dynamic-value-as-a-step-input",level:2},{value:"What is a <code>raw</code> step input argument?",id:"what-is-a-raw-step-input-argument",level:2},{value:"What is a <code>proc</code> step input argument?",id:"what-is-a-proc-step-input-argument",level:2},{value:"What is a <code>not_step</code>?",id:"what-is-a-not_step",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"which-types-of-steps-are-available",children:"Which types of steps are available?"}),"\n",(0,t.jsx)(n.p,{children:"The two criteria currently categorize steps."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"By action: service and method steps."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["By control flow: ",(0,t.jsx)(n.code,{children:"and"}),", ",(0,t.jsx)(n.code,{children:"or"}),", ",(0,t.jsx)(n.code,{children:"not"})," steps."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-define-a-service-step",children:"How to define a service step?"}),"\n",(0,t.jsxs)(n.p,{children:["You can register existing services as steps of other services using the ",(0,t.jsx)(n.code,{children:"step"})," directive."]}),"\n",(0,t.jsx)(n.p,{children:"Let's have a look at it in practice."}),"\n",(0,t.jsxs)(n.p,{children:["Having the ",(0,t.jsx)(n.code,{children:"Service"})," service."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Service\n  include ConvenientService::Standard::Config\n\n  def result\n    success\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can use it as a step of the ",(0,t.jsx)(n.code,{children:"OtherService"})," service in the following way."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class OtherService\n  include ConvenientService::Standard::Config\n\n  step Service\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"This code works almost the same as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class OtherService\n  include ConvenientService::Standard::Config\n\n  def result\n    Service.result\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"That is why for a single-step service the usage of steps may not seem very beneficial."}),"\n",(0,t.jsx)(n.p,{children:"So consider a more complex example."}),"\n",(0,t.jsx)(n.p,{children:"Now we have 3 services."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class FooService\n  include ConvenientService::Standard::Config\n\n  def result\n    success\n  end\nend\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class BarService\n  include ConvenientService::Standard::Config\n\n  def result\n    success\n  end\nend\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class BazService\n  include ConvenientService::Standard::Config\n\n  def result\n    success\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"HostService"})," uses them as steps."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class HostService\n  include ConvenientService::Standard::Config\n\n  step FooService\n  step BarService\n  step BazService\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Rough ",(0,t.jsx)(n.code,{children:"HostService"})," equivalent without steps may be implemented as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class HostService\n  include ConvenientService::Standard::Config\n\n  def result\n    foo_result = FooService.result\n\n    return foo_result unless foo_result.success?\n\n    bar_result = BarService.result\n\n    return bar_result unless bar_result.success?\n\n    BazService.result\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you can see, steps allow us to eliminate at least 2 assignments and 2 if-conditionals for this particular example."}),"\n",(0,t.jsx)(n.p,{children:"Sure, those assignments and if-conditionals are still performed under the hood, but it is no longer a developer's responsibility to manage them."}),"\n",(0,t.jsx)(n.p,{children:"Now the benefit of steps becomes more obvious, but that is not the only benefit."}),"\n",(0,t.jsx)(n.p,{children:"Other guides are going to demonstrate the additional simplifications."}),"\n",(0,t.jsx)(n.h2,{id:"how-to-define-a-method-step",children:"How to define a method step?"}),"\n",(0,t.jsx)(n.p,{children:"Any method can be a step."}),"\n",(0,t.jsx)(n.p,{children:"The only requirement is that it must return a result."}),"\n",(0,t.jsx)(n.p,{children:"For example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Service\n  include ConvenientService::Standard::Config\n\n  step :foo\n\n  def foo\n    success\n  end\nend\n"})}),"\n",(0,t.jsx)(n.h2,{id:"what-is-the-result-of-a-service-with-steps",children:"What is the result of a service with steps?"}),"\n",(0,t.jsx)(n.p,{children:"Consider the following service."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Service\n  include ConvenientService::Standard::Config\n\n  step :foo\n  step :bar\n  step :baz\n\n  def foo\n    success\n  end\n\n  def bar\n    success\n  end\n\n  def baz\n    success\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"When all steps are successful, the overall service result is the last step result."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"result = Service.result\n# => <Service::Result status: :success>\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"result.step\n# => <Service::Step method: :baz>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's check some other service."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class OtherService\n  include ConvenientService::Standard::Config\n\n  step :foo\n  step :bar\n  step :baz\n\n  def foo\n    success\n  end\n\n  def bar\n    failure("Message from `bar`")\n    # `error("Message from `bar`")` also stops the sequence.\n  end\n\n  def baz\n    raise "Not raised exception"\n\n    success\n  end\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:"When any step is NOT successful, the overall service result is that NOT successful step result."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"result = OtherService.result\n# => <OtherService::Result status: :failure>\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"result.step\n# => <OtherService::Step method: :bar>\n"})}),"\n",(0,t.jsx)(n.p,{children:"It is important to note that the remaining steps are NOT even evaluated."}),"\n",(0,t.jsxs)(n.p,{children:["That is why the exception from ",(0,t.jsx)(n.code,{children:"baz"})," was not raised."]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-an-organizer",children:"What is an organizer?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Organizer"})," is a service with steps."]}),"\n",(0,t.jsxs)(n.p,{children:["It is also worth mentioning that services without steps are often referred to as ",(0,t.jsx)(n.em,{children:"regular services"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-pass-arguments-to-steps",children:"How to pass arguments to steps?"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"in"})," option of the ",(0,t.jsx)(n.code,{children:"step"})," directive."]}),"\n",(0,t.jsx)(n.p,{children:"Here is a quick example."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"NestedService"})," accepts two keyword arguments - ",(0,t.jsx)(n.code,{children:":first_kwarg"}),", and ",(0,t.jsx)(n.code,{children:":second_kwarg"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class NestedService\n  include ConvenientService::Standard::Config\n\n  attr_reader :first_kwarg, :second_kwarg\n\n  def initialize(:first_kwarg, :second_kwarg)\n    @first_kwarg = first_kwarg\n    @second_kwarg = second_kwarg\n  end\n\n  def result\n    puts "first_kwarg: `#{first_kwarg}`"\n    puts "second_kwarg: `#{second_kwarg}`"\n\n    success\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This is how the ",(0,t.jsx)(n.code,{children:"in"})," option is utilized in order to pass them as step inputs."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Service\n  include ConvenientService::Standard::Config\n\n  step NestedService, in: [:first_kwarg, :second_kwarg]\n\n  def first_kwarg\n    :foo\n  end\n\n  def second_kwarg\n    :bar\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["As you can see below, the corresponding methods' return values are passed as ",(0,t.jsx)(n.code,{children:":first_kwarg"})," and ",(0,t.jsx)(n.code,{children:":second_kwarg"})," to the ",(0,t.jsx)(n.code,{children:"NestedService"})," step when we call the organizer."]}),"\n",(0,t.jsxs)(n.p,{children:["For this particular case, it is ",(0,t.jsx)(n.code,{children:":foo"})," and ",(0,t.jsx)(n.code,{children:":bar"})," respectively."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'result = Service.result\n# "first_kwarg: `:foo`"\n# "second_kwarg: `:bar`"\n# => <Service::Result status: :success>\n'})}),"\n",(0,t.jsx)(n.p,{children:"In order to simplify the understanding of the step inputs, let's have a closer look at this specific line."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"step NestedService, in: [:first_kwarg, :second_kwarg]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Whenever you have trouble with its meaning, please, remember that it can be ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"mentally translated"})," like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"def first_step_result\n  @first_step_result ||= NestedService.result(\n    first_kwarg: first_kwarg,\n    second_kwarg: second_kwarg\n  )\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"That is why it is important to have corresponding instance methods defined for step inputs in the organizer class."}),"\n",(0,t.jsxs)(n.p,{children:["More examples of the ",(0,t.jsx)(n.code,{children:"in"})," option usage may be found in ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"the so-called translation table"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-access-step-result-data",children:"How to access step result data?"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"out"})," option of the ",(0,t.jsx)(n.code,{children:"step"})," directive."]}),"\n",(0,t.jsx)(n.p,{children:"Here is a short example."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"NestedService"})," returns a ",(0,t.jsx)(n.code,{children:"success"})," with data that has two keys - ",(0,t.jsx)(n.code,{children:":first_data_key"}),", and ",(0,t.jsx)(n.code,{children:":second_data_key"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class NestedService\n  include ConvenientService::Standard::Config\n\n  def result\n    success(first_data_key: :baz, second_data_key: :qux)\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is how the ",(0,t.jsx)(n.code,{children:"out"})," option is utilized in order to access them as step outputs."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class Service\n  include ConvenientService::Standard::Config\n\n  step NestedService, out: [:first_data_key, :second_data_key]\n\n  step :result\n\n  def result\n    puts "first_data_key: `#{first_data_key}`"\n    puts "second_data_key: `#{second_data_key}`"\n\n    success\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Step result data values become available via the ",(0,t.jsx)(n.code,{children:"first_data_key"})," and ",(0,t.jsx)(n.code,{children:"second_data_key"})," instance methods."]}),"\n",(0,t.jsxs)(n.p,{children:["For this particular case, they return ",(0,t.jsx)(n.code,{children:":baz"})," and ",(0,t.jsx)(n.code,{children:":qux"}),", the same values that were passed to the original ",(0,t.jsx)(n.code,{children:"success"})," in the ",(0,t.jsx)(n.code,{children:"NestedService"})," service."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'result = Service.result\n# "first_data_key: `:baz`"\n# "second_data_key: `:qux`"\n# => <Service::Result status: :success>\n'})}),"\n",(0,t.jsx)(n.p,{children:"In order to simplify the understanding of the step outputs, let's have a closer look at this specific line."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"step NestedService, out: [:first_data_key, :second_data_key]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Whenever you have trouble with its meaning, please, remember that it can be ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"mentally translated"})," like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"def first_step_result\n  @first_step_result ||= NestedService.result\nend\n\ndef first_data_key\n  first_step_result.data[:first_data_key]\nend\n\ndef second_data_key\n  first_step_result.data[:second_data_key]\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"Having this information, avoid defining instance methods with the same names as step outputs in the organizer class."}),"\n",(0,t.jsx)(n.p,{children:"Otherwise, your methods will be silently overridden."}),"\n",(0,t.jsxs)(n.p,{children:["More examples of the ",(0,t.jsx)(n.code,{children:"out"})," option usage may be found in ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"the so-called translation table"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-create-a-step-input-alias",children:"How to create a step input alias?"}),"\n",(0,t.jsx)(n.p,{children:"There are cases when the organizer service does not have the corresponding method defined with the same name as a step input."}),"\n",(0,t.jsx)(n.p,{children:"Or that method is already reserved for some other purpose and can not be reused."}),"\n",(0,t.jsxs)(n.p,{children:["Consider the example, when the ",(0,t.jsx)(n.code,{children:"RemoveNilElements"})," service expects the ",(0,t.jsx)(n.code,{children:"elements"})," keyword argument as its input."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class RemoveNilElements\n  include ConvenientService::Standard::Config\n\n  attr_reader :elements\n\n  def initialize(elements:)\n    @elements = elements\n  end\n\n  def result\n    success(filtered_elements: elements.compact)\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"PrepareCollection"})," service tries to register ",(0,t.jsx)(n.code,{children:"RemoveNilElements"})," as its step."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class PrepareCollection\n  include ConvenientService::Standard::Config\n\n  step RemoveNilElements, in: [:elements]\n\n  def collection\n    [42, nil, "foo"]\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Since it does not have the ",(0,t.jsx)(n.code,{children:"elements"})," method defined, the usual ",(0,t.jsx)(n.code,{children:"in: [:elements]"})," declaration won't work."]}),"\n",(0,t.jsxs)(n.p,{children:["But it has the ",(0,t.jsx)(n.code,{children:"collection"})," method instead."]}),"\n",(0,t.jsxs)(n.p,{children:["In order to utilize its return value as the ",(0,t.jsx)(n.code,{children:":elements"})," input, the ",(0,t.jsx)(n.code,{children:"PrepareCollection"})," should be updated as follows."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class PrepareCollection\n  include ConvenientService::Standard::Config\n\n  # highlight-start\n  step RemoveNilElements, in: [{elements: :collection}]\n  # highlight-end\n\n  def collection\n    [42, nil, "foo"]\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Now, the ",(0,t.jsx)(n.code,{children:"in"})," option contains a hash ",(0,t.jsx)(n.code,{children:"{elements: :collection}"}),' that can be read as "Pass ',(0,t.jsx)(n.code,{children:"elements"})," to step as ",(0,t.jsx)(n.code,{children:"collection"}),'".']}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"As a rule of thumb, try to memorize that the alias is always on the right side of the hash \ud83d\ude0e."})}),"\n",(0,t.jsxs)(n.p,{children:["Traditionally, to simplify the understanding of the steps-related stuff, input aliases this time, let's have a closer look at the ",(0,t.jsx)(n.code,{children:"step"})," directive again."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"step RemoveNilElements, in: [{elements: :collection}]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Whenever you have trouble with its meaning, please, remember that it can be ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"mentally translated"})," like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"def first_step_result\n  @first_step_result ||= RemoveNilElements.result(elements: collection)\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you can see, creating an input alias is just passing a different method return value to the underlying service."}),"\n",(0,t.jsxs)(n.p,{children:["More examples of the ",(0,t.jsx)(n.code,{children:"in"})," option aliases usage may be found in ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"the so-called translation table"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-create-a-step-output-alias",children:"How to create a step output alias?"}),"\n",(0,t.jsx)(n.p,{children:"There are cases when the organizer service already has the corresponding method defined with the same name as a step output."}),"\n",(0,t.jsx)(n.p,{children:"That method is probably reserved for some other purpose so it is not supposed to be redefined."}),"\n",(0,t.jsxs)(n.p,{children:["Consider the example, when the ",(0,t.jsx)(n.code,{children:"RemoveNilElements"})," service returns the ",(0,t.jsx)(n.code,{children:"filtered_elements"})," key as its output."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class RemoveNilElements\n  include ConvenientService::Standard::Config\n\n  attr_reader :elements\n\n  def initialize(elements:)\n    @elements = elements\n  end\n\n  def result\n    success(filtered_elements: elements.compact)\n  end\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"PrepareCollection"})," service tries to register ",(0,t.jsx)(n.code,{children:"RemoveNilElements"})," as its step."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class PrepareCollection\n  include ConvenientService::Standard::Config\n\n  step RemoveNilElements,\n    in: [:elements],\n    out: [:filtered_elements]\n\n  def elements\n    [42, nil, "foo"]\n  end\n\n  def filtered_elements\n    elements - ["foo"]\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Since it already has the ",(0,t.jsx)(n.code,{children:"filtered_elements"})," method defined, the usual ",(0,t.jsx)(n.code,{children:"out: [:filtered_elements]"})," declaration overrides its return value."]}),"\n",(0,t.jsxs)(n.p,{children:["Whenever you call ",(0,t.jsx)(n.code,{children:"filtered_elements"})," before the ",(0,t.jsx)(n.code,{children:"RemoveNilElements"})," step is executed, it returns ",(0,t.jsx)(n.code,{children:"[42, nil]"})," (raises an exception for versions lower than v0.20)."]}),"\n",(0,t.jsxs)(n.p,{children:["But when you invoke it after the ",(0,t.jsx)(n.code,{children:"RemoveNilElements"})," step is run, it returns ",(0,t.jsx)(n.code,{children:'[42, "foo"]'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes such behavior is expected, but typically we don't want to lose access to the original ",(0,t.jsx)(n.code,{children:"filtered_elements"})," implementation."]}),"\n",(0,t.jsx)(n.p,{children:"That is why there is an ability to define output aliases."}),"\n",(0,t.jsxs)(n.p,{children:["Let's utilize one in the ",(0,t.jsx)(n.code,{children:"PrepareCollection"})," service."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class PrepareCollection\n  include ConvenientService::Standard::Config\n\n  # highlight-start\n  step RemoveNilElements,\n    in: [:elements],\n    out: [{:filtered_elements: :filtered_collection}]\n  # highlight-end\n\n  def elements\n    [42, nil, "foo"]\n  end\n\n  def filtered_elements\n    elements - ["foo"]\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"out"})," option contains a hash ",(0,t.jsx)(n.code,{children:"{:filtered_elements: :filtered_collection}"}),' that can be read as "Retrieve ',(0,t.jsx)(n.code,{children:"filtered_elements"})," from step as ",(0,t.jsx)(n.code,{children:"filtered_collection"}),'".']}),"\n",(0,t.jsxs)(n.p,{children:["Now, the additional ",(0,t.jsx)(n.code,{children:"filtered_collection"})," method is defined that is fully independent of ",(0,t.jsx)(n.code,{children:"filtered_elements"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"As a rule of thumb, try to memorize that the alias is always on the right side of the hash \ud83d\ude0e."})}),"\n",(0,t.jsxs)(n.p,{children:["As always, to simplify the understanding of the steps-related stuff, output aliases this time, let's have a closer look at the ",(0,t.jsx)(n.code,{children:"step"})," directive."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"step RemoveNilElements,\n  in: [:elements],\n  out: [{:filtered_elements: :filtered_collection}]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Whenever you have trouble with its meaning, please, remember that it can be ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"mentally translated"})," like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"def first_step_result\n  @first_step_result ||= RemoveNilElements.result(elements: elements)\nend\n\ndef filtered_collection\n  @filtered_collection ||= first_step_result.data[:filtered_elements]\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you can see, creating an output alias is just retrieving a different key value from the underlying step result."}),"\n",(0,t.jsxs)(n.p,{children:["More examples of the ",(0,t.jsx)(n.code,{children:"out"})," option aliases usage may be found in ",(0,t.jsx)(n.a,{href:"/basics/step_to_result_translation_table",children:"the so-called translation table"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"how-to-pass-a-dynamic-value-as-a-step-input",children:"How to pass a dynamic value as a step input?"}),"\n",(0,t.jsx)(n.p,{children:"Let's consider the following service."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Service\n  # ...\n\n  step EscapeRegexp,\n    in: [:pattern]\n    out: [:escaped]\n\n  # ...\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We need to pass either ",(0,t.jsx)(n.code,{children:'ENV["PATH_PATTERN"]'})," or ",(0,t.jsx)(n.code,{children:'ENV["PATH_GLOB"]'})," to the ",(0,t.jsx)(n.code,{children:"EscapeRegexp"})," step as the ",(0,t.jsx)(n.code,{children:"pattern"})," argument."]}),"\n",(0,t.jsx)(n.p,{children:"As you may already guessed that is achievable by defining a corresponding instance method."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class Service\n  # ...\n\n  step EscapeRegexp,\n    in: [:pattern]\n    out: [:escaped]\n\n  # ...\n\n  def pattern\n    ENV["PATH_PATTERN"] || ENV["PATH_GLOB"]\n  end\nend\n'})}),"\n",(0,t.jsx)(n.p,{children:"This is what you would usually do most of the time."}),"\n",(0,t.jsxs)(n.p,{children:["When the ",(0,t.jsx)(n.code,{children:"pattern"})," method is reserved for some other purpose in your organizer service, there is always a possibility of using an alias."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class Service\n  # ...\n\n  step EscapeRegexp,\n    in: [{pattern: :template}]\n    out: [:escaped]\n\n  # ...\n\n  def template\n    ENV["PATH_PATTERN"] || ENV["PATH_GLOB"]\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example the ",(0,t.jsx)(n.code,{children:"template"})," method return value is passed as the ",(0,t.jsx)(n.code,{children:"pattern"})," argument."]}),"\n",(0,t.jsx)(n.p,{children:"But sometimes it may feel redundant or unnatural to define a dedicated method for such a simple task."}),"\n",(0,t.jsx)(n.p,{children:"That is why there are two additional ways to dynamically pass a value as a step input:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Using a ",(0,t.jsx)(n.code,{children:"raw"})," step input argument."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Using a ",(0,t.jsx)(n.code,{children:"proc"})," step input argument."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"what-is-a-raw-step-input-argument",children:["What is a ",(0,t.jsx)(n.code,{children:"raw"})," step input argument?"]}),"\n",(0,t.jsx)(n.p,{children:"Here is a quick example."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'step EscapeRegexp,\n  in: [{pattern: raw(ENV["PATH_PATTERN"] || ENV["PATH_GLOB"]) }],\n  out: [:escaped]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This is how the ",(0,t.jsx)(n.code,{children:"step"}),' call is "translated" to regular service invocation under the hood:']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'def step_result\n  @step_result ||= EscapeRegexp.result(pattern: ENV["PATH_PATTERN"] || ENV["PATH_GLOB"])\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"raw"})," is just a ",(0,t.jsx)(n.a,{href:"https://rubyreferences.github.io/rubyref/language/methods-def.html#scope",children:"class method"})," you can pass to it anything from the enclosing class scope."]}),"\n",(0,t.jsx)(n.p,{children:"The value is forwarded without any intermediate processing."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"step EscapeRegexp,\n  in: [{pattern: raw(any_class_method)}],\n  out: [:escaped]\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"what-is-a-proc-step-input-argument",children:["What is a ",(0,t.jsx)(n.code,{children:"proc"})," step input argument?"]}),"\n",(0,t.jsx)(n.p,{children:"Here is a quick example."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'step EscapeRegexp,\n  in: [{pattern: -> { ENV["PATH_PATTERN"] || ENV["PATH_GLOB"] }}],\n  out: [:escaped]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Similarly to ",(0,t.jsx)(n.code,{children:"raw"}),", the ",(0,t.jsx)(n.code,{children:"proc"})," form also does not additionally process the passed value, but it is evaluated in the instance scope instead of the class scope."]}),"\n",(0,t.jsx)(n.p,{children:"So you can access any service instance methods in it."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"step EscapeRegexp,\n  in: [{pattern: -> { any_instance_method }}],\n  out: [:escaped]\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"what-is-a-not_step",children:["What is a ",(0,t.jsx)(n.code,{children:"not_step"}),"?"]}),"\n",(0,t.jsx)(n.p,{children:"Once your codebase starts to grow, you will notice that it contains a lot of so-called boolean services."}),"\n",(0,t.jsx)(n.p,{children:"The following list demonstrates some common names."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IsAdmin"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"HasAccessRights"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ShouldGrantPermission"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"AssertPolicySatisfied"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"EnsureEligibleForRemoval"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ConfirmRuleApplied"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"WasPreviouslyChecked"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"And so on..."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Usually, such services are utilized as the precondition steps in organizers."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class PlayAudio\n  include ConvenientService::Standard::Config\n\n  # ...\n\n  step AssertFormatSupported,\n      in: :audio\n\n  step EnsureDriverUpgraded,\n      in: :format\n\n  step ConfirmMaxSizeNotExceeded,\n      in: :size\n\n    # ...\n\n  step :result\n\n  def result\n    # ...\n  end\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"After a while it is just a matter of time when some of those preconditions are required to be used in some other contexts, but in the negated form."}),"\n",(0,t.jsx)(n.p,{children:"In other words, negative counterparts are created."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IsAdmin"})," -> ",(0,t.jsx)(n.code,{children:"IsNotAdmin"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"HasAccessRights"})," -> ",(0,t.jsx)(n.code,{children:"DoesNotHaveAccessRights"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ShouldGrantPermission"})," -> ",(0,t.jsx)(n.code,{children:"ShouldNotGrantPermission"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"AssertPolicySatisfied"})," -> ",(0,t.jsx)(n.code,{children:"RefutePolicySatisfied"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"EnsureEligibleForRemoval"})," -> ",(0,t.jsx)(n.code,{children:"EnsureNotEligibleForRemoval"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ConfirmRuleApplied"})," -> ",(0,t.jsx)(n.code,{children:"DenyRuleApplied"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"WasPreviouslyChecked"})," -> ",(0,t.jsx)(n.code,{children:"WasNotPreviouslyChecked"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"And so on..."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"A majority of the time those services have very similar implementations."}),"\n",(0,t.jsxs)(n.p,{children:["The only difference is that ",(0,t.jsx)(n.code,{children:"success"})," and ",(0,t.jsx)(n.code,{children:"failure"})," results are switched."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, consider the ",(0,t.jsx)(n.code,{children:"AssertFormatSupported"})," service."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class AssertFormatSupported\n  include ConvenientService::Standard::Config\n\n  attr_reader :audio\n\n  def initialize(audio:)\n    @audio = audio\n  end\n\n  def result\n    return error("Audio is nil") if audio.nil?\n\n    if !supported_formats.include?(audio.format)\n      return failure("Audio `#{audio.name}` format `#{audio.format}` is NOT supported")\n    end\n\n    success\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Its opposite service ",(0,t.jsx)(n.code,{children:"RefuteFormatSupported"})," has a slighlty distinctive definition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'class RefuteFormatSupported\n  include ConvenientService::Standard::Config\n\n  attr_reader :audio\n\n  def initialize(audio:)\n    @audio = audio\n  end\n\n  def result\n    return error("Audio is nil") if audio.nil?\n\n    if supported_formats.include?(audio.format)\n      return failure("Audio `#{audio.name}` format `#{audio.format}` is supported")\n    end\n\n    success\n  end\nend\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you look precisely, only ",(0,t.jsx)(n.code,{children:"!"})," and ",(0,t.jsx)(n.code,{children:"NOT"})," are removed compared to the original ",(0,t.jsx)(n.code,{children:"AssertFormatSupported"})," service."]}),"\n",(0,t.jsx)(n.p,{children:"As a consequence, it may seem not logical to maintain two almost identical solutions."}),"\n",(0,t.jsxs)(n.p,{children:["That is why the ",(0,t.jsx)(n.code,{children:"not_step"})," directive is available."]}),"\n",(0,t.jsxs)(n.p,{children:["It works similarly to the regular ",(0,t.jsx)(n.code,{children:"step"})," directive."]}),"\n",(0,t.jsxs)(n.p,{children:["It also has ",(0,t.jsx)(n.code,{children:"in"})," and ",(0,t.jsx)(n.code,{children:"out"})," options, supports ",(0,t.jsx)(n.code,{children:"alias"}),", ",(0,t.jsx)(n.code,{children:"raw"}),", and ",(0,t.jsx)(n.code,{children:"proc"})," input arguments, etc, but it calls the ",(0,t.jsx)(n.code,{children:"negated_result"})," under the hood."]}),"\n",(0,t.jsxs)(n.p,{children:["Having that said, a ",(0,t.jsx)(n.code,{children:"not_step"})," usage like in the following snippet:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"class Service\n  include ConvenientService::Standard::Config\n\n  not_step AssertFormatSupported,\n    in: :audio\n\n  # ...\nend\n"})}),"\n",(0,t.jsx)(n.p,{children:"Can be mentally translated to:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:"def first_step_result\n  @first_step_result ||= AssertFormatSupported.negated_result(audio: audio)\nend\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When the original ",(0,t.jsx)(n.code,{children:"result"})," returns ",(0,t.jsx)(n.code,{children:"success"}),", the ",(0,t.jsx)(n.code,{children:"negated_result"})," returns ",(0,t.jsx)(n.code,{children:"failure"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When the original ",(0,t.jsx)(n.code,{children:"result"})," returns ",(0,t.jsx)(n.code,{children:"failure"}),", the ",(0,t.jsx)(n.code,{children:"negated_result"})," returns ",(0,t.jsx)(n.code,{children:"success"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"error"})," is always an ",(0,t.jsx)(n.code,{children:"error"}),", so both the original ",(0,t.jsx)(n.code,{children:"result"})," and ",(0,t.jsx)(n.code,{children:"negated_result"})," return the same status."]}),"\n",(0,t.jsxs)(n.p,{children:["Thus, the ",(0,t.jsx)(n.code,{children:"not_step"})," directive (and ",(0,t.jsx)(n.code,{children:"negated_result"}),") eliminates the need to maintain the opposite services when negated implementations are almost identical to the original."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>d});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);