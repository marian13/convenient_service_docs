{"searchDocs":[{"title":"Errors","type":0,"sectionRef":"#","url":"/basics/errors","content":"","keywords":"","version":"Next"},{"title":"What is an error?‚Äã","type":1,"pageTitle":"Errors","url":"/basics/errors#what-is-an-error","content":"Error is a result type caused either by the wrong input data (validation error) or by the exceptional behaviour (exception error). In some cases, it may be a validation rule violation, unsatisfied assertion, or unmet precondition based on the service arguments. It is a responsibility of a developer/service user to provide correct inputs. Otherwise, there is no sense in even starting any service processing. Also errors are often semantically close to the exceptions. In other words, service errors are frequently located at the same places where exceptions are raised/rescued in the reqular methods. info Exceptional behaviour like HTTP connection issues, database inconsistencies, timeouts, etc are also errors. Check out the following example: class EnsureFeatureActive # ... def initialize(name:) @name = name end def result return error(&quot;Feature name can NOT be `nil`&quot;) if name.nil? return error(&quot;Unknown feature `#{name}`&quot;) unless Feature.exist?(name: name) # ... Tricky and non trivial logic to ensure that feature is active... rescue Feature::Exceptions::ConnectionTimeout =&gt; exception return error(&quot;Feature `#{name}` connection timeout due to `#{exception.message}`&quot;) end end  And this is how it can be triggerred: result = EnsureFeatureActive.result(name: &quot;Fancy feature&quot;) if result.error? # `result.message` is a string-like object with error reason. result.message end  There is no point to involve all the heavy machinery when the feature name is nil. Why do we need to waste any expensive resources if the feature name is unknown? Can we guarantee whether the feature is actually active when a connection timeout happens? So, the one of the purposes of the error result is to say that the callers need to make adjustments in their code/config/dependency, not the service authors. ","version":"Next","tagName":"h2"},{"title":"Assigns attributes in constructor using Dry::Initializer","type":0,"sectionRef":"#","url":"/api/plugins/common/assigns_attributes_in_constructor/using_dry_initializer","content":"Assigns attributes in constructor using Dry::Initializer It is so common to write constructors and attributes in Ruby like so: class FormatHeader include ApplicationService::Config attr_reader :parsed_content, :skip_frozen_string_literal def initialize(parsed_content:, skip_frozen_string_literal: false) @parsed_content = parsed_content @skip_frozen_string_literal = skip_frozen_string_literal end # ... end If Ruby is your day-to-day language, such code probably seems too routine for you. class RunShell include ApplicationService::Config attr_reader :command, :debug def initialize(command:, debug: false) @command = command @debug = debug end # ... end Also, it is so annoying to make accidental typos, when you are already tired, but you still have some stuff to complete. For example, the word command is typed 4 times in the example above, so there are 4 opportunities to make an automatic mistake. Please, don't even tell that your IDE handles that for you. When the whole team is feeling the same annoyance. All of the members really believe in the benefits of the removal of such repeatable code. You may consider to utilizing the Dry::Initializer integration that the AssignsAttributesInConstructor::UsingDryInitalizer plugin provides. module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config # ... concerns do use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingDryInitalizer::Concern end end end end end Thus, FormatHeader and RunShell can be reduced in the following way: class FormatHeader include ApplicationService::Config option :parsed_content option :skip_frozen_string_literal, default: -&gt; { false } # ... end class RunShell include ApplicationService::Config option :command option :debug, default: -&gt; { false } # ... end caution Dry::Initializer does NOT call super in its initialize implementation. If it causes problems for you, try to place AssignsAttributesInConstructor::UsingDryInitalizer closer to the top in the concerns stack. See insert_before. danger Introduce new libraries to the projects only when you have strong arguments and complete ideas about why to do so. In fast-paced enterprise projects, with a poor onboarding process, simplicity is almost always a better choice. The simplicity in a sense, that the tech stack should be familiar to the people, who maintain the project for years. Since you probably won't have a chance to talk with the &quot;one-task&quot; developers while they remember the initial reasoning behind their code. Moreover, that code is frequently left without any diagrams, documentation, or even tests üòê.","keywords":"","version":"Next"},{"title":"Failures","type":0,"sectionRef":"#","url":"/basics/failures","content":"","keywords":"","version":"Next"},{"title":"What is a failure?‚Äã","type":1,"pageTitle":"Failures","url":"/basics/failures#what-is-a-failure","content":"Errors prevent the achievement of the service goal due to unsatisfied validations or exceptions. At the same time, failures prevent the achievement of the service goal due to business reasons. That is why is so vital to use meaningful names for services. For instance, when the aim is to order a bus ticket, call it - OrderBusTicket. So when the service is invoked, but the ticket is not ordered for some logical business reason, it should be treated as a failure. Why? Business reason is not an error, since the input is valid, the environment is stable, but the service goal is still not achieved. Please, read the following code snippet carefully to get the idea. class OrderBusTicket # ... def result return error(&quot;Bus is nil&quot;) if bus.nil? return error(&quot;Bus `#{bus.number}` is NOT valid&quot;) unless bus.has_valid_number? return failure(&quot;Bus has no available seats&quot;) if bus.full? return failure(&quot;Bus trip is postponed&quot;) if Trip.for_bus(bus).postponed? ticket = BusTerminal.issue_ticket(bus) success(ticket: ticket) rescue =&gt; exception error(&quot;Ticket order for bus `#{name}` is not completed due to `#{exception.message}`&quot;) end end  And this is how it can be triggerred: result = OrderBusTicket.result(bus: bus) if result.failure? # `result.message` is a string-like object with failure reason. result.message end  When the bus is nil we can not even try to order a ticket. When the bus does not have a valid number, we can not even try to order a ticket. When an exception is raised, we can not complete the ticket order due to the technical issue. Hence errors are returned for those cases. But once all the validation preconditions are met and exceptions are avoided, the ticket can still not be ordered for business reasons. This is the place when failures come into play. The lack of available seats or the trip delay are examples of business reasons. Just accept the fact that at the given moment in time, there is no possibility to order a ticket for that specific bus. But the crucial point is that a failure is a strong and reliable explainer of why the desired effect hasn't happened. That is the key difference between errors and failures. Errors give you no service goal resolution at all. While failures provide a stable negative service goal resolution that is a strong foundation for the subsequent decision-making. ","version":"Next","tagName":"h2"},{"title":"Result-ducks","type":0,"sectionRef":"#","url":"/basics/results_are_ducks","content":"","keywords":"","version":"Next"},{"title":"Why Results are Ducks?‚Äã","type":1,"pageTitle":"Result-ducks","url":"/basics/results_are_ducks#why-results-are-ducks","content":"If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. ‚Äî Duck test Results are Ducks in the sense that no matter whether you have success, failure, or error - all of them have the same interface with reasonable defaults. Here is a comparison table: \tdata\tmessage\tcodesuccess\t*data or {}\t*message or &quot;&quot;\t*code or :default_success failure\t*data or {}\t*message or &quot;&quot;\t*code or :default_failure error\t*data or {}\t*message or &quot;&quot;\t*code or :default_error Where * means user-provided. info As a user, you have the ability to pass custom values for everything, e.g: extraordinary code for success. We (as library designers) left such a possibility to avoid the Incomplete Library Class code smell. But to be honest, we don't see any valuable use cases for now. note Actually, Convenient Service utilizes look-alike wrappers for data, message, and code. {}, &quot;&quot; and :symbol notations are used to not overcomplicate the table with too low-level details. As a consequence, you can be confident that any (adequate) status check (like success?) is enough to proceed: def show # ... # Status is logically checked somewhere. result.success? # n lines of code later... # Won't crash since all `success`, `failure` and `error` respond to `data` and have reasonable defaults. result.data # Won't crash since all `success`, `failure` and `error` respond to `message` and have reasonable defaults. result.message # Won't crash since all `success`, `failure` and `error` respond to `code` and have reasonable defaults. result.code # ... end  danger When you forget to check the result status before accessing any of its attributes - an exception is raised. That is intentional in order to motivate a user to think not only about a happy path but about negative cases as well. For example: delivery_result = OrderFoodDelivery.result # Oh, raises `... Result::Errors::StatusIsNotChecked` since (as its name states) status is not checked. # How can you eat something if you don't even know whether it is already delivered or not üôÇ? client.eat(delivery_result.data[:food])  ","version":"Next","tagName":"h2"},{"title":"Results","type":0,"sectionRef":"#","url":"/basics/results","content":"","keywords":"","version":"Next"},{"title":"Motivation behind results‚Äã","type":1,"pageTitle":"Results","url":"/basics/results#motivation-behind-results","content":"Usually, the service exposes a sole public method, let it be call for this case. class Service def call # ... end end  Since Ruby is a dynamic language, call may return any type of value. Sometimes it is advantageous, for things like Duck Typing, Abstract Factories, Null Objects, etc. But occasionally it may also become problematic. For example, you can not implement a unified way to check whether the value was calculated correctly (as it was intended by its author). value = service.call if value.any? # When an array. if value.cover?(0...100) # Range. if value.match(/^[0-9]*$/) # Regexp. if value.dig(:user, :address) # Hash. if value.nozero? # Integer....  note Someone may consider Object#blank? and its opposite Object#present? from ActiveSupport as an attempt, but they detect truthiness in the Rails sense. Also it is common to forget to verify if the returned value is actually what you need: hash = service.call hash.merge(other_hash) # Expected a merge, but it raises since hash is nil...  Convenient Service suggests utilizing Result objects as a way to overcome the problems listed above. Practically speaking, to return results from all services. To express this idea, let's create a different public method instead of call and name it result. class Service def result # ... end end  Now, we have the following invocation: result = service.result if result.success? result.data else result.message end  ","version":"Next","tagName":"h2"},{"title":"So what is a Result? Its benefits?‚Äã","type":1,"pageTitle":"Results","url":"/basics/results#so-what-is-a-result-its-benefits","content":"Result is a data structure that satisfies the following properties: Firstly, it has a consolidated way to detect its state (success?, failure?, error?, and their counterparts with not like not_success?). Secondly, when the result is successful, you can be 100% sure that its data is correct, no additional verifications are needed (the notion of correctness is defined by the service author). Moveover, results induce you to always check them, before accessing their attributes, otherwise an exception is raised. Also, when something goes wrong, the result contains a description of the reason (result.message), which simplifies finding the source of the problem. ","version":"Next","tagName":"h2"},{"title":"Services","type":0,"sectionRef":"#","url":"/basics/services","content":"","keywords":"","version":"Next"},{"title":"What is a service?‚Äã","type":1,"pageTitle":"Services","url":"/basics/services#what-is-a-service","content":"Service is an object that does only one operation, nothing more, nothing less. Service may usually be implemented as follows: class Service def call # ... end end  It has a single public method, often named call or run, process, perform, etc, that is used to invoke its logic. service = Service.new service.call  ","version":"Next","tagName":"h2"},{"title":"Why do we need services?‚Äã","type":1,"pageTitle":"Services","url":"/basics/services#why-do-we-need-services","content":"Hang on a minute! According to the definition above, a service is almost the same as a regular function/method. Why do we need a new concept? ‚Äî A curious developer Usual Ruby methods may solve similar problems as services most of the time. Moreover, when it is possible to achieve the task only by using plain methods, it is almost always preferable. As a result, services should NOT be considered competitors or replacements for methods, they are additions to them. It is like a new option in the development toolbox. You have primitives, methods, classes, etc, and now there is an ability to use a service. For example, removing duplicates from an array can be implemented in multiple ways, you decide whether to utilize an array, hash or a set, depending on your environment limitations. The same case is with services. Just use them when you feel they bring advantages compared to other approaches. ","version":"Next","tagName":"h2"},{"title":"Service goals","type":0,"sectionRef":"#","url":"/basics/service_goals","content":"","keywords":"","version":"Next"},{"title":"What is the service goal?‚Äã","type":1,"pageTitle":"Service goals","url":"/basics/service_goals#what-is-the-service-goal","content":"The service goal is the desired effect of an action/operation. What does it mean in practise? Imagine the service below: class FindUser # ... def initialize(user_id:) @user_id = user_id end def result # ... end end  Its desired effect is the found user record. Simple and straightforward. So, if you are a developer who wants to utilize this service, the only reason why you would decide to do it is to get the user record. Thus the following conclusion can be made. We always invoke a service to achieve some concrete goal defined by the service author. In other words, we call a service to resolve some specific problem stated by the service name. ","version":"Next","tagName":"h2"},{"title":"Service problem resolutions‚Äã","type":1,"pageTitle":"Service goals","url":"/basics/service_goals#service-problem-resolutions","content":"Let's come back to the FindUser service and add some basic implementation for it. class FindUser include ::ConvenientService::Standard::Config def initialize(user_id:) @user_id = user_id end def result return error(&quot;User id in NOT an integer&quot;) unless user_id.instance_of?(::Integer) user = ::User.find_by(id: user_id) return failure(&quot;NO user with id `#{user_id}`&quot;) unless user success(user: user) end end  result = FindUser.result(user_id: user_id) # =&gt; `success`, `failure` or `error`.  As you can see, it may return one of the three possible result types that represent different resolutions. Each of them has a specific meaning. The success result communicates to its caller the positive service problem resolution, since the found user record is returned as expected. The failure result provides the negative resolution, because the user record does not exist in database. The error result gives no resolution at all, since the service no even tried to complete the user lookup. ","version":"Next","tagName":"h2"},{"title":"Steps","type":0,"sectionRef":"#","url":"/basics/steps","content":"","keywords":"","version":"Next"},{"title":"What is a step?‚Äã","type":1,"pageTitle":"Steps","url":"/basics/steps#what-is-a-step","content":"After a while service logic may grow into more complicated and less straightforward. Therefore, a future developer spends more time trying to figure out what is going on. That is probably an inevitable process since: Complex problem can not have non-complex solution in a global sense. But a particular step (piece) from that solution can be simple. ‚Äî Own savvy That is what steps are all about. As soon as you start to see that service logic becomes too difficult to digest for a minute or two. It is a clear sign that you need to split it into multiple sub-services and combine them back into a step sequence. This is how it looks in practice: class PurchaseBook # ... step AuthenticateUser, in: :user_id, out: :user step SearchBooks, in: [:title, :author_id], out: [:book, :count] step VerifyPaymentMethod, in: :user step CalculatePrice in: :book, out: {price: :price_without_discount} step ApplyDiscounts, in: [:book, {price: :price_without_discount}], out: {price: :price_with_discount} # ... end  For the sake of completeness, here is the same service, but without steps: class PurchaseBook # ... def result authenticate_user_result = AuthenticateUser.result(user_id: user_id) return authenticate_user_result unless authenticate_user_result.success? user = authenticate_user_result.data[:user] search_book_result = SearchBook.result(title: title, author_id: author_id) return search_book_result if search_book_result.not_success? # NOTE: One service may return multiple values if needed. book = search_book_result.data[:book] count = search_book_result.data[:count] verify_payment_method = VerifyPaymentMethod.result(user: user) return verify_payment_method unless verify_payment_method.success? calculate_price_result = CalculatePrice.result(book: book) return calculate_price_result if calculate_price_result.not_success? # NOTE: Aliasing `data[:price]` to `price_without_discount`. price_without_discount = calculate_price_result.data[:price] apply_discounts_result = ApplyDiscounts.result(book: book, price: :price_without_discount) return apply_discounts_result unless apply_discounts_result.success? # NOTE: Aliasing `data[:price]` to `price_with_discount`. price_with_discount = apply_discounts_result.data[:price] # ... end end  Looks pretty impressive, isn't it? So steps are just regular services, but their declarative interface hides the boilerplate code. They are executed in the same order as they are defined. If any intermediate step service result is not successful, the step sequence is stopped, and that unsuccessful result is returned (similar to Railway Oriented Programming). ","version":"Next","tagName":"h2"},{"title":"delegate_to","type":0,"sectionRef":"#","url":"/api/tests/rspec/matchers/delegate_to","content":"","keywords":"","version":"Next"},{"title":"What is delegate_to?‚Äã","type":1,"pageTitle":"delegate_to","url":"/api/tests/rspec/matchers/delegate_to#what-is-delegate_to","content":"delegate_to is a custom RSpec matcher that provides a neat way to check whether a delegation was performed as expected. For example, consider the following code snippet: class FirstService attr_reader :params def initialize(params:) @params = params end def result # ... SecondService.result(params: params) end end  As you can see, the first service asks the second one to do some &quot;interesting&quot; stuff and returns its value. This behavior can be easily tested in RSpec like so: RSpec.describe FirstService do describe &quot;.result&quot; do let(:params) { {foo: :bar} } it &quot;delegates to `SecondService.result`&quot; do # Creates a spy. allow(SecondService).to receive(:result).and_call_orginal FirstService.result(params: params) # Confirms delegation. expect(SecondService).to have_received(:result) end it &quot;returns `SecondService.result`&quot; do # Confirms return value equality. expect(FirstService.result(params: params)).to eq(SecondService.result(params: params)) end end end  Since it is so common to write specs as above when working with services, the delegate_to matcher is provided to hide the repeatable noise. RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:params) { {foo: :bar} } it &quot;delegates to `SecondService.result`&quot; do expect { FirstService.result(params: params) }.to delegate_to(SecondService, :result) end it &quot;returns `SecondService.result`&quot; do # Confirms return value equality. expect(FirstService.result(params: params)).to eq(SecondService.result(params: params)) end end end  delegate_to has a self-explanatory and_return_its_value chaining, so we can refactor out the second spec as well. RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:kwargs) { {foo: :bar} } it &quot;delegates to and returns `SecondService.result`&quot; do expect { FirstService.result(params: params) } .to delegate_to(SecondService, :result) .and_return_its_value end end end  danger and_return_its_value uses RSpec eq to compare values, therefore ensure your return values define meaningful == operator. Also delegate_to supports with_arguments chaining to make sure that delegation happened with certain arguments. RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:params) { {foo: :bar} } it &quot;delegates to and returns `SecondService.result`&quot; do expect { FirstService.result(params: params) } .to delegate_to(SecondService, :result) .with_arguments(params: params) .and_return_its_value end end end  This spec can be simplified even further. RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:params) { {foo: :bar} } specify do expect { FirstService.result(params: params) } .to delegate_to(SecondService, :result) .with_arguments(params: params) .and_return_its_value end end end  When specify is utilized, RSpec infers spec description from delegate_to arguments and chainings. ","version":"Next","tagName":"h2"},{"title":"delegate_to is context-independent‚Äã","type":1,"pageTitle":"delegate_to","url":"/api/tests/rspec/matchers/delegate_to#delegate_to-is-context-independent","content":"In other words, delegate_to is applicable for any classes, not only for services, e.g: class Notifier # ... def broadcast_event(*args, **kwargs, &amp;block) Event.create(*args, **kwargs, &amp;block) end end  With specs: RSpec.describe Notifier do describe &quot;#broadcast_event&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:notifier) { create(:notifier) } let(:args) { :foo } let(:kwargs) { {foo: :bar} } let(:block) { proc { :foo } } specify do expect { notifier.broadcast_event(*args, **kwargs, &amp;block) } .to delegate_to(Event, :create) .with_arguments(*args, **kwargs, &amp;block) .and_return_its_value end end end  Please, note that delegate_to is able to verify block argument (&amp;block) that is not possible with raw allow to receive. danger Blocks (procs, lambdas) are compared by RSpec eq under the hood. Please, remember their semantics in order to not be overly surprised. The two Proc instances may look the same from the syntax point of view. But they are different from the Proc semantics point of view. first = proc { :foo } second = proc { :foo } first == second # =&gt; false first == first # =&gt; true second == second # =&gt; true  ","version":"Next","tagName":"h2"},{"title":"Success","type":0,"sectionRef":"#","url":"/basics/success","content":"","keywords":"","version":"Next"},{"title":"What is a success?‚Äã","type":1,"pageTitle":"Success","url":"/basics/success#what-is-a-success","content":"Success is a kind of result when the service objective is fully satisfied. All errors and failures preconditions are met. Every validation check is passed. There is no obstacle that prohibits achieving the service goal. In general, a service must have one and only one reason to return success. note No sense to hide the truth, sometimes it is really necessary to return multiple success cases from a single service (For example, fake HTTP responses for external testing systems). As a rule of thumb, if you start to feel that you have such a scenario, always prefer to think about how to create multiple services instead. If not, be ready to strongly argue why your situation is truly exceptional and unavoidable. ","version":"Next","tagName":"h2"},{"title":"Success data‚Äã","type":1,"pageTitle":"Success","url":"/basics/success#success-data","content":"Success results may have some data (So-called Boolean Services are often without success data). Data is a hash-like structure with values received by service processing. Example: class FetchPopularVideos # ... def result # ... # Actual logic to fetch videos. # ... success( own_channel_videos: own_channel_videos, followers_videos: followers_videos, all_videos: own_channel_videos.concat(followers_videos) ) end end  With invocation: result = FetchPopularVideos.result if result.success? # No `data` checks here, since `result.success?` guarantees that `result.data[:all_videos]` are 100% valid. markup = result.data[:all_videos].map { |video| generate_markup(video) }.join # ... end  ","version":"Next","tagName":"h2"},{"title":"Avoid error shadowing","type":0,"sectionRef":"#","url":"/best_practices/avoid_error_shadowing","content":"","keywords":"","version":"Next"},{"title":"What is an error shadowing?‚Äã","type":1,"pageTitle":"Avoid error shadowing","url":"/best_practices/avoid_error_shadowing#what-is-an-error-shadowing","content":"Error shadowing is a hiding of the original cause of the problem. A common use case may be always returning a 404 HTTP error code in production, even when the real code is different. This way you make it a little bit harder for a possible attacker to find security holes in your web application. danger A professional web attacker may easily exploit any kind of security vulnerabilities. That is why it is so important to be extremely careful. Please, constantly impove your security skills. Securing Rails Applications and OWASP: Ruby on Rails Cheat Sheet are good places to revisit from time to time. Also it is popular to rescue low-level exceptions to encapsulate internal details from the end-user. The following example is taken directly from the Rails codebase: def download_chunk(key, range) instrument :download_chunk, key: key, range: range do file_for(key).download(range: range).string rescue Google::Cloud::NotFoundError raise ActiveStorage::FileNotFoundError end end  As you can see, the original exception message is dropped and not reused anywhere. ","version":"Next","tagName":"h2"},{"title":"When does error shadowing happen with services?‚Äã","type":1,"pageTitle":"Avoid error shadowing","url":"/best_practices/avoid_error_shadowing#when-does-error-shadowing-happen-with-services","content":"Using Convenient Service, you may encounter an error shadowing as well. But as always, any approach may have advantages and disadvantages. To illustrate that, check the service below: class MainService # ... def result return error(message: &quot;Something went wrong&quot;) unless sub_service_result.success? # ... success end private def sub_service_result @sub_service_result ||= SubService.result end # ... end  MainService looks innocent, but the problem starts to appear when you execute it. result = MainService.result result.success? # =&gt; false result.message # =&gt; &quot;Something went wrong&quot;  result.message does NOT help to figure out what is actually wrong. SubService is failing in reality, but it is NOT reflected in the outside world in any way. If you don't want to intentionally confuse the service users or hide the internals from them, prefer to forward the original message. class MainService # ... def result return error(message: &quot;Something went wrong (#{sub_service_result.message})&quot;) unless sub_service_result.success? # ... success end # ... end  It is also OK to immediately return SubService result when you don't need to provide any additional text to its message, since it also avoids error shadowing. class MainService # ... def result return sub_service_result unless sub_service_result.success? # ... success end # ... end  But the best option is to utilize the step macro. It works as the previous example under the hood and when used frequently - helps to forget about error shadowing in the context of services completely. class MainService step SubService # ... def result # This line is removed... # ... success end # ... end  note If you are not safisfied how step automatically prevents error shadowing - consider to create a plugin to extend/modify it. ","version":"Next","tagName":"h2"},{"title":"Cast feature arguments inside entries","type":0,"sectionRef":"#","url":"/best_practices/fdd/cast_feature_arguments_inside_entries","content":"Cast feature arguments inside entries Usually, features have their own entities to represent their domain. Entry is the best place where outside-world objects can be cast into them. For example, consider the User entity for the LoginSession feature. module Features class LoginSession module Entities class User def initialize(email:, password:) @email = email @password = password end def self.cast(object) if object.instance_of?(::User) Entities::User.new(email: object.email_address, password: object.encrypted_password) else # ... end end # ... end end end end This is how an entry may convert a raw user object into feature specific entity. module Features class LoginSession include ConvenientService::Feature::Standard::Config def start(**kwargs) kwargs[:user] = Entities::User.cast(kwargs[:user]) Services::Login.result(**kwargs) end end end ","keywords":"","version":"Next"},{"title":"Invoke proxy middleware behavior via public method","type":0,"sectionRef":"#","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method","content":"","keywords":"","version":"Next"},{"title":"How?‚Äã","type":1,"pageTitle":"Invoke proxy middleware behavior via public method","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method#how","content":"## # Okish. # module Plugins module CanHaveConnectedSteps class Middleware &lt; MethodChainMiddleware intended_for :result, entity: :service def next(...) return chain.next(...) if entity.steps.none? entity.steps.each_evaluated_step do |step| step.save_outputs_in_organizer! # ... end entity.steps.result end end end end  ## # Better. # module Plugins module CanHaveConnectedSteps class Middleware &lt; MethodChainMiddleware intended_for :result, entity: :service def next(...) return chain.next(...) if entity.steps.none? entity.steps_result(...) end end end end module Plugins module CanHaveConnectedSteps module Concern include Support::Concern instance_methods do def steps_result # ... steps.each_evaluated_step do |step| step.save_outputs_in_organizer! # ... end steps.result end # ... end end end end  ","version":"Next","tagName":"h2"},{"title":"Why?‚Äã","type":1,"pageTitle":"Invoke proxy middleware behavior via public method","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method#why","content":"It allows end-users to create middlewares specifically for proxy middleware behavior. For example: ## # Good. # class Service include ConvenientService::Standard::Config middlewares :steps_result do # ... end # ... end It decreases the amount of type checks. Without the extracted method, the end-user requries to utilize type checks to distinguish return values. ## # Bad. # class Middleware &lt; MethodChainMiddleware intended_for :result, entity: :service def next(...) result = chain.next(...) if result.from_step? # Type check. some_logic_with(result) else # ... end end end ## # Better. # class Middleware &lt; MethodChainMiddleware intended_for :step_result, entity: :service def next(...) result = chain.next(...) some_logic_with(result) end end It decreases the amount of order-dependent middlewares. It simplifies specs. Methods are easier to tests than middlewares. ","version":"Next","tagName":"h2"},{"title":"Why not?‚Äã","type":1,"pageTitle":"Invoke proxy middleware behavior via public method","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method#why-not","content":"When proxy middleware behavior is truly private. ","version":"Next","tagName":"h2"},{"title":"Describe feature public interface using entries","type":0,"sectionRef":"#","url":"/best_practices/fdd/describe_feature_public_interface_using_entries","content":"Describe feature public interface using entries This way it becomes easier to get an overview of what a feature can do. Here is an example of the Gemfile feature. module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format entry :lint entry :update entry :regenerate def format # ... end def lint # ... end def update # ... end def regenerate # ... end end end Having a quick eye on the list of entries you immediately realize that there are abilities to format, lint, update, and regenerate Gemfiles. Now, check out the RequestParams feature. module Features class RequestParams include ConvenientService::Feature::Standard::Config entry :extract_from_url_path entry :extract_from_url_query entry :extract_from_body def extract_from_url_path # ... end def extract_from_url_query # ... end def extract_from_body # ... end end end The same story, once you review the entries' names, you get the idea of what the RequestParams feature is about. It gives the opportunity to extract parameters from the request body and URL path/query.","keywords":"","version":"Next"},{"title":"Skip `result` call for boolean services","type":0,"sectionRef":"#","url":"/best_practices/skip_result_call_for_boolean_services","content":"Skip `result` call for boolean services Let's check the following boolean service: class IsConnectionActive include ::ConvenientService::Standard::Config attr_reader :connection def initialize(:connection) @connection = connection end def result return error(&quot;Connection: can't be blank&quot;) if connection.blank? return failure(&quot;Connection `#{connection.id}` is NOT connected&quot;) unless connection.connected? return failure(&quot;Connection `#{connection.id}` has NO task&quot;) if connection.task.blank? return failure(&quot;Connection `#{connection.id}` task is NOT in progress&quot;) unless connection.task.in_progres? success end end A common way to run a usual service is like this: # okish result = IsConnectionActive.result(connection: connection) if result.success? ## # `result.data` is processed somehow by the end-user here... # result.data else end Most of the time you will probably work with result.data inside if result.success? branch. But that is not the case for the boolean services. Their success calls do NOT accept any data, that is why the previous chunk of code can be written in a shorter form: # better if IsConnectionActive.success?(connection: connection) else end ","keywords":"","version":"Next"},{"title":"Translation table","type":0,"sectionRef":"#","url":"/basics/step_to_result_translation_table","content":"","keywords":"","version":"Next"},{"title":"No in or out‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#no-in-or-out","content":"Definition: step AssertNodeAvailable  Translation: def step_result @step_result ||= AssertNodeAvailable.result end  ","version":"Next","tagName":"h3"},{"title":"One in usual method‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#one-in-usual-method","content":"Definitions (equivalent): step ValidateUncastedParams, in: :params  step ValidateUncastedParams, in: [ :params ]  Translation: def step_result @step_result ||= ValidateUncastedParams.result( params: params ) end  ","version":"Next","tagName":"h3"},{"title":"Multiple in usual methods‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#multiple-in-usual-methods","content":"Definition: step LogRequestParams, in: [ :request, :params ]  Translation: def step_result @step_result ||= LogRequestParams.result( request: request, params: params ) end  ","version":"Next","tagName":"h3"},{"title":"One in alias method‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#one-in-alias-method","content":"Definitions (equivalent): step ValidateCastedParams, in: {casted_params: :params}  step ValidateCastedParams, in: [ {casted_params: :params} ]  Translation: def step_result @step_result ||= ValidateCastedParams.result( casted_params: params ) end  ","version":"Next","tagName":"h3"},{"title":"Multiple in alias method‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#multiple-in-alias-method","content":"Definitions: step AuditContent, in: [ {content: :content_without_comments}, {verbose: :debug} ]  Translation: def step_result @step_result ||= AuditContent.result( content: content_without_comments, verbose: debug ) end  ","version":"Next","tagName":"h3"},{"title":"One out usual method‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#one-out-usual-method","content":"Definitions (equivalent): step ReadFileContent, in: :path, out: :content  step ReadFileContent, in: :path, out: [ :content ]  Translation: def step_result @step_result ||= ReadFileContent.result( path: path ) end def content step_result.data[:content] end  ","version":"Next","tagName":"h3"},{"title":"Multiple out usual methods‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#multiple-out-usual-methods","content":"Definition: step CastParams, in: :params, out: [ :original_params, :casted_params ]  Translation: def step_result @step_result ||= CastParams.result( params: params ) end def original_params step_result.data[:original_params] end def casted_params step_result.data[:casted_params] end  ","version":"Next","tagName":"h3"},{"title":"One out alias method‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#one-out-alias-method","content":"Definitions (equivalent): step FormatHeader, in: :parsed_content, out: {formatted_content: :formatted_header_content}  step FormatHeader, in: :parsed_content, out: [ {formatted_content: :formatted_header_content} ]  Translation: def step_result @step_result ||= FormatHeader.result( parsed_content: parsed_content ) end def formatted_header_content step_result.data[:formatted_content] end  ","version":"Next","tagName":"h3"},{"title":"Multiple out alias methods‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#multiple-out-alias-methods","content":"Definition: step ExtractParamsFromRequest, in: :request, out: [ {header_params: :request_params_from_header}, {body_params: :request_params_from_body} ]  Translation: def step_result @step_result ||= ExtractParamsFromRequest.result( request: request ) end def request_params_from_header step_result.data[:header_params] end def request_params_from_body step_result.data[:body_params] end  ","version":"Next","tagName":"h3"},{"title":"One in raw value‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#one-in-raw-value","content":"Definitions (equivalent): step AssertFeatureEnabled, in: {name: raw(:chat_v2)}  step AssertFeatureEnabled, in: [ {name: raw(:chat_v2)} ]  Translation: def step_result @step_result ||= AssertFeatureEnabled.result( name: :chat_v2 ) end  ","version":"Next","tagName":"h3"},{"title":"Multiple in raw values‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#multiple-in-raw-values","content":"Definitions (equivalent): step PrintShellCommand, in: [ {text: raw(&quot;ls -a&quot;)} {stream: raw($stdout)} ]  Translation: def step_result @step_result ||= PrintShellCommand.result( text: &quot;ls -a&quot;, stream: $stdout ) end  info in raw values are useful for passing values, constants, methods, etc from the class scope. step PrintShellCommand, in: [ {text: raw(display_directory_structure_command)} {stream: raw($stdout)} ] def self.display_directory_structure_command &quot;ls -a&quot; end  ","version":"Next","tagName":"h3"},{"title":"One in proc method‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#one-in-proc-method","content":"Definitions (equivalent): step RemoveDirectoryRecursively, in: {path: -&gt;{ &quot;/tmp&quot; }}  step RemoveDirectoryRecursively, in: [ {path: -&gt;{ &quot;/tmp&quot; }} ]  Translation: def step_result @step_result ||= RemoveDirectoryRecursively.result( path: &quot;/tmp&quot; ) end  ","version":"Next","tagName":"h3"},{"title":"Multiple in proc methods‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#multiple-in-proc-methods","content":"Definition: step CreateSoftLink, in: [ {source: -&gt;{ &quot;~/.bash_profile&quot; }}, {destination: -&gt;{ &quot;#{Dir.pwd}/bash_profile_link&quot; }} ]  Translation: def step_result @step_result ||= CreateSoftLink.result( source: &quot;~/.bash_profile&quot;, destination: &quot;#{Dir.pwd}/bash_profile_link&quot; ) end  info in proc methods are useful for passing values, constants, methods, etc from the instance scope. step CreateSoftLink, in: [ {source: -&gt;{ &quot;~/.bash_profile&quot; }}, {destination: -&gt;{ generate_destination_path }} ] def generate_destination_path &quot;#{Dir.pwd}/bash_profile_link&quot; end  ","version":"Next","tagName":"h3"},{"title":"All-in-one example:‚Äã","type":1,"pageTitle":"Translation table","url":"/basics/step_to_result_translation_table#all-in-one-example","content":"Definition: ENV[&quot;API_ONLY&quot;] = true class UpdatePost include ConvenientService::Standard::Config PERMITTED_PARAMS = [:id, :format, :title, :description, :tags, :sources] attr_reader :http_string # ... step PrepareRequestObject in: [ :http_string, {url_pattern: raw(url_pattern)}, {role: -&gt;{ admin? }}, {permitted_keys: raw(PERMITTED_PARAMS)} {defaults: -&gt;{ resolve_defaults_values }} ], out: [ :params_from_path, :params_from_body, {headers: :request_headers} ] # ... def self.url_pattern /^\\/rules\\/(?&lt;id&gt;\\d+)\\.(?&lt;format&gt;\\w+)$/ end def admin? false end def resolve_defaults_values defaults_values = {format: &quot;html&quot;, tags: [], sources: []} defaults_values[:format] = &quot;json&quot; if ENV[&quot;API_ONLY&quot;] defaults_values end # ... end  Translation: ENV[&quot;API_ONLY&quot;] = true class UpdatePost include ConvenientService::Standard::Config PERMITTED_PARAMS = [:id, :format, :title, :description, :tags, :sources] attr_reader :http_string # ... def step_result @step_result ||= PrepareRequestObject.result( http_string: http_string, url_pattern: /^\\/rules\\/(?&lt;id&gt;\\d+)\\.(?&lt;format&gt;\\w+)$/, role: admin?, # =&gt; false permitted_keys: [:id, :format, :title, :description, :tags, :sources], defaults: resolve_defaults_values # =&gt; {format: &quot;json&quot;, tags: [], sources: []} ) end def params_from_path step_result.data[:params_from_path] end def params_from_body step_result.data[:params_from_body] end def request_headers step_result.data[:headers] end # ... def self.url_pattern /^\\/rules\\/(?&lt;id&gt;\\d+)\\.(?&lt;format&gt;\\w+)$/ end def admin? false end def resolve_defaults_values defaults_values = {format: &quot;html&quot;, tags: [], sources: []} defaults_values[:format] = &quot;json&quot; if ENV[&quot;API_ONLY&quot;] defaults_values end # ... end  note def step_result is used to express the concept. In reality, such a method is not generated by the Convenient Service under the hood. It utilizes a lower-level toolset that is out of the scope of this guide. ","version":"Next","tagName":"h3"},{"title":"Service has only one `success`","type":0,"sectionRef":"#","url":"/best_practices/service_has_only_one_success","content":"Service has only one `success` Most of the time it is relatively easy to follow this rule. Consider the following service: class BuildDisplayName include ::ConvenientService::Standard::Config attr_reader :person def initialize(person:) @person = person end def result return error(&quot;Person can't be blank&quot;) if person.blank? success(display_name: &quot;#{person.first_name} #{persom.last_name}&quot;) end end It currently has no conditional logic to build the display_name. After a while, our system started to grow and it appears that some people would like to see their pseudo in place of display names. Let's reflect on that change in the code using a naive approach: class BuildDisplayName include ::ConvenientService::Standard::Config attr_reader :person def initialize(person:) @person = person end def result return error(&quot;Person can't be blank&quot;) if person.blank? if person.has_pseudonym? success(display_name: person.pseudonym) else success(display_name: &quot;#{person.first_name} #{persom.last_name}&quot;) end end end Having two success calls inside the result is what we try to avoid. Why? It encourages future devs to write deeply nested conditionals. It interferes with the layering of information. You don't need to know the details of the implementation until it is really necessary. The code above tells you about pseudonyms too early, even if you are not interested in them. If you refactor BuildDisplayName like this: class BuildDisplayName include ::ConvenientService::Standard::Config def initialize(person:) @person = person end def result return error(&quot;Person can't be blank&quot;) if person.blank? success(display_name: display_name) end private def display_name @display_name ||= person.has_pseudonym? ? person.pseudonym : &quot;#{person.first_name} #{persom.last_name}&quot; end end Then the result describes which data it may return and when it is NOT successful, just that. Only when you are curious about how display_name is exactly built, feel free to check private methods. This is how the layering of information works in practice. Nesting is replaced by a flat ternary operator. It is time to have a look at the specs: # spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe BuildDisplayName do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(person: person) } context &quot;when building of display name is NOT successful&quot; do context &quot;when `person` is blank&quot; do let(:person) { nil } it &quot;returns `error`&quot; do expect(result).to be_error.with_message(&quot;Person can't be blank&quot;).of_service(described_class).without_step end end end context &quot;when building of display name is successful&quot; do context &quot;when `person` does NOT have pseudonym&quot; do let(:person) { Person.new(&quot;John&quot;, &quot;Doe&quot;) } it &quot;returns `success` with first name and last name as display name&quot; do expect(result).to be_success.with_data(display_name: &quot;John Doe&quot;).of_service(described_class).without_step end end context &quot;when `person` has pseudonym&quot; do let(:person) { Person.new(&quot;John&quot;, &quot;Doe&quot;, preudonym: &quot;Gorilla&quot;) } it &quot;returns `success` with pseudonym as display name&quot; do expect(result).to be_success.with_data(display_name: &quot;Gorilla&quot;).of_service(described_class).without_step end end end end end end As you can see, specs still have two contexts for successful cases and that is completely OK. Now, we are ready for the conclusion: A fact that a Service has only one success actually means that the service calls success inside result only once. But that success can still have multiple variations of data values, just like display_name in BuildDisplayName service.","keywords":"","version":"Next"},{"title":"Services with `or` conditionals","type":0,"sectionRef":"#","url":"/best_practices/services_with_or_conditionals","content":"Services with `or` conditionals Convenient Service shines very brightly when you have and conditional logic. It is very easy to construct such behavior using the step DSL. Check out the following service: class RefreshSubscription include ::ConvenientService::Standard::Config attr_reader :user, :subscription_id step IsSubscriptionOwner, in: [:user, :subscription_id] step FindSubscription, in: :subscription_id, out: :subscription step RegenerateSubscriptionTokens in: :subscription, out: :tokens step UploadSubscriptionTokens in: :subscription, out: :tokens def initialize(:user, :subscription_id) @user = user @subscription_id = subscription_id end end Let's use the pseudo notation below to describe a sequence of steps from RefreshSubscription as and conditionals: `IsSubscriptionOwner` and `FindSubscription` and `RegenerateSubscriptionTokens` and `UploadSubscriptionTokens`. Pretty simple and straightforward. But, but, but üò¢... What should we do when we have some or conditionals? For example, two additional requirements are introduced to the one we had before: Super admin can refresh any user subscriptions. A user with a special ability can refresh other user's subscriptions. User can refresh its own subscription (already existing requirement). In our pseudo notation it will look like this: `IsSuperAdmin` or `HasAbility`or `IsSubscriptionOwner` and `FindSubscription` and `RegenerateSubscriptionTokens` and `UploadSubscriptionTokens` It is not the time to give up üò≠. The list of to-do actions is not so long: Create a new service which name generalizes all or conditions, for instance - IsAuthorizedForSubscriptionRefresh. Then the updated pseudo notation can be displayed as: `IsAuthorizedForSubscriptionRefresh` and `FindSubscription` and `RegenerateSubscriptionTokens` and `UploadSubscriptionTokens` Now, we can utilize all the step DSL s usual. class RefreshSubscription # ... step IsAuthorizedForSubscriptionRefresh, in: [:user, :subscription_id] step FindSubscription, in: :subscription_id, out: :subscription step RegenerateSubscriptionTokens in: :subscription, out: :tokens step UploadSubscriptionTokens in: :subscription, out: :tokens # ... end Prepare a common template for a service with or conditionals. Here it is for our particular case: class IsAuthorizedForSubscriptionRefresh include ::ConvenientService::Standard::Config attr_reader :user, :subscription_id def initialize(:user, :subscription_id) @user = user @subscription_id = subscription_id end def result # TODO: Implement end private def is_super_admin_result @is_super_admin_result ||= IsSuperAdmin.result(user: user) end def has_ability_result @has_ability_result ||= HasAbility.result(user: user, ability: :refresh_someone_else_subscription) end def is_subscription_owner_result @is_subscription_owner_result ||= IsSubscriptionOwner.result(user: user, subscription_id: subscription_id) end end Implement the result method. Before we move on to the final polished chuck of code, let's discuss the common anti-patterns. Please, welcome deeply nested if statements and multiple success calls. Zombie version üßü‚Äã # bad - zombie def result if is_super_admin_result.not_success? if has_ability_result.not_success? if is_subscription_owner_result.not_success? error( &quot;All conditions are not satisfied:&quot; + &quot; and &quot; + is_super_admin_result.message + &quot; and &quot; + has_ability_result.message + &quot; and &quot; + is_subscription_owner_result.message ) else success end else success end else success end end Although, this code is &quot;perfect&quot; from the performance point of view and it works exactly as needed according to the requirements... Please, do not commit it. Just imagine what will happen with an additional fourth or fifth condition. How can we make it simpler and more readable? Use or_step. SourceRSpec class CreateButton include ConvenientService::Standard::Config step CreateWebButtonFactory, in: :app, out: :button or_step CreateAndroidButtonFactory, in: :app, out: {action: :button} or_step CreateIosButtonFactory, in: :app, out: {control: :button} or_step CreateDesktopButtonFactory, in: :app, out: {knob: :button} step :result, in: :app, out: :button attr_reader :app def initialize(:app) @app = app end def result success(button: button) end end ","keywords":"","version":"Next"},{"title":"Imports and exports via dependency containers","type":0,"sectionRef":"#","url":"/deprecations/imports_and_exports_via_dependency_containers","content":"Imports and exports via dependency containers The purpose of entry is significantly simpler to explain than import/export.","keywords":"","version":"Next"},{"title":"What is the purpose of Standard::V1::Config?","type":0,"sectionRef":"#","url":"/faq/what_is_purpose_of_v1_config","content":"What is the purpose of Standard::V1::Config? Convenient Service is a young library in the constant process of polishing its public interface. As a result, some breaking changes may still happen. ConvenientService::Standard::V1::Config is a config that was created to delay the migration of services that were created by older Convenient Service versions. Specifically, v0.12.0 and lower.","keywords":"","version":"Next"},{"title":"JSend meaning of failure and error","type":0,"sectionRef":"#","url":"/deprecations/jsend_meaning_of_failure_and_error","content":"JSend meaning of failure and error Usage of ConvenientService::Standard::V1::Config.","keywords":"","version":"Next"},{"title":"Is it possible to modify the step collection from a callback?","type":0,"sectionRef":"#","url":"/faq/is_it_possible_to_modify_step_collection_from_callback","content":"Is it possible to modify the step collection from a callback? No‚ùó That is done by design. One of the main Convenient Service goals is the representation of the complex logic as a sequence of simple declarative steps. This idea is completely lost when a callback allows modification of step collection. Right after the first such mutation, you can not rely on what you see. In order to make sure, that the steps declared at the build time are actually the same at runtime, you need to check implementation of every callback. This contradicts the Clean Code definition. class Service include ConvenientService::Standard::Config step :one step :two step :three before :step do byebug steps.clear # =&gt; FrozenError end def one puts &quot;one&quot; success end def two puts &quot;two&quot; success end def three puts &quot;three&quot; success end end Service.result ","keywords":"","version":"Next"},{"title":"Why `case/when` does NOT work with just result codes?","type":0,"sectionRef":"#","url":"/faq/why_case_when_does_not_work_with_jus_result_codes","content":"Why `case/when` does NOT work with just result codes? Sometimes it may feel idiomatic to check the result code in the following way: # wrong if result.not_success? case result.code # `result.code` returns fancy object when :full_queue notify_devops when :duplicated_job notify_devs else # ... end end Although this snippet looks very appealing, it won't work as expected. A lot of Ruby folks often have an assumption that a value of case is compared with a value of when. case value === when value In other words, the case/when from example above can be transformed to if/else like so: # wrong if result.not_success? if result.code === :full_queue notify_devops elsif result.code === :duplicated_job notify_devs else # ... end end But, that is NOT correct. In reality, the value of when is always compared with the value of case. when value === case value Let's write the proper transformation: # okish if result.not_success? if :full_queue === result.code notify_devops elsif :duplicated_job === result.code notify_devs else # ... end end Symbol#=== is just an alias to Symbol#==. There is no way to hook into any behavior like with strings (String#=== calls to_str on its argument). As a result, just case result.code is not enough. But once you use case result.code.to_sym, the natural Ruby charm is back. # ok if result.not_success? case result.code.to_sym when :full_queue notify_devops when :duplicated_job notify_devs else # ... end end ","keywords":"","version":"Next"},{"title":"Decorator Middleware","type":0,"sectionRef":"#","url":"/glossary/advanced/decorator_middleware","content":"Decorator Middleware A decorator middleware is a kind of middleware that always calls the next middleware in a chain. HasCallbacks is a good example. module ConvenientService module Common module Plugins module HasCallbacks class Middleware &lt; Core::MethodChainMiddleware # ... def next(...) entity.callbacks.for([:before, method]).each { |callback| callback.call_in_context(entity) } original_value = chain.next(...) entity.callbacks.for([:after, method]).reverse_each { |callback| callback.call_in_context(entity, original_value) } original_value end # ... end end end end end It triggers before callbacks, then chain.next(...), and later after callbacks. There are no conditionals that may skip chain.next(...) invocation. That is why this middleware is considered decorator middleware. In contrast, proxy middlewares may not call chain.next if needed.","keywords":"","version":"Next"},{"title":"Standard::V1::Config","type":0,"sectionRef":"#","url":"/glossary/advanced/standard_v1","content":"Standard::V1::Config ConvenientService::Standard::V1::Config is an outdated service configuration. It was created as a reaction to the breaking change introduced between ConvenientService v0.13.0 and v0.14.0 versions. Its development is currently stopped and it won't receive any updates, except critical backports. This config already lacks of new plugins for fallbacks and extended ROP concepts. And this list will grow up over time. If you have any old services that are using ConvenientService::Standard::V1::Config, please don't worry too much. Luckily, the migration process is pretty strightforward.","keywords":"","version":"Next"},{"title":"Why errors? Why not exceptions?","type":0,"sectionRef":"#","url":"/faq/why_error_not_exception","content":"","keywords":"","version":"Next"},{"title":"Unhandled exceptions are crashing important flows for minor reasons too often‚Äã","type":1,"pageTitle":"Why errors? Why not exceptions?","url":"/faq/why_error_not_exception#unhandled-exceptions-are-crashing-important-flows-for-minor-reasons-too-often","content":"Imagine we have a travel app. A typical apartment booking flow may look like the following. User opens the application. User selects location, dates, guest number, etc. User books an apartment. Host accepts the booking. User pays for the apartment. And so on... After a while, a new requirement is received to display a small discount proposals widget for the apartments that are located in the not popular regions. Business truly and argumentably believes that such a feature will increase the conversion rate. The region popularity detection algorithm is developed by a different team, which swears that it works as expected, but the unit tests are not finished due to other commitments. With constant pressure from the higher management, an inexperienced developer agrees to add the widget with the subsequent release. Once the new app version is deployed, apartment selection starts to crash, preventing the users from completing bookings. The rest is history. Massive panic. Endless late-night meetings and discussions. DevOps engineers who know how to roll back the change are on vacation. End-users are posting negative feedback on their social media, etc. Instead of increasing the conversion rate, it is now significantly degraded. The moral of the story is that the new feature was added in a non fault-tolerant way. Sure, the discount widget is a useful functionality when properly implemented. But, it is just a tiny component in the context of the full apartment booking flow. Thus not having a feature-specific exception handler for it is an unjustified risk. That is why Convenient Service promotes the idea of using error results instead of regular exceptions. They help to develop fault-tolerant systems right from the beginning. Let's tackle a more ground-facing example, that every Ruby developer experiences from time to time. Data and time formatting ü•≤. A minimal code snippet to illustrate the issue is the following: require &quot;date&quot; def format_date(string) Date.strptime(string, &quot;%Y-%m-%d&quot;) end  Once the user's browser localization format changes, the format_date method breaks the whole page by raising invalid date (Date::Error) exceptions. format_date(&quot;2024/07/16&quot;) # =&gt; # `strptime': invalid date (Date::Error) # # Date.strptime(string, &quot;%Y-%m-%d&quot;) # ^^^^^^^^^^^^^^^^^^  At the same time, a corresponding service encloses unhandled exceptions by converting them into error results. require &quot;convenient_service&quot; ConvenientService::Dependencies.require_rescues_result_unhandled_exceptions class FormatDate include ConvenientService::Standard::Config attr_reader :string middlewares :result do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end def initialize(string:) @string = string end def result formatted_date = Date.strptime(string, &quot;%Y-%m-%d&quot;) success(formatted_date: formatted_date) end end  Technically speaking, it creates so-called exception boundaries. result = FormatDate.result(string: &quot;2024/07/16&quot;) # =&gt; # &lt;FormatDate::Result status: :error data_keys: [:exception] message: &quot;Date::Error: # ... #  As a consequence, only a single service has an unpredicted mistake, but since its negative effect is isolated, the rest of the system stays functional. Due to the fact that unhandled exceptions can not leak outside error results boundaries, the code becomes fault-tolerant by default. info Currently, the RescuesResultUnhandledExceptions plugin is not included in the Standard configuration. End-users have the ability to decide by themselves whether to add it or not. For example, the best practice says to use it for development and production environments. This way you can learn how the plugin works during development and have a calm and healthy sleep when the code is released. But for the testing environment, it is still beneficial to not auto rescue exceptions to find them faster. caution This article demonstrates the concept that there is a possibility of an automated fallback for exceptions. However, developers still need to reasonably predict the edge cases and describe them explicitly in order to have more explanatory error messages. So, the properly finished FormatDate service is written below. class FormatDate include ConvenientService::Standard::Config attr_reader :string middlewares :result do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end def initialize(string:) @string = string end def result success(date_time: ::DateTime.strptime(string, format)) rescue ::Date::Error error(&quot;String `#{string}` does NOT follow date time `#{format}`&quot;) end end  ","version":"Next","tagName":"h2"},{"title":"Proxy Middleware","type":0,"sectionRef":"#","url":"/glossary/advanced/proxy_middleware","content":"Proxy Middleware A proxy middleware is a kind of middleware that may skip calling the next middleware in a chain. CachesReturnValue is a good example. module ConvenientService module Common module Plugins module CachesReturnValue class Middleware &lt; Core::MethodChainMiddleware # ... def next(*args, **kwargs, &amp;block) key = cache.keygen(:return_values, method, *args, **kwargs, &amp;block) cache.fetch(key) { chain.next(*args, **kwargs, &amp;block) } end # ... end end end end end When the cache does NOT contain any value by key, it calls the next middleware in the chain and stores its return value. When the cache already contains a value by key, it does NOT trigger the next middleware at all. That is why this middleware is considered proxy middleware. In contrast, decorator middlewares always call chain.next. note cache.fetch in CachesReturnValue has the same semantics as Ruby's Hash#fetch.","keywords":"","version":"Next"},{"title":"Clean Code","type":0,"sectionRef":"#","url":"/glossary/clean_code","content":"Clean Code When: The author's intention is obvious.In less than 10 minutes.With minimal context.Without diving into implementation.Without running that code. caution By the Convenient Service custom definition.","keywords":"","version":"Next"},{"title":"Why failures and errors? Why not just failure or error?","type":0,"sectionRef":"#","url":"/faq/why_both_failure_and_error","content":"","keywords":"","version":"Next"},{"title":"Failure and errors have different fallbacks‚Äã","type":1,"pageTitle":"Why failures and errors? Why not just failure or error?","url":"/faq/why_both_failure_and_error#failure-and-errors-have-different-fallbacks","content":"Consider the following user story. As a doctor I would like to see a list of the patient's allergies. The list is received from the third-party API. Sometimes a controller for this task may be implemented as follows. controllers/allergies_controller.rb class AllergiesController &lt; ApplicationController # ... def index # `response` is a `Hash`. response = ApiClient.get( &quot;/allergies&quot;, params: {patient_id: allowed_patient_id} ) @allergies = response.dig(:data, :allergies) end end  And the corresponding view. views/allergies/index.html.erb &lt;h2&gt;Allergies&lt;/h2&gt; &lt;% if @allergies.present? %&gt; &lt;% @allergies.each do |allergy| %&gt; &lt;p&gt; &lt;div&gt; Name: &lt;%= allergy[:name] %&gt; &lt;/div&gt; &lt;div&gt; Symptoms: &lt;%= allergy[:symptoms].join(&quot;, &quot;) %&gt; &lt;/div&gt; &lt;/p&gt; &lt;% end %&gt; &lt;% else %&gt; &lt;span&gt; Patient has no allergies. &lt;/span&gt; &lt;% end %&gt;  The code may look innocent from the first point of view, but the devil is in the details. In a case, the API response has an unexpected format, response.dig(:data, :allergies) returns nil. Then @allergies.present? is evaluated as false in the view. As a consequence, the &quot;Patient has no allergies&quot; string is displayed in the doctor's browser. Just try to imagine what may happen when a doctor blindly relies on the page text üò¨? Unfortunately, a code with similar problems sometimes may be written even by senior developers üò¢. That is the main reason of why Convenient Service differentiate failures and errors. Sure, the lib still can NOT 100% guarantee the complete elimination of the issue. However, it encourages the users to think about fallbacks and split the failures and errors from the beginning. The curiosity or the confusion that people feel when they find it difficult to decide whether to use a failure or an error works as a provocation for them to open and read this article. This way they become aware of the issue and share it with others more frequently. Refactoring using Convenient Service is the following: controllers/allergies_controller.rb class FetchAllergies include ::ConvenientService::Standard::Config # ... def result return error(&quot;API response does not have `data` key&quot;) unless response.has_key?(:data) return error(&quot;API response data does not have `allergies` key&quot;) unless response[:data].has_key?(:allergies) return failure(&quot;Patient `#{allowed_patient_id}` has no allergies&quot;) if response[:data][:allergies].empty? success(allergies: response[:data][:allergies]) end private def response # `response` is a `Hash`. @response ||= ApiClient.get(&quot;/allergies&quot;, params: {patient_id: allowed_patient_id}) end end  controllers/allergies_controller.rb class AllergiesController &lt; ApplicationController # ... def index @fetch_allergies_result = FetchAllergies.result(allowed_patient_id: allowed_patient_id) end end  views/allergies/index.html.erb &lt;h2&gt;Allergies&lt;/h2&gt; &lt;% if @fetch_allergies_result.success? %&gt; &lt;% @fetch_allergies_result.data[:allergies].each do |allergy| %&gt; &lt;p&gt; &lt;div&gt; Name: &lt;%= allergy[:name] %&gt; &lt;/div&gt; &lt;div&gt; Symptoms: &lt;%= allergy[:symptoms].join(&quot;, &quot;) %&gt; &lt;/div&gt; &lt;/p&gt; &lt;% end %&gt; &lt;% elsif @fetch_allergies_result.failure? %&gt; &lt;span&gt; Patient has no allergies. &lt;/span&gt; &lt;% else # @fetch_allergies_result.error? %&gt; &lt;span&gt; No allergies information available. &lt;/span&gt; &lt;div&gt; Try to refresh the page after a while. &lt;div&gt; &lt;div&gt; If the issue persists please contact the support. &lt;/div&gt; &lt;% end %&gt;  The code is more verbose, but that is the price of reliability. Using the service goal resolution terminology, this is what we have as a summary. @fetch_allergies_result.success? means that a patient 100% has allergies (positive service goal resolution). That is why we freely display them. @fetch_allergies_result.failure? means that a patient 100% has NO allergies (negative service goal resolution). So we are confident in the &quot;Patient has no allergies&quot; text. @fetch_allergies_result.error? means that even after service invocation, we still don't know whether a patient has allergies or not (no service goal resolution at all). Due to that, we are telling the truth that &quot;No allergies information available&quot; instead of the false-negative resolution that we had before the separation of failure and errors. ","version":"Next","tagName":"h2"},{"title":"How to debug the lib?","type":0,"sectionRef":"#","url":"/guides/advanced/debugging/how_to_debug_lib","content":"How to debug the lib? Convenient Service has already more than 5000 unit and integration tests. That is not the end, more specs are constantly added to cover even the craziest cases. But since it is relatively a new library something unpredicatable may still happen. Prefer to create a GitHub issue, when you encounter unexpected behavior. However, if you are curious and enthusiastic enough, you can always try to dive deep and debug the &quot;nifty&quot; inner parts by yourself. First of all, navigate to the directory with a project that uses Convenient Service as a dependency. cd your_project In other words, you have it in your project Gemfile like so: Gemfile gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Make sure Convenient Service is installed. bundle install Open the gem source. Set the EDITOR env variable to your favorite code editing tool. The command below uses VS Code. EDITOR=code bundle open convenient_service Select any file you need and place a debugger call in it. The following example utilizes byebug. Start your project (irb console, Rails server, RSpec suite, Rake tasks) to trigger the code that seems to be broken. Happy debugging! danger Do not forget to erase the debugger call once finished debugging. caution binding.pry is an amazing instrument, but is NOT a debugger, it is a REPL. REPL has a completely different purpose, it can enhance the debugger, but not replace it. A casual REPL does not support even half of the possibilities that a mature debugger provides. Just to name some of them, line-by-line debugging, up and down stack navigation, dynamic breakpoints, etc. Don't like byebug since it does not highlight the syntax ü§¶? Then this gist is for you. Still don't like byebug? Use binding.break - a modern debugger developed by the Ruby core team.","keywords":"","version":"Next"},{"title":"Entry","type":0,"sectionRef":"#","url":"/glossary/fdd/entry","content":"Entry Entry is a single part of the feature's public interface. Let's check the following feature class. module Application module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do |path:| Services::Format.result(path: path) end entry :lint do |path:| Services::Lint.result(path: path) end end end end After a brief overview, you should start to have a high-level understanding of the goal of the Gemfile feature and what to do with it in practice. In this particular case, two abilities are available: Formatting of a Gemfile (entry :format). Linting of a Gemfile (entry :lint). Calling of an entry is as simple as: # Somewhere inside your codebase. App::Features::Gemfile.format(path: &quot;Gemfile&quot;) App::Features::Gemfile.lint(path: &quot;Gemfile&quot;) That's why people are often thinking about entries as something really close to Ruby's regular class methods. ## # The actual entry. # entry :format do |path:| Services::Format.result(path: path) end ## # Just a mental concept to imagine entries as wrappers over class methods (under the hood they are something not so straightforward, but this is a topic for a different story). # def self.format(path:) Services::Format.result(path: path) end Eventually, a list of entries may and must be considered as a Facade in front of the complex system. tip While having a code review of a new (or existing) feature, prefer to check its list of entries at the very beginning. This is the way to quickly get a summary of the feature and its main purpose. In other words, to get so-called &quot;minimal context&quot;. After that, the intention of the internal feature services may become more obvious (hopefully üôÇ). tip In order to find all feature triggers, just search for entries invocations using your favorite code editor.","keywords":"","version":"Next"},{"title":"How to access result attributes without checking its status?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_access_result_attributes_without_checking_its_status","content":"","keywords":"","version":"Next"},{"title":"Use Result#unsafe_data, Result#unsafe_message, Result#unsafe_code‚Äã","type":1,"pageTitle":"How to access result attributes without checking its status?","url":"/guides/debugging/how_to_access_result_attributes_without_checking_its_status#use-resultunsafe_data-resultunsafe_message-resultunsafe_code","content":" ","version":"Next","tagName":"h2"},{"title":"Even better, use shorter aliases Result#ud, Result#um, Result#uc‚Äã","type":1,"pageTitle":"How to access result attributes without checking its status?","url":"/guides/debugging/how_to_access_result_attributes_without_checking_its_status#even-better-use-shorter-aliases-resultud-resultum-resultuc","content":" ","version":"Next","tagName":"h2"},{"title":"Boolean Service","type":0,"sectionRef":"#","url":"/glossary/boolean_service","content":"Boolean Service Boolean service is a service that confirms/denies the concrete assumption. Boolean service is a service that answers to the specific question. Boolean service is a service whose success result has no data. success result from the boolean service confirms the assumption stated in its name. In other words, it answers positively to the question. failure result from the boolean service tells why exactly the assumption is NOT accurate. In other words, it answers negatively to the question + provides the reason. error result explains why there is no even hypothetical opportunity to confirm/deny the assumption. In other words, it gives no answer to the question at all. Here are some examples of such services: class IsEmployeeFree attr_reader :employee def initialize(employee:) @employee = employee end def result return error(&quot;Employee can't be blank&quot;) if employee.blank? return failure(&quot;Employee `#{employee.id}` has task `#{employee.tasks.find(&amp;:in_progress?).id}` in progress&quot;) if employee.tasks.any?(&amp;:in_progress?) success end end IsEmployeeFree assumes that an employee is available. The following command either confirms or denies that assumption. IsEmployeeFree.success?(employee: employee) class IsTaskUnassigned attr_reader :task def initialize(task:) @task = task end def result return error(&quot;Task can't be blank&quot;) if task.blank? return failure(&quot;Task `#{task.id}` has employee `#{task.employee}`&quot;) if task.employee.present? success end end IsTaskUnassigned asks a question - is a task not assigned to anyone? The expression below answers it either positively or negatively. IsEmployeeFree.success?(employee: employee) Also as with any other type of service, the boolean service can be triggered via the result method or a step: result = IsEmployeeFree.result(employee: employee) class AssignTaskToEmployee include ConvenientService::Standard::Config attr_reader :task, :employee step IsTaskUnassigned, in: :task step IsEmployeeFree, in: :employee def initialize(task:, employee:) @task = task @employee = employee end def result task.employee = employee saved = task.save return failure(&quot;Employee `#{employee.id}` is NOT saved to task `#{task.id}`&quot;) unless saved success end end ","keywords":"","version":"Next"},{"title":"How to access result original service?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_access_result_original_service","content":"How to access result original service? The Result#service method returns the service instance that created its result. For example: class Service include ConvenientService::Standard::Config def result success end end result = Service.result # =&gt; &lt;Service::Result status: :success&gt; result.service # =&gt; &lt;Service&gt; When the result is bubbled up from a deeply nested step, the Result#service method returns a top-level organizer instance. Let's see it in practice: class TwoLevelsNestedService include ConvenientService::Standard::Config def result success end end class OneLevelNestedService include ConvenientService::Standard::Config step TwoLevelsNestedService end class Service include ConvenientService::Standard::Config step OneLevelNestedService end result = Service.result # =&gt; &lt;Service::Result status: :success&gt; result.service # =&gt; &lt;Service&gt; Here, the TwoLevelsNestedService creates a success result. Later this result is processed by steps from the OneLevelNestedService and Service services. That is why it becomes the Service overall result. result.service # =&gt; &lt;Service&gt; Sometimes it may be useful to access the original service instance, e.g. for debugging purposes. For that reason the Result#original_service method is available. result.original_service # =&gt; &lt;TwoLevelsNestedService&gt; ","keywords":"","version":"Next"},{"title":"How to print library logs?","type":0,"sectionRef":"#","url":"/guides/advanced/logging/how_to_print_lib_logs","content":"","keywords":"","version":"Next"},{"title":"Log levels‚Äã","type":1,"pageTitle":"How to print library logs?","url":"/guides/advanced/logging/how_to_print_lib_logs#log-levels","content":"It is possible to configure internal library logging by using the CONVENIENT_SERVICE_LOGGER_LEVEL env variable. It is defaulting to info, which is why the majority of the logs are skipped most of the time. But you can modify this behavior by setting a different severity level. Just place the env variable in front of the command that starts your Ruby process which utilizes Convenient Service. For example: CONVENIENT_SERVICE_LOGGER_LEVEL=debug bundle exec rails console  Since the Convenient Service logger is based on the Ruby stdlib Logger, it supports the same levels. Here is the screenshot straight from its official docs.  danger When your project uses Ruby stdlib Logger with a version older than 1.3.0, then log levels as words are not supported yet. Pass numbers in such cases. CONVENIENT_SERVICE_LOGGER_LEVEL=0 bundle exec rails console  ","version":"Next","tagName":"h2"},{"title":"Colored logs‚Äã","type":1,"pageTitle":"How to print library logs?","url":"/guides/advanced/logging/how_to_print_lib_logs#colored-logs","content":"If you have Ruby Paint gem as a dependency, and it is required, then CONVENIENT_SERVICE_LOGGER_ENABLE_COLORS env variable activates coloring like so: CONVENIENT_SERVICE_LOGGER_LEVEL=0 CONVENIENT_SERVICE_LOGGER_ENABLE_COLORS=true bundle exec rails console  ","version":"Next","tagName":"h2"},{"title":"Configuration via script‚Äã","type":1,"pageTitle":"How to print library logs?","url":"/guides/advanced/logging/how_to_print_lib_logs#configuration-via-script","content":"Convenient Service logger can be accessed inside any Ruby source as well. For example: ConvenientService.logger.level = Logger::INFO  ","version":"Next","tagName":"h2"},{"title":"How to find result step?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_find_result_step","content":"","keywords":"","version":"Next"},{"title":"Use Result#step‚Äã","type":1,"pageTitle":"How to find result step?","url":"/guides/debugging/how_to_find_result_step#use-resultstep","content":" ","version":"Next","tagName":"h2"},{"title":"How to find result parents?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_find_result_parents","content":"","keywords":"","version":"Next"},{"title":"Use Result#parents‚Äã","type":1,"pageTitle":"How to find result parents?","url":"/guides/debugging/how_to_find_result_parents#use-resultparents","content":" ","version":"Next","tagName":"h2"},{"title":"How to rescue all result unhandled exceptions?","type":0,"sectionRef":"#","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions","content":"","keywords":"","version":"Next"},{"title":"Use RescuesResultUnhandledExceptions plugin‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#use-rescuesresultunhandledexceptions-plugin","content":"danger RescuesResultUnhandledExceptions plugin intentionally rescues only StandardErrors, not Exceptions. info RescuesResultUnhandledExceptions plugin is especially useful for the Fault Tolerant production environments. caution RescuesResultUnhandledExceptions plugin is NOT included in the Standard config by default. It is up to the end-users to decide whether it is needed for thier applications or not. ","version":"Next","tagName":"h2"},{"title":"Option 1: Modify config to rescue results in all services‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#option-1-modify-config-to-rescue-results-in-all-services","content":" ConvenientService::Dependencies.require_rescues_result_unhandled_exceptions  module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config middlewares :result, scope: :class do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end end end end end  class Service include ApplicationService::Config def result raise StandardError, &quot;exception message&quot; end end  ","version":"Next","tagName":"h3"},{"title":"Option 2: Modify service to rescue results in a single service‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#option-2-modify-service-to-rescue-results-in-a-single-service","content":" ConvenientService::Dependencies.require_rescues_result_unhandled_exceptions  module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config end end end end  class Service include ApplicationService::Config middlewares :result, scope: :class do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end def result raise StandardError, &quot;exception message&quot; end end  ","version":"Next","tagName":"h3"},{"title":"Result with exception becomes an error‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#result-with-exception-becomes-an-error","content":" info Convenient Service core team strongly believes that it is a responsibility of a developer to predict all possible exceptions reasonably. That is why the result is an error, not a failure. result = Service.result  result.success?  puts result.message  ","version":"Next","tagName":"h2"},{"title":"Result has access to the original exception object‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#result-has-access-to-the-original-exception-object","content":"info result.data[:exception] is Ruby's StandardError object that inherits from Exception.  result.data[:exception]  result.data[:exception].class  result.data[:exception].message  result.data[:exception].backtrace.to_a.take(10)  result.data[:exception].cause  ","version":"Next","tagName":"h2"},{"title":"How to debug services via callbacks?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_debug_services_via_callbacks","content":"","keywords":"","version":"Next"},{"title":"Use after result‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-after-result","content":"after :result do |result| binding.pry end  ","version":"Next","tagName":"h2"},{"title":"Use after step‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-after-step","content":"## # Step is Result-like duck. # after :step do |step| byebug end  ","version":"Next","tagName":"h2"},{"title":"Use around result‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-around-result","content":"after :result do |chain| puts &quot;before&quot; result = chain.yield p &quot;after&quot; end  ","version":"Next","tagName":"h2"},{"title":"Use after step‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-after-step-1","content":"## # Step is Result-like duck. # after :step do |step| binding.break step = chain.yield print &quot;after&quot; end  ","version":"Next","tagName":"h2"},{"title":"Real-world example‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#real-world-example","content":"# frozen_string_literal: true module Services class AssertNpmPackageAvailable include ConvenientService::Standard::Config attr_reader :name step :validate_name step Services::AssertNodeAvailable step Services::RunShell, in: {command: -&gt; { &quot;npm list #{name} --depth=0 &gt; /dev/null 2&gt;&amp;1&quot; }} after :result do |result| binding.pry end after :step do |step| byebug end def initialize(name:) @name = name end private def validate_name return error(&quot;Name is `nil`&quot;) if name.nil? return error(&quot;Name is empty&quot;) if name.empty? success end end end  ","version":"Next","tagName":"h2"},{"title":"How to migrate from `Standard::V1`?","type":0,"sectionRef":"#","url":"/guides/advanced/deprecations/how_to_migrate_from_standard_v1","content":"How to migrate from `Standard::V1`? Consider the following old service that is using the outdated ConvenientService::Standard::V1::Config. class AssertFileNotEmpty include ConvenientService::Standard::V1::Config attr_reader :path def initialize(path:) @path = path end def result return failure(path: &quot;Path is \\`nil\\`&quot;) if path.nil? return failure(path: &quot;Path is empty&quot;) if path.empty? return error(&quot;File is empty at path \\`#{path}\\`&quot;) if ::File.zero?(path) success end end Its specs may look like this: require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results include ConvenientService::RSpec::Matchers::IncludeModule let(:result) { described_class.result(path: path) } example_group &quot;modules&quot; do subject { described_class } it { is_expected.to include_module(ApplicationService::Config) } end example_group &quot;class methods&quot; do describe &quot;.result&quot; do context &quot;when assertion that file exists is NOT successful&quot; do context &quot;when `path` is NOT valid&quot; do context &quot;when `path` is `nil`&quot; do let(:path) { nil } it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is `nil`&quot;).of_service(described_class).without_step end end context &quot;when `path` is empty&quot; do let(:path) { &quot;&quot; } it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is empty&quot;).of_service(described_class).without_step end end end context &quot;when file with `path` does NOT exist&quot; do let(:path) { &quot;non_existing_path&quot; } it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;File with path `#{path}` does NOT exist&quot;).of_service(described_class).without_step end end end context &quot;when assertion that file exists is successful&quot; do ## # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection. # let(:tempfile) { Tempfile.new } let(:path) { tempfile.path } it &quot;returns `success`&quot; do expect(result).to be_success.of_service(described_class).without_step end end end end end In order to migrate it, we need to perform four actions: Rename the outdated configuration to the modern one. class AssertFileNotEmpty # before include ConvenientService::Standard::V1::Config # after include ConvenientService::Standard::Config # ... end Rename failures and errors results inside the source code. class AssertFileNotEmpty # ... # before def result return failure(path: &quot;Path is \\`nil\\`&quot;) if path.nil? return failure(path: &quot;Path is empty&quot;) if path.empty? return error(&quot;File is empty at path \\`#{path}\\`&quot;) if ::File.zero?(path) success end # after def result return error(&quot;Path is \\`nil\\`&quot;) if path.nil? return error(&quot;Path is empty&quot;) if path.empty? return failure(&quot;File is empty at path \\`#{path}\\`&quot;) if ::File.zero?(path) success end end caution This update should NOT be &quot;blind&quot;. Make sure failures and errors are used according to their meanings. Rename failures and errors results inside the specs. require &quot;spec_helper&quot; RSpec.describe AssertFileExists do # ... # before it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is `nil`&quot;).of_service(described_class).without_step end # after it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;Path is `nil`&quot;).of_service(described_class).without_step end # before it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is empty&quot;).of_service(described_class).without_step end # after it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;Path is empty&quot;).of_service(described_class).without_step end # before it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;File with path `#{path}` does NOT exist&quot;).of_service(described_class).without_step end # after it &quot;returns `failure` with `message`&quot; do expect(result).to be_failure.with_message(&quot;File with path `#{path}` does NOT exist&quot;).of_service(described_class).without_step end # ... end caution Again, please, ensure that failures and errors are used according to their meanings. Otherwise, this renaming makes no sense. Repeat the same procedure for the rest services that are using ConvenientService::Standard::V1::Config. danger Do not mix services with the modern and outdated configurations. For example, that is possible with steps. Instead, update all outdated services at once or delay this refactoring for the better times. If you structure your services as isolated features, then refactor the whole feature.","keywords":"","version":"Next"},{"title":"Setup in Minitest","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_minitest","content":"Setup in Minitest Currently Convenient Service does not have Minitest extentions üò¢. But they are planned for subsequent releases ü•π. Consequently, the setup process is pretty much the same as for the regular Ruby project. Happy testing!","keywords":"","version":"Next"},{"title":"Setup in RSpec","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_rspec","content":"Setup in RSpec As always, add a new entry to your Gemfile as the first step. gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Then run bundle to install the gem. bundle install Add the following line to your spec_helper.rb or rails_helper.rb. ConvenientService::Dependencies.require_rspec_extentions To ensure Convenient Service RSpec extentions are properly loaded, define a quick service, for example: lib/service.rb class Service include ConvenientService::Standard::Config def result success end end Create the specs for it. spec/service_spec.rb RSpec.describe Service do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result } context &quot;when `Service` is successful&quot; do it &quot;returns `success`&quot; do expect(result).to be_success.of_service(described_class).with_data.without_step end end end end end Finally, run them. bundle exec rspec spec/service_spec.rb That's it. Happy testing!","keywords":"","version":"Next"},{"title":"Setup in a Ruby project","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_ruby","content":"Setup in a Ruby project As always, add a new entry to your Gemfile as the first step. gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Then run bundle to install the gem. bundle install Once finished, require the gem. require &quot;convenient_service&quot; To ensure the lib is properly loaded you can define the following service. class Service include ConvenientService::Standard::Config def result success end end And run it by the command below. Service.result That's it. Happy coding!","keywords":"","version":"Next"},{"title":"Setup in a Rails project","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_rails","content":"Setup in a Rails project As always, add a new entry to your Gemfile as the first step. gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Then run bundle to install the gem. bundle install To mimic the classic Rails folder structure, you may consider creating app/services directory like so: mkdir -p app/services But feel free to select other directory if you like. app/services is chosen for a demonstration since it is autoloaded by Rails. Place a configuration file into it. A common name may be application_service/config.rb. mkdir -p app/services/application_service &amp;&amp; touch app/services/application_service/config.rb This example utilizes Standard or Rails configs, but you can also pick any other predefined configuration, create customization, or even have multiple configs. StandardRails app/services/application_service/config.rb module ApplicationService module Config include ConvenientService::Config included do include ConvenientService::Standard::Config end end end Now you have everything ready to create fancy services for your application. (Do not forget to include config into them üôÇ) StandardRails app/services/print_what_cow_says.rb class PrintWhatCowSays include ApplicationService::Config attr_reader :text def initialize(text: &quot;Hello World!&quot;) @text = text end def result puts template(text) success end private ## # Copied with ‚ù§Ô∏è from https://github.com/gaborbata/rosetta-cow # def template(text) cloud = &lt;&lt;~HEREDOC #{border(text, &quot;_&quot;)} &lt; #{text} &gt; #{border(text, &quot;-&quot;)} HEREDOC cow = &lt;&lt;~'HEREDOC'.split(&quot;\\n&quot;).map { |line| &quot; &quot; * 10 + line }.join(&quot;\\n&quot;) \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || HEREDOC cloud + cow end def border(text, char) char * (text.length + 2) end end That's it. Happy coding!","keywords":"","version":"Next"},{"title":"How to use entries?","type":0,"sectionRef":"#","url":"/guides/fdd/usage/how_to_create_and_invoke_entries","content":"","keywords":"","version":"Next"},{"title":"How to create an entry?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-create-an-entry","content":"There are two ways to do it - block and method forms. This is how it can be done using the block form. module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do Services::Format.result(path: &quot;#{::Dir.pwd}/Gemfile&quot;) end end end  The following code snippet demonstrates the equivalent method form. module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format def format Services::Format.result(path: &quot;#{::Dir.pwd}/Gemfile&quot;) end end end  ","version":"Next","tagName":"h2"},{"title":"How to define arguments for entries?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-define-arguments-for-entries","content":"Since entries are built on the top of the regular Ruby blocks and methods you are able to utilize the techniques that you already know. Here are some examples of how to define positional and keyword arguments. The block form: module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do |path, verbose: false| Services::Format.result(path: path, verbose: verbose) end end end  The method form: module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format def format(path, verbose: false) Services::Format.result(path: path, verbose: verbose) end end end  Entries with variable arguments list may look like as follows. The block form: module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do |*args, **kwargs, &amp;block| path = args.first verbose = block ? block.call : kwargs[:verbose] Services::Format.result(path: path, verbose: verbose) end end end  The method form: module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format def format(*args, **kwargs, &amp;block) path = args.first verbose = block ? block.call : kwargs[:verbose] Services::Format.result(path: path, verbose: verbose) end end end  ","version":"Next","tagName":"h2"},{"title":"How to invoke an entry?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-invoke-an-entry","content":"No matter whether an entry was defined by a block or by a method, its invocation is the same, e.g: Features::Gemfile.format  Features::Gemfile.format(path, verbose: true)  Features::Gemfile.format(*args, **kwargs, &amp;block)  ","version":"Next","tagName":"h2"},{"title":"How to add a middleware for all entries?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-add-a-middleware-for-all-entries","content":"Check the following feature. module Features class SomeFeature include ConvenientService::Feature::Standard::Config entry :some_entry_without_arguments entry :some_entry_with_arguments def some_entry_without_arguments puts &quot;Entry `some_entry_without_arguments` called.&quot; end def some_entry_with_arguments(*args, **kwargs, &amp;block) puts &quot;Entry `some_entry_with_arguments` called.&quot; end end end  It has two entries that are displaying some text on the screen. For example: Features::SomeFeature.first_entry # =&gt; &quot;Entry `first_entry` called.&quot;  Features::SomeFeature.second_entry # =&gt; &quot;Entry `second_entry` called.&quot;  Now, let's define a simple middleware. class TestMiddleware &lt; ConvenientService::MethodMiddleware def next(entry_name, *args, **kwargs, &amp;block) puts &quot;`TestMiddleware` called for entry `#{entry_name}` with args `#{args.inspect}`, kwargs `#{kwargs.inspect}` and block `#{block.inspect}`.&quot; chain.next(entry_name, *args, **kwargs, &amp;block) end end  It logs the entry name and its arguments. Then it triggers the original entry behaviour. In order to register a middleware for all entries inside the particular feature, use the middlewares :entry directive. module Features class SomeFeature include ConvenientService::Feature::Standard::Config middlewares :entry do use TestMiddleware end entry :some_entry_without_arguments entry :some_entry_with_arguments def some_entry_without_arguments puts &quot;Entry `some_entry_without_arguments` called.&quot; end def some_entry_with_arguments(*args, **kwargs, &amp;block) puts &quot;Entry `some_entry_with_arguments` called.&quot; end end end  Now the TestMiddleware is executed before any entry invocation. This is how it looks in practice. Features::SomeFeature.some_entry_without_arguments # =&gt; &quot;`TestMiddleware` called for entry `some_entry_without_arguments` with args `[]`, kwargs `{}` and block `nil`.&quot; # =&gt; &quot;Entry `some_entry_without_arguments` called.&quot;  Features::SomeFeature.some_entry_with_arguments(:foo, foo: :bar) { :foo } # =&gt; &quot;`TestMiddleware` called for entry `some_entry_with_arguments` with args `[:foo]`, kwargs `{:foo=&gt;:bar}` and block `#&lt;Proc:0x00000001227756c8.&gt;`.&quot; # =&gt; &quot;Entry `some_entry_with_arguments` called.&quot;  ","version":"Next","tagName":"h2"},{"title":"How to add a middleware for the specific entry?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-add-a-middleware-for-the-specific-entry","content":"The process is almost the same as with the addition of a middleware for all entries. But the arguments list does not start with positional entry_name. info It is still possible to access entry_name via method method üôÇ. class TestMiddleware &lt; ConvenientService::MethodMiddleware def next(*args, **kwargs, &amp;block) puts &quot;`TestMiddleware` called for entry `#{method}` with args `#{args.inspect}`, kwargs `#{kwargs.inspect}` and block `#{block.inspect}`.&quot; chain.next(*args, **kwargs, &amp;block) end end  The registration directive contains the specific entry name. module Features class SomeFeature include ConvenientService::Feature::Standard::Config middlewares :some_entry do use TestMiddleware end entry :some_entry entry :some_other_entry def some_entry(first_positional_argument, second_positional_argument) puts &quot;Entry `some_entry` called.&quot; end def some_other_entry puts &quot;Entry `some_other_entry` called.&quot; end end end  Thus the TestMiddleware is executed only before specific entry invocation. Features::SomeFeature.some_entry(:foo, :bar) # =&gt; &quot;`TestMiddleware` called for entry `some_entry` with args `[:foo, :bar]`, kwargs `{}` and block `nil`.&quot; # =&gt; &quot;Entry `some_entry` called.&quot;  All the other entries stay unaffected. Features::SomeFeature.some_other_entry # =&gt; &quot;Entry `some_other_entry` called.&quot;  ","version":"Next","tagName":"h2"},{"title":"How to create and invoke services?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_create_and_invoke_services","content":"","keywords":"","version":"Next"},{"title":"How to create a service?‚Äã","type":1,"pageTitle":"How to create and invoke services?","url":"/guides/usage/how_to_create_and_invoke_services#how-to-create-a-service","content":"Create a class, include some Convenient Service configuration, define the result method üôÇ. Here is the minimal example. class Service include ConvenientService::Standard::Config def result success end end  ","version":"Next","tagName":"h2"},{"title":"How to invoke a service?‚Äã","type":1,"pageTitle":"How to create and invoke services?","url":"/guides/usage/how_to_create_and_invoke_services#how-to-invoke-a-service","content":"There a two ways to do it. First one - using the class method result. result = Service.result  Second one - using the instance method result. service = Service.new result = service.result  info Most of the time you will utilize the class method variant (Service.result). But keep in my mind, that allocating a service instance may be useful when it is needed to delay result calculation. ","version":"Next","tagName":"h2"},{"title":"How to pass a value to step from class/instance scope?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_pass_value_to_step_class_or_instance_scope","content":"How to pass a value to step from class/instance scope? Let's consider the following service: class Service # ... step EscapeRegexp, \\ in: {pattern: ???}, # `???` is just a placeholder here, it is not a valid Ruby syntax. out: :escaped # ... end We need to pass ENV[&quot;PATH_PATTERN&quot;] to the EscapeRegexp step as the pattern param. How that can be achievable? There are multiple ways: Using raw. step EscapeRegexp, \\ in: {pattern: raw(ENV[&quot;PATH_PATTERN&quot;])}, out: :escaped This is how step call is &quot;translated&quot; to regular service invocation under the hood: def step_result @step_result ||= EscapeRegexp.result(pattern: ENV[&quot;PATH_PATTERN&quot;]) end Since raw is a class method you can pass it anything from the enclosing class scope. The value is forwarded without any intermediate processing. step EscapeRegexp, \\ in: {pattern: raw(any_class_method)}, out: :escaped Using proc form. step EscapeRegexp, \\ in: {pattern: -&gt; { ENV[&quot;PATH_PATTERN&quot;] }}, out: :escaped The proc form does not additionally process the passed value as well, but it is evaluated in the instance scope. So you can access any service instance methods in it. step EscapeRegexp, \\ in: {pattern: -&gt; { any_instance_method }}, out: :escaped info Check the Step to Result Translation table for more detailed reference.","keywords":"","version":"Next"},{"title":"Installation","type":0,"sectionRef":"#","url":"/installation","content":"","keywords":"","version":"Next"},{"title":"Bundler‚Äã","type":1,"pageTitle":"Installation","url":"/installation#bundler","content":"Add the following line to your Gemfile: gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot;  And then run: bundle install  ","version":"Next","tagName":"h2"},{"title":"Without Bundler‚Äã","type":1,"pageTitle":"Installation","url":"/installation#without-bundler","content":"Execute the command below: gem install convenient_service -v 0.19.1  info Convenient Service follows the Semantic Versioning standard. ","version":"Next","tagName":"h2"},{"title":"Requirements","type":0,"sectionRef":"#","url":"/requirements","content":"","keywords":"","version":"Next"},{"title":"Recommended‚Äã","type":1,"pageTitle":"Requirements","url":"/requirements#recommended","content":"Ruby 3+ ","version":"Next","tagName":"h2"},{"title":"Minimal‚Äã","type":1,"pageTitle":"Requirements","url":"/requirements#minimal","content":"Ruby 2.7 note Ruby 3+ provides some advanced features that are used internally to optimize performance. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/index","content":"","keywords":"","version":"Next"},{"title":"‚ùó‚ùó‚ùó WARNING ‚ùó‚ùó‚ùó‚Äã","type":1,"pageTitle":"Introduction","url":"/index#-warning-","content":"This library is under heavy development. Most of the public API is polished, but it still may be subject to change. It has already been successfully used in production environments for more than a year, but the first major version is planned for the second quarter of 2025. Use the current version at your own risk. Ruby 2.7+, JRuby 9.4+ (TruffleRuby support is planned as well). Thanks. ","version":"Next","tagName":"h2"},{"title":"Quick Links‚Äã","type":1,"pageTitle":"Introduction","url":"/index#quick-links","content":"Check out TL;DR. Visit the All-in-One Presentation to get a quick overview.  Copyright (c) 2022 - 2024 Marian Kostyk.  ","version":"Next","tagName":"h2"},{"title":"How to use service steps?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_use_steps","content":"","keywords":"","version":"Next"},{"title":"Which types of steps are available?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#which-types-of-steps-are-available","content":"The two criteria currently categorize steps. By action: service and method steps. By control flow: and, or, not steps. ","version":"Next","tagName":"h2"},{"title":"How to define a service step?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-define-a-service-step","content":"You can register existing services as steps of other services using the step directive. Let's have a look at it in practice. Having the Service service. class Service include ConvenientService::Standard::Config def result success end end  We can use it as a step of the OtherService service in the following way. class OtherService include ConvenientService::Standard::Config step Service end  This code works almost the same as: class OtherService include ConvenientService::Standard::Config def result Service.result end end  That is why for a single-step service the usage of steps may not seem very beneficial. So consider a more complex example. Now we have 3 services. class FooService include ConvenientService::Standard::Config def result success end end  class BarService include ConvenientService::Standard::Config def result success end end  class BazService include ConvenientService::Standard::Config def result success end end  The HostService uses them as steps. class HostService include ConvenientService::Standard::Config step FooService step BarService step BazService end  Rough HostService equivalent without steps may be implemented as follows: class HostService include ConvenientService::Standard::Config def result foo_result = FooService.result return foo_result unless foo_result.success? bar_result = BarService.result return bar_result unless bar_result.success? BazService.result end end  As you can see, steps allow us to eliminate at least 2 assignments and 2 if-conditionals for this particular example. Sure, those assignments and if-conditionals are still performed under the hood, but it is no longer a developer's responsibility to manage them. Now the benefit of steps becomes more obvious, but that is not the only benefit. Other guides are going to demonstrate the additional simplifications. ","version":"Next","tagName":"h2"},{"title":"How to define a method step?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-define-a-method-step","content":"Any method can be a step. The only requirement is that it must return a result. For example: class Service include ConvenientService::Standard::Config step :foo def foo success end end  ","version":"Next","tagName":"h2"},{"title":"What is the result of a service with steps?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#what-is-the-result-of-a-service-with-steps","content":"Consider the following service. class Service include ConvenientService::Standard::Config step :foo step :bar step :baz def foo success end def bar success end def baz success end end  When all steps are successful, the overall service result is the last step result. result = Service.result # =&gt; &lt;Service::Result status: :success&gt;  result.step # =&gt; &lt;Service::Step method: :baz&gt;  Let's check some other service. class OtherService include ConvenientService::Standard::Config step :foo step :bar step :baz def foo success end def bar failure(&quot;Message from `bar`&quot;) # `error(&quot;Message from `bar`&quot;)` also stops the sequence. end def baz raise &quot;Not raised exception&quot; success end end  When any step is NOT successful, the overall service result is that NOT successful step result. result = OtherService.result # =&gt; &lt;OtherService::Result status: :failure&gt;  result.step # =&gt; &lt;OtherService::Step method: :bar&gt;  It is important to note that the remaining steps are NOT even evaluated. That is why the exception from baz was not raised. ","version":"Next","tagName":"h2"},{"title":"My plugin is added to the config, but its middleware is never called","type":0,"sectionRef":"#","url":"/troubleshooting/added_config_but_middleware_never_called","content":"My plugin is added to the config, but its middleware is never called Some plugins are order-dependent. For example, CanHaveConnectedSteps has a middleware for the instance result method in the Standard config. middlewares :result do # ... use Plugins::Service::CanHaveConnectedSteps::Middleware # ... end If your plugin enhances the instance result method as well, you may be affected by CanHaveConnectedSteps. How? Let's check its source. module ConvenientService module Service module Plugins module CanHaveConnectedSteps class Middleware &lt; Core::MethodChainMiddleware def next(...) return chain.next(...) if entity.steps.none? # ... entity.steps.result end # ... end end end end end It works as a proxy middleware. When a service has no steps, CanHaveConnectedSteps just calls what is next in the middleware chain, by chain.next(...). Otherwise, it returns the last completed step result. Let's place, e.g. HasJSendResultParamsValidations::UsingActiveModelValidations plugin after CanHaveConnectedSteps in your application service config. module ApplicationService module Config include ConvenientService::Concern included do include ConvenientService::Standard::Config # ... middlewares :result do use ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware end end end end This way HasJSendResultParamsValidations::UsingActiveModelValidations is never called for services with steps. To fix that, locate it before CanHaveConnectedSteps like so: module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config # ... middlewares :result do insert_before \\ ConvenientService::Plugins::Service::CanHaveConnectedSteps::Middleware, ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware end end end end end Apart from insert_before, insert_after, insert_after_each, insert_before_each, replace, and delete are also available.","keywords":"","version":"Next"},{"title":"`AwesomePrintInspect` does not colorize results","type":0,"sectionRef":"#","url":"/troubleshooting/awesome_print_inspect_does_not_colorize_results","content":"`AwesomePrintInspect` does not colorize results Consider a service that includes the AwesomePrintInspect config. Here is the minimal example. ConvenientService::Dependencies.require_awesome_print_inspect class Service include ::ConvenientService::Standard::Config include ::ConvenientService::AwesomePrintInspect::Config def result success(foo: :bar, baz: :qux) end end When it is called from the console like IRB. Service.result The result should be pretty-printed by awesome_print. But it actually outputs some &quot;weird escape characters&quot; ^[[0;37m, ^[[0m or ^[[0;33m like in the screenshot below. One way to fix that problem is to activate Awesome Print IRB integration. AwesomePrint.irb! Thus the output is colorized as expected. In case you are using Pry, Awesome Print has integration for it as well. AwesomePrint.pry! ","keywords":"","version":"Next"},{"title":"How to use service results?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_use_results","content":"","keywords":"","version":"Next"},{"title":"Which result types/statuses are available?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#which-result-typesstatuses-are-available","content":"There are only 3 available statuses for service results. The success status is when the service goal is resolved positively. The failure status is when a service goal is resolved negatively. The error status is when the service goal is not resolved. Additional moves are required to get a failure or success instead. ","version":"Next","tagName":"h2"},{"title":"How to create success result?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-create-success-result","content":"Just call the success instance method and return it from result. class Service include ConvenientService::Standard::Config def result success end end  ","version":"Next","tagName":"h2"},{"title":"How to pass data to success result?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-pass-data-to-success-result","content":"To be explicit, you may use the data keyword. It accepts a hash with Symbol keys and any values. Like in the service below. class Service include ConvenientService::Standard::Config def result success(data: {foo: :bar, baz: :qux}) end end  But it is more common to omit it. class Service include ConvenientService::Standard::Config def result success(foo: :bar, baz: :qux) end end  ","version":"Next","tagName":"h2"},{"title":"How to access success result data?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-access-success-result-data","content":"Utilize round brackes [] on the result data object. result = Service.result if result.success? result.data[:foo] # =&gt; bar end  info A self-explanatory exception is raised when data is accessed before the status is checked. result = Service.result result.data[:foo] # =&gt; Raises exception since result status is NOT checked... That is by design. The intention is to encourage developers to think about fallbacks from the beginning. For example, to define reasonable else. if result.success? result.data[:foo] # =&gt; bar else # Fallback. end Or to check for failure and error as well. if result.success? result.data[:foo] # =&gt; bar elsif result.failure? # Some fallback. else # result.error? # Some other fallback. end  info A self-explanatory exception is raised when a missing data key is accessed. result = Service.result if result.success? result.data[:missing_key] # =&gt; Raises exception since data has NO value by `:missing_key` key... end That is also by design. The intention is to highligh typos during development, so that they are fixed earlier. ","version":"Next","tagName":"h2"},{"title":"How to create failure or error results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-create-failure-or-error-results","content":"failures and errors have similar public interface. That is why it makes sence to explain them together. So in order to create a failure or error - invoke the corresponding instance method, pass a message to it, and return its value from result. This is an example for failure. class Service include ConvenientService::Standard::Config def result failure(message: &quot;Some business rule is NOT satisfied&quot;) end end  This is how to create error. class Service include ConvenientService::Standard::Config def result error(message: &quot;Something forbided service goal to be resolved&quot;) end end  The message keyword can be omitted. def result failure(&quot;Some business rule is NOT satisfied&quot;) end  def result error(&quot;Something forbided service goal to be resolved&quot;) end  ","version":"Next","tagName":"h2"},{"title":"How to access failure or error result message?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-access-failure-or-error-result-message","content":"Utilize the result message object. result = Service.result if result.success? # ... elsif result.failure? result.message # =&gt; &quot;Some business rule is NOT satisfied&quot; else # result.error? result.message # =&gt; &quot;Something forbided service goal to be resolved&quot; end  info A self-explanatory exception is raised when message is accessed before the status is checked. result = Service.result result.message # =&gt; Raises exception since result status is NOT checked... The motivation is to discourage checks like if result.message.empty?. ","version":"Next","tagName":"h2"},{"title":"How to check result status?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-check-result-status","content":"Check the comprehensive list of commands below. To make them more demonstrative, let's introduce the following minimalistic services. class SuccessService include ConvenientService::Standard::Config def result success end end  SuccessService always returns success. class FailureService include ConvenientService::Standard::Config def result failure end end  FailureService always returns failure. class ErrorServices include ConvenientService::Standard::Config def result error end end  ErrorServices always returns error. Having that information status checkers work as follows: SuccessService.result.success? # =&gt; true FailureService.result.success? # =&gt; false ErrorService.result.success? # =&gt; false  SuccessService.result.failure? # =&gt; false FailureService.result.failure? # =&gt; true ErrorService.result.failure? # =&gt; false  SuccessService.result.error? # =&gt; false FailureService.result.error? # =&gt; false ErrorService.result.error? # =&gt; true  Also not counterparts are available. SuccessService.result.not_success? # =&gt; false FailureService.result.not_success? # =&gt; true ErrorService.result.not_success? # =&gt; true  SuccessService.result.not_failure? # =&gt; true FailureService.result.not_failure? # =&gt; false ErrorService.result.not_failure? # =&gt; true  SuccessService.result.not_error? # =&gt; true FailureService.result.not_error? # =&gt; true ErrorService.result.not_error? # =&gt; false  For people who like to save every keyboard stroke - a shorter equivalent is available for success. It is just ok. SuccessService.result.ok? # =&gt; true FailureService.result.ok? # =&gt; false ErrorService.result.ok? # =&gt; false  And the opposite for it. SuccessService.result.not_ok? # =&gt; false FailureService.result.not_ok? # =&gt; true ErrorService.result.not_ok? # =&gt; true  ","version":"Next","tagName":"h2"},{"title":"How to check for specific failure or error?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-check-for-specific-failure-or-error","content":"No. You don't need to match regular expressions by yourself. Something like result.message.to_s.match?(/Business Rule/) is NOT the way to go. Please, consider the code keyword. Here is a quick demonstration. class Service include ConvenientService::Standard::Config attr_reader :number def initialize(number:) @number = number end def result return error(message: &quot;Message for `foo`&quot;, code: :foo) if number == 1 return error(message: &quot;Message for `bar`&quot;, code: :bar) if number == 2 return failure(message: &quot;Message for `baz`&quot;, code: :baz) if number == 3 return failure(message: &quot;Message for `qux`&quot;, code: :qux) if number == 4 success end end  Depending on the input number, the service above returns various failures and errors. A shorter form is also available. def result return error(&quot;Message for `foo`&quot;, :foo) if number == 1 return error(&quot;Message for `bar`&quot;, :bar) if number == 2 return failure(&quot;Message for `baz`&quot;, :baz) if number == 3 return failure(&quot;Message for `qux`&quot;, :qux) if number == 4 success end  This is how you can differentiate those failures and errors on the calling code. result = Service.result(number: 4) if result.success? # ... elsif result.failure? if result.code.to_sym == :baz result.message # =&gt; &quot;Message for `baz`&quot; elsif result.code.to_sym == :qux result.message # =&gt; &quot;Message for `qux`&quot; else # ... end else # result.error? if result.code.to_sym == :foo result.message # =&gt; &quot;Message for `foo`&quot; elsif result.code.to_sym == :bar result.message # =&gt; &quot;Message for `bar`&quot; else # ... end end  Sure, this snippet is not the prettiest, but currently, there is NO alternative. Optimization like the following (API is still subject to change) is planned for the subsequent Convenient Service releases. result = Service.result(number: 4) result.respond_to do |status| status.success { } status.failure(code: :baz) { } status.failure(code: :qux) { } status.error(code: :foo) { } status.error(code: :bar) { } status.unexpected { } end  ","version":"Next","tagName":"h2"},{"title":"When to use success results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#when-to-use-success-results","content":"When you have a 100% guarantee that the service's desired outcome is achieved. tip In other words, all business rules are satisfied and the service's actual operation is completed. ","version":"Next","tagName":"h2"},{"title":"When to use failure results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#when-to-use-failure-results","content":"When you have a 100% guarantee that the service's desired outcome is NOT achieved. tip In other words, some business rule is NOT satisfied. ","version":"Next","tagName":"h2"},{"title":"When to use error results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#when-to-use-error-results","content":"When you don't have any guarantee that the service's desired outcome was even tried to be completely achieved. tip In other words, some business rule check is NOT completed or the service's actual operation is NOT completed. ","version":"Next","tagName":"h2"},{"title":"How to decide between success, failure, and error results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-decide-between-success-failure-and-error-results","content":"Let's consider the following service. class AddRole include ConvenientService::Standard::Config attr_reader :user, :role_name def initialize(user:, role_name:) @user = user @role_name = role_name end def result return error(&quot;User is blank&quot;) if user.blank? return error(&quot;Role name is blank&quot;) if role_name.blank? return failure(&quot;User(#{user.id}) already has `#{role_name}` role&quot;) if user.has_role?(role_name) # Business rule. return failure(&quot;User(#{user.id}) reputation is too low for `#{role_name}` role&quot;) if user.reputation.low? &amp;&amp; role_name == :admin # Business rule. user.add_role(role_name) # Service actual operation. success rescue DB::ConnectionTimeout =&gt; exception error(&quot;DB connection is lost due to `#{exception.message}`&quot;) end end  As its name states, the AddRole service is responsible for the addition of a role to a particular user. Thus successfully added role is its service goal. AddRole can be easily invoked like so: result = AddRole.result(user: User.find(1), role_name: :admin)  When the success result is returned, you are confident that the role is added. result.success? # =&gt; true  When the failure result is returned, you are confident that the role is NOT added. result.failure? # =&gt; true  As a significant bonus, you immediately receive the exact logical reason that clearly explains what forbade the role addition. For this concrete service, it is the fact that the user already has the passed role. result.message # =&gt; &quot;User(1) already has `admin` role&quot;  Or the fact that the user's reputation is too low for the admin role. result.message # =&gt; &quot;User(1) reputation is too low for `admin` role&quot;  So you can quickly report that reason to the interested people without additional debugging sessions. When the error result is returned, you obtain NO new information about the service goal. result.error? # =&gt; true  As you had NO idea whether it was possible or impossible to add the role before running the service. The same question remains open and unresolved after executing the service. Strictly speaking, the error result notifies that the only way to get the reliable service goal outcome is to rerun the service with changed inputs or to retry later. AddRole has multiple errors. The first two of them are unsatisfied input validations. result.message # =&gt; &quot;User is blank&quot;  result.message # =&gt; &quot;Role name is blank&quot;  Usually, they indicate that a developer (service user) who was invoking the service made a mistake by providing incorrect inputs. That is why they should be changed before rerunning the service. The last one is a database exception. result.message # =&gt; &quot;DB connection is lost due to `Default timeout exceeded`&quot;  Such an error may show that the runtime infrastructure is not stable. That is why retrying again later may be an option. Similarly to failures, errors also have messages that clearly explain the reasons for what went wrong. But, this time they are just hints about where to proceed with debugging, not the reliable facts about service goal resolution. ","version":"Next","tagName":"h2"},{"title":"`AmazingPrintInspect` does not colorize","type":0,"sectionRef":"#","url":"/troubleshooting/amazing_print_inspect_does_not_colorize","content":"`AmazingPrintInspect` does not colorize Consider a service that includes the AmazingPrintInspect config. Here is the minimal example. ConvenientService::Dependencies.require_amazing_print_inspect class Service include ::ConvenientService::Standard::Config include ::ConvenientService::AmazingPrintInspect::Config def result success(foo: :bar, baz: :qux) end end When it is called from the console like IRB. Service.result The result should be pretty-printed by amazing_print. But it actually outputs some &quot;weird escape characters&quot; ^[[0;37m, ^[[0m or ^[[0;33m like in the screenshot below. One way to fix that problem is to activate Amazing Print IRB integration. AmazingPrint.irb! Thus the output is colorized as expected. In case you are using Pry, Amazing Print has integration for it as well. AmazingPrint.pry! ","keywords":"","version":"Next"},{"title":"TL;DR","type":0,"sectionRef":"#","url":"/tldr","content":"","keywords":"","version":"Next"},{"title":"More examples‚Äã","type":1,"pageTitle":"TL;DR","url":"/tldr#more-examples","content":"Source Code\tRSpec Specslib/convenient_service/examples\tspec/lib/convenient_service ","version":"Next","tagName":"h2"},{"title":"I18n.translate wrong number of arguments","type":0,"sectionRef":"#","url":"/troubleshooting/i18n_translate_wrong_number_of_arguments","content":"I18n.translate wrong number of arguments Failure/Error: @errors ||= entity.tap(&amp;:valid?).errors.messages.transform_values(&amp;:first) ArgumentError: wrong number of arguments (given 2, expected 0..1) # /usr/local/bundle/gems/i18n-1.12.0/lib/i18n.rb:210:in `translate' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/naming.rb:190:in `human' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/errors.rb:424:in `generate_message' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/errors.rb:454:in `normalize_message' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/errors.rb:298:in `add' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validations/presence.rb:7:in `validate_each' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validator.rb:152:in `block in validate' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validator.rb:149:in `each' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validator.rb:149:in `validate' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:426:in `block in make_lambda' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:198:in `block (2 levels) in halting' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:606:in `block (2 levels) in default_termi nator' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:605:in `catch' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:605:in `block in default_terminator' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:199:in `block in halting' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:513:in `block in invoke_before' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:513:in `each' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:513:in `invoke_before' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:131:in `run_callbacks' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:816:in `_run_validate_callbacks' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validations.rb:409:in `run_validations!' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validations.rb:339:in `valid?' # ./lib/convenient_service/service/plugins/has_result_params_validations/using_active_model_validations/middleware.rb:28 :in `errors' # ./lib/convenient_service/service/plugins/has_result_params_validations/using_active_model_validations/middleware.rb:10 :in `next' This exception may happen when HasJSendResultParamsValidations::UsingActiveModelValidations plugin is used in an environemnt with Ruby 3+ and Rails 5. It is caused by separation of positional and keyword arguments in Ruby 3.0. Check correct Delegation with Ruby 2.6, 2.7 and 3.0 and I18n.translate for more details. Currenty, there is no a simple workaround for it. Actually, you may choose any of the following two options: Upgrade to Rails 6 or higher. Or remove HasJSendResultParamsValidations::UsingActiveModelValidations plugin from config (do not forget to remove validates calls as well). concerns do delete Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Concern end middlewares :result do delete Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware end ","keywords":"","version":"Next"}],"options":{"languages":["en"],"id":"default"}}