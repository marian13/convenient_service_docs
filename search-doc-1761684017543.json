{"searchDocs":[{"title":"Errors","type":0,"sectionRef":"#","url":"/basics/errors","content":"","keywords":"","version":"Next"},{"title":"What is an error?‚Äã","type":1,"pageTitle":"Errors","url":"/basics/errors#what-is-an-error","content":" Error is a result type caused either by the wrong input data (validation error) or by the exceptional behaviour (exception error).  In some cases, it may be a validation rule violation, unsatisfied assertion, or unmet precondition based on the service arguments.  It is a responsibility of a developer/service user to provide correct inputs.  Otherwise, there is no sense in even starting any service processing.  Also errors are often semantically close to the exceptions.  In other words, service errors are frequently located at the same places where exceptions are raised/rescued in the reqular methods.  info Exceptional behaviour like HTTP connection issues, database inconsistencies, timeouts, etc are also errors.  Check out the following example:  class EnsureFeatureActive # ... def initialize(name:) @name = name end def result return error(&quot;Feature name can NOT be `nil`&quot;) if name.nil? return error(&quot;Unknown feature `#{name}`&quot;) unless Feature.exist?(name: name) # ... Tricky and non trivial logic to ensure that feature is active... rescue Feature::Exceptions::ConnectionTimeout =&gt; exception return error(&quot;Feature `#{name}` connection timeout due to `#{exception.message}`&quot;) end end   And this is how it can be triggerred:  result = EnsureFeatureActive.result(name: &quot;Fancy feature&quot;) if result.error? # `result.message` is a string-like object with error reason. result.message end   There is no point to involve all the heavy machinery when the feature name is nil.  Why do we need to waste any expensive resources if the feature name is unknown?  Can we guarantee whether the feature is actually active when a connection timeout happens?  So, the one of the purposes of the error result is to say that the callers need to make adjustments in their code/config/dependency, not the service authors. ","version":"Next","tagName":"h2"},{"title":"delegate_to","type":0,"sectionRef":"#","url":"/api/tests/rspec/matchers/delegate_to","content":"","keywords":"","version":"Next"},{"title":"What is delegate_to?‚Äã","type":1,"pageTitle":"delegate_to","url":"/api/tests/rspec/matchers/delegate_to#what-is-delegate_to","content":" delegate_to is a custom RSpec matcher that provides a neat way to check whether a delegation was performed as expected.  For example, consider the following code snippet:  class FirstService attr_reader :params def initialize(params:) @params = params end def result # ... SecondService.result(params: params) end end   As you can see, the first service asks the second one to do some &quot;interesting&quot; stuff and returns its value.  This behavior can be easily tested in RSpec like so:  RSpec.describe FirstService do describe &quot;.result&quot; do let(:params) { {foo: :bar} } it &quot;delegates to `SecondService.result`&quot; do # Creates a spy. allow(SecondService).to receive(:result).and_call_orginal FirstService.result(params: params) # Confirms delegation. expect(SecondService).to have_received(:result) end it &quot;returns `SecondService.result`&quot; do # Confirms return value equality. expect(FirstService.result(params: params)).to eq(SecondService.result(params: params)) end end end   Since it is so common to write specs as above when working with services, the delegate_to matcher is provided to hide the repeatable noise.  RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:params) { {foo: :bar} } it &quot;delegates to `SecondService.result`&quot; do expect { FirstService.result(params: params) }.to delegate_to(SecondService, :result) end it &quot;returns `SecondService.result`&quot; do # Confirms return value equality. expect(FirstService.result(params: params)).to eq(SecondService.result(params: params)) end end end   delegate_to has a self-explanatory and_return_its_value chaining, so we can refactor out the second spec as well.  RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:kwargs) { {foo: :bar} } it &quot;delegates to and returns `SecondService.result`&quot; do expect { FirstService.result(params: params) } .to delegate_to(SecondService, :result) .and_return_its_value end end end   danger and_return_its_value uses RSpec eq to compare values, therefore ensure your return values define meaningful == operator.  Also delegate_to supports with_arguments chaining to make sure that delegation happened with certain arguments.  RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:params) { {foo: :bar} } it &quot;delegates to and returns `SecondService.result`&quot; do expect { FirstService.result(params: params) } .to delegate_to(SecondService, :result) .with_arguments(params: params) .and_return_its_value end end end   This spec can be simplified even further.  RSpec.describe FirstService do describe &quot;.result&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:params) { {foo: :bar} } specify do expect { FirstService.result(params: params) } .to delegate_to(SecondService, :result) .with_arguments(params: params) .and_return_its_value end end end   When specify is utilized, RSpec infers spec description from delegate_to arguments and chainings.  ","version":"Next","tagName":"h2"},{"title":"delegate_to is context-independent‚Äã","type":1,"pageTitle":"delegate_to","url":"/api/tests/rspec/matchers/delegate_to#delegate_to-is-context-independent","content":" In other words, delegate_to is applicable for any classes, not only for services, e.g:  class Notifier # ... def broadcast_event(*args, **kwargs, &amp;block) Event.create(*args, **kwargs, &amp;block) end end   With specs:  RSpec.describe Notifier do describe &quot;#broadcast_event&quot; do include ConvenientService::RSpec::Matchers::DelegateTo let(:notifier) { create(:notifier) } let(:args) { :foo } let(:kwargs) { {foo: :bar} } let(:block) { proc { :foo } } specify do expect { notifier.broadcast_event(*args, **kwargs, &amp;block) } .to delegate_to(Event, :create) .with_arguments(*args, **kwargs, &amp;block) .and_return_its_value end end end   Please, note that delegate_to is able to verify block argument (&amp;block) that is not possible with raw allow to receive.  danger Blocks (procs, lambdas) are compared by RSpec eq under the hood. Please, remember their semantics in order to not be overly surprised. The two Proc instances may look the same from the syntax point of view. But they are different from the Proc semantics point of view. first = proc { :foo } second = proc { :foo } first == second # =&gt; false first == first # =&gt; true second == second # =&gt; true  ","version":"Next","tagName":"h2"},{"title":"Assigns attributes in constructor using Dry::Initializer","type":0,"sectionRef":"#","url":"/api/plugins/common/assigns_attributes_in_constructor/using_dry_initializer","content":"Assigns attributes in constructor using Dry::Initializer It is so common to write constructors and attributes in Ruby like so: class FormatHeader include ApplicationService::Config attr_reader :parsed_content, :skip_frozen_string_literal def initialize(parsed_content:, skip_frozen_string_literal: false) @parsed_content = parsed_content @skip_frozen_string_literal = skip_frozen_string_literal end # ... end If Ruby is your day-to-day language, such code probably seems too routine for you. class RunShell include ApplicationService::Config attr_reader :command, :debug def initialize(command:, debug: false) @command = command @debug = debug end # ... end Also, it is so annoying to make accidental typos, when you are already tired, but you still have some stuff to complete. For example, the word command is typed 4 times in the example above, so there are 4 opportunities to make an automatic mistake. Please, don't even tell that your IDE handles that for you. When the whole team is feeling the same annoyance. All of the members really believe in the benefits of the removal of such repeatable code. You may consider to utilizing the Dry::Initializer integration that the AssignsAttributesInConstructor::UsingDryInitalizer plugin provides. module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config # ... concerns do use ConvenientService::Plugins::Common::AssignsAttributesInConstructor::UsingDryInitalizer::Concern end end end end end Thus, FormatHeader and RunShell can be reduced in the following way: class FormatHeader include ApplicationService::Config option :parsed_content option :skip_frozen_string_literal, default: -&gt; { false } # ... end class RunShell include ApplicationService::Config option :command option :debug, default: -&gt; { false } # ... end caution Dry::Initializer does NOT call super in its initialize implementation. If it causes problems for you, try to place AssignsAttributesInConstructor::UsingDryInitalizer closer to the top in the concerns stack. See insert_before. danger Introduce new libraries to the projects only when you have strong arguments and complete ideas about why to do so. In fast-paced enterprise projects, with a poor onboarding process, simplicity is almost always a better choice. The simplicity in a sense, that the tech stack should be familiar to the people, who maintain the project for years. Since you probably won't have a chance to talk with the &quot;one-task&quot; developers while they remember the initial reasoning behind their code. Moreover, that code is frequently left without any diagrams, documentation, or even tests üòê.","keywords":"","version":"Next"},{"title":"Failures","type":0,"sectionRef":"#","url":"/basics/failures","content":"","keywords":"","version":"Next"},{"title":"What is a failure?‚Äã","type":1,"pageTitle":"Failures","url":"/basics/failures#what-is-a-failure","content":" Errors prevent the achievement of the service goal due to unsatisfied validations or exceptions.  At the same time, failures prevent the achievement of the service goal due to business reasons.  That is why is so vital to use meaningful names for services.  For instance, when the aim is to order a bus ticket, call it - OrderBusTicket.  So when the service is invoked, but the ticket is not ordered for some logical business reason, it should be treated as a failure.  Why?  Business reason is not an error, since the input is valid, the environment is stable, but the service goal is still not achieved.  Please, read the following code snippet carefully to get the idea.  class OrderBusTicket # ... def result return error(&quot;Bus is nil&quot;) if bus.nil? return error(&quot;Bus `#{bus.number}` is NOT valid&quot;) unless bus.has_valid_number? return failure(&quot;Bus has no available seats&quot;) if bus.full? return failure(&quot;Bus trip is postponed&quot;) if Trip.for_bus(bus).postponed? ticket = BusTerminal.issue_ticket(bus) success(ticket: ticket) rescue =&gt; exception error(&quot;Ticket order for bus `#{name}` is not completed due to `#{exception.message}`&quot;) end end   And this is how it can be triggerred:  result = OrderBusTicket.result(bus: bus) if result.failure? # `result.message` is a string-like object with failure reason. result.message end   When the bus is nil we can not even try to order a ticket.  When the bus does not have a valid number, we can not even try to order a ticket.  When an exception is raised, we can not complete the ticket order due to the technical issue.  Hence errors are returned for those cases.  But once all the validation preconditions are met and exceptions are avoided, the ticket can still not be ordered for business reasons.  This is the place when failures come into play.  The lack of available seats or the trip delay are examples of business reasons.  Just accept the fact that at the given moment in time, there is no possibility to order a ticket for that specific bus.  But the crucial point is that a failure is a strong and reliable explainer of why the desired effect hasn't happened.  That is the key difference between errors and failures.  Errors give you no service goal resolution at all.  While failures provide a stable negative service goal resolution that is a strong foundation for the subsequent decision-making. ","version":"Next","tagName":"h2"},{"title":"Results","type":0,"sectionRef":"#","url":"/basics/results","content":"","keywords":"","version":"Next"},{"title":"Motivation behind results‚Äã","type":1,"pageTitle":"Results","url":"/basics/results#motivation-behind-results","content":" Usually, the service exposes a sole public method, let it be call for this case.  class Service def call # ... end end   Since Ruby is a dynamic language, call may return any type of value.  Sometimes it is advantageous, for things like Duck Typing, Abstract Factories, Null Objects, etc.  But occasionally it may also become problematic.  For example, you can not implement a unified way to check whether the value was calculated correctly (as it was intended by its author).  value = service.call if value.any? # When an array. if value.cover?(0...100) # Range. if value.match(/^[0-9]*$/) # Regexp. if value.dig(:user, :address) # Hash. if value.nozero? # Integer....   note Someone may consider Object#blank? and its opposite Object#present? from ActiveSupport as an attempt, but they detect truthiness in the Rails sense.  Also it is common to forget to verify if the returned value is actually what you need:  hash = service.call hash.merge(other_hash) # Expected a merge, but it raises since hash is nil...   Convenient Service suggests utilizing Result objects as a way to overcome the problems listed above.  Practically speaking, to return results from all services.  To express this idea, let's create a different public method instead of call and name it result.  class Service def result # ... end end   Now, we have the following invocation:  result = service.result if result.success? result.data else result.message end   ","version":"Next","tagName":"h2"},{"title":"So what is a Result? Its benefits?‚Äã","type":1,"pageTitle":"Results","url":"/basics/results#so-what-is-a-result-its-benefits","content":" Result is a data structure that satisfies the following properties:  Firstly, it has a consolidated way to detect its state (success?, failure?, error?, and their counterparts with not like not_success?). Secondly, when the result is successful, you can be 100% sure that its data is correct, no additional verifications are needed (the notion of correctness is defined by the service author). Moveover, results induce you to always check them, before accessing their attributes, otherwise an exception is raised. Also, when something goes wrong, the result contains a description of the reason (result.message), which simplifies finding the source of the problem. ","version":"Next","tagName":"h2"},{"title":"Service goals","type":0,"sectionRef":"#","url":"/basics/service_goals","content":"","keywords":"","version":"Next"},{"title":"What is the service goal?‚Äã","type":1,"pageTitle":"Service goals","url":"/basics/service_goals#what-is-the-service-goal","content":" The service goal is the desired effect of an action/operation.  What does it mean in practise?  Imagine the service below:  class FindUser # ... def initialize(user_id:) @user_id = user_id end def result # ... end end   Its desired effect is the found user record.  Simple and straightforward.  So, if you are a developer who wants to utilize this service, the only reason why you would decide to do it is to get the user record.  Thus the following conclusion can be made.  We always invoke a service to achieve some concrete goal defined by the service author.  In other words, we call a service to resolve some specific problem stated by the service name.  ","version":"Next","tagName":"h2"},{"title":"Service problem resolutions‚Äã","type":1,"pageTitle":"Service goals","url":"/basics/service_goals#service-problem-resolutions","content":" Let's come back to the FindUser service and add some basic implementation for it.  class FindUser include ::ConvenientService::Standard::Config def initialize(user_id:) @user_id = user_id end def result return error(&quot;User id in NOT an integer&quot;) unless user_id.instance_of?(::Integer) user = ::User.find_by(id: user_id) return failure(&quot;NO user with id `#{user_id}`&quot;) unless user success(user: user) end end   result = FindUser.result(user_id: user_id) # =&gt; `success`, `failure` or `error`.   As you can see, it may return one of the three possible result types that represent different resolutions.  Each of them has a specific meaning.  The success result communicates to its caller the positive service problem resolution, since the found user record is returned as expected.  The failure result provides the negative resolution, because the user record does not exist in database.  The error result gives no resolution at all, since the service no even tried to complete the user lookup. ","version":"Next","tagName":"h2"},{"title":"Result-ducks","type":0,"sectionRef":"#","url":"/basics/results_are_ducks","content":"","keywords":"","version":"Next"},{"title":"Why Results are Ducks?‚Äã","type":1,"pageTitle":"Result-ducks","url":"/basics/results_are_ducks#why-results-are-ducks","content":" If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. ‚Äî Duck test  Results are Ducks in the sense that no matter whether you have success, failure, or error - all of them have the same interface with reasonable defaults.  Here is a comparison table:  \tdata\tmessage\tcodesuccess\t*data or {}\t*message or &quot;&quot;\t*code or :default_success failure\t*data or {}\t*message or &quot;&quot;\t*code or :default_failure error\t*data or {}\t*message or &quot;&quot;\t*code or :default_error  Where * means user-provided.  info As a user, you have the ability to pass custom values for everything, e.g: extraordinary code for success. We (as library designers) left such a possibility to avoid the Incomplete Library Class code smell. But to be honest, we don't see any valuable use cases for now.  note Actually, Convenient Service utilizes look-alike wrappers for data, message, and code. {}, &quot;&quot; and :symbol notations are used to not overcomplicate the table with too low-level details.  As a consequence, you can be confident that any (adequate) status check (like success?) is enough to proceed:  def show # ... # Status is logically checked somewhere. result.success? # n lines of code later... # Won't crash since all `success`, `failure` and `error` respond to `data` and have reasonable defaults. result.data # Won't crash since all `success`, `failure` and `error` respond to `message` and have reasonable defaults. result.message # Won't crash since all `success`, `failure` and `error` respond to `code` and have reasonable defaults. result.code # ... end   danger When you forget to check the result status before accessing any of its attributes - an exception is raised. That is intentional in order to motivate a user to think not only about a happy path but about negative cases as well. For example: delivery_result = OrderFoodDelivery.result # Oh, raises `... Result::Errors::StatusIsNotChecked` since (as its name states) status is not checked. # How can you eat something if you don't even know whether it is already delivered or not üôÇ? client.eat(delivery_result.data[:food])  ","version":"Next","tagName":"h2"},{"title":"Services","type":0,"sectionRef":"#","url":"/basics/services","content":"","keywords":"","version":"Next"},{"title":"What is a service?‚Äã","type":1,"pageTitle":"Services","url":"/basics/services#what-is-a-service","content":" Service is an object that does only one operation, nothing more, nothing less.  Service may usually be implemented as follows:  class Service def call # ... end end   It has a single public method, often named call or run, process, perform, etc, that is used to invoke its logic.  service = Service.new service.call   ","version":"Next","tagName":"h2"},{"title":"Why do we need services?‚Äã","type":1,"pageTitle":"Services","url":"/basics/services#why-do-we-need-services","content":" Hang on a minute! According to the definition above, a service is almost the same as a regular function/method. Why do we need a new concept? ‚Äî A curious developer  Usual Ruby methods may solve similar problems as services most of the time.  Moreover, when it is possible to achieve the task only by using plain methods, it is almost always preferable.  As a result, services should NOT be considered competitors or replacements for methods, they are additions to them.  It is like a new option in the development toolbox.  You have primitives, methods, classes, etc, and now there is an ability to use a service.  For example, removing duplicates from an array can be implemented in multiple ways, you decide whether to utilize an array, hash or a set, depending on your environment limitations.  The same case is with services. Just use them when you feel they bring advantages compared to other approaches. ","version":"Next","tagName":"h2"},{"title":"Steps","type":0,"sectionRef":"#","url":"/basics/steps","content":"","keywords":"","version":"Next"},{"title":"What is a step?‚Äã","type":1,"pageTitle":"Steps","url":"/basics/steps#what-is-a-step","content":" After a while service logic may grow into more complicated and less straightforward.  Therefore, a future developer spends more time trying to figure out what is going on.  That is probably an inevitable process since:  Complex problem can not have non-complex solution in a global sense. But a particular step (piece) from that solution can be simple. ‚Äî Own savvy  That is what steps are all about.  As soon as you start to see that service logic becomes too difficult to digest for a minute or two.  It is a clear sign that you need to split it into multiple sub-services and combine them back into a step sequence.  This is how it looks in practice:  class PurchaseBook # ... step AuthenticateUser, in: :user_id, out: :user step SearchBooks, in: [:title, :author_id], out: [:book, :count] step VerifyPaymentMethod, in: :user step CalculatePrice in: :book, out: {price: :price_without_discount} step ApplyDiscounts, in: [:book, {price: :price_without_discount}], out: {price: :price_with_discount} # ... end   For the sake of completeness, here is the same service, but without steps:  class PurchaseBook # ... def result authenticate_user_result = AuthenticateUser.result(user_id: user_id) return authenticate_user_result unless authenticate_user_result.success? user = authenticate_user_result.data[:user] search_book_result = SearchBook.result(title: title, author_id: author_id) return search_book_result if search_book_result.not_success? # NOTE: One service may return multiple values if needed. book = search_book_result.data[:book] count = search_book_result.data[:count] verify_payment_method = VerifyPaymentMethod.result(user: user) return verify_payment_method unless verify_payment_method.success? calculate_price_result = CalculatePrice.result(book: book) return calculate_price_result if calculate_price_result.not_success? # NOTE: Aliasing `data[:price]` to `price_without_discount`. price_without_discount = calculate_price_result.data[:price] apply_discounts_result = ApplyDiscounts.result(book: book, price: :price_without_discount) return apply_discounts_result unless apply_discounts_result.success? # NOTE: Aliasing `data[:price]` to `price_with_discount`. price_with_discount = apply_discounts_result.data[:price] # ... end end   Looks pretty impressive, isn't it?  So steps are just regular services, but their declarative interface hides the boilerplate code.  They are executed in the same order as they are defined.  If any intermediate step service result is not successful, the step sequence is stopped, and that unsuccessful result is returned (similar to Railway Oriented Programming). ","version":"Next","tagName":"h2"},{"title":"Success","type":0,"sectionRef":"#","url":"/basics/success","content":"","keywords":"","version":"Next"},{"title":"What is a success?‚Äã","type":1,"pageTitle":"Success","url":"/basics/success#what-is-a-success","content":" Success is a kind of result when the service objective is fully satisfied.  All errors and failures preconditions are met.  Every validation check is passed.  There is no obstacle that prohibits achieving the service goal.  In general, a service must have one and only one reason to return success.  note No sense to hide the truth, sometimes it is really necessary to return multiple success cases from a single service (For example, fake HTTP responses for external testing systems). As a rule of thumb, if you start to feel that you have such a scenario, always prefer to think about how to create multiple services instead. If not, be ready to strongly argue why your situation is truly exceptional and unavoidable.  ","version":"Next","tagName":"h2"},{"title":"Success data‚Äã","type":1,"pageTitle":"Success","url":"/basics/success#success-data","content":" Success results may have some data (So-called Boolean Services are often without success data).  Data is a hash-like structure with values received by service processing.  Example:  class FetchPopularVideos # ... def result # ... # Actual logic to fetch videos. # ... success( own_channel_videos: own_channel_videos, followers_videos: followers_videos, all_videos: own_channel_videos.concat(followers_videos) ) end end   With invocation:  result = FetchPopularVideos.result if result.success? # No `data` checks here, since `result.success?` guarantees that `result.data[:all_videos]` are 100% valid. markup = result.data[:all_videos].map { |video| generate_markup(video) }.join # ... end  ","version":"Next","tagName":"h2"},{"title":"Invoke proxy middleware behavior via public method","type":0,"sectionRef":"#","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method","content":"","keywords":"","version":"Next"},{"title":"How?‚Äã","type":1,"pageTitle":"Invoke proxy middleware behavior via public method","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method#how","content":" ## # Okish. # module Plugins module CanHaveConnectedSteps class Middleware &lt; MethodChainMiddleware intended_for :result, entity: :service def next(...) return chain.next(...) if entity.steps.none? entity.steps.each_evaluated_step do |step| step.save_outputs_in_organizer! # ... end entity.steps.result end end end end   ## # Better. # module Plugins module CanHaveConnectedSteps class Middleware &lt; MethodChainMiddleware intended_for :result, entity: :service def next(...) return chain.next(...) if entity.steps.none? entity.steps_result(...) end end end end module Plugins module CanHaveConnectedSteps module Concern include Support::Concern instance_methods do def steps_result # ... steps.each_evaluated_step do |step| step.save_outputs_in_organizer! # ... end steps.result end # ... end end end end   ","version":"Next","tagName":"h2"},{"title":"Why?‚Äã","type":1,"pageTitle":"Invoke proxy middleware behavior via public method","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method#why","content":" It allows end-users to create middlewares specifically for proxy middleware behavior. For example: ## # Good. # class Service include ConvenientService::Standard::Config middlewares :steps_result do # ... end # ... end It decreases the amount of type checks. Without the extracted method, the end-user requries to utilize type checks to distinguish return values. ## # Bad. # class Middleware &lt; MethodChainMiddleware intended_for :result, entity: :service def next(...) result = chain.next(...) if result.from_step? # Type check. some_logic_with(result) else # ... end end end ## # Better. # class Middleware &lt; MethodChainMiddleware intended_for :step_result, entity: :service def next(...) result = chain.next(...) some_logic_with(result) end end It decreases the amount of order-dependent middlewares.  It simplifies specs. Methods are easier to tests than middlewares.  ","version":"Next","tagName":"h2"},{"title":"Why not?‚Äã","type":1,"pageTitle":"Invoke proxy middleware behavior via public method","url":"/best_practices/advanced/invoke_proxy_middleware_behavior_via_public_method#why-not","content":" When proxy middleware behavior is truly private. ","version":"Next","tagName":"h2"},{"title":"Avoid error shadowing","type":0,"sectionRef":"#","url":"/best_practices/avoid_error_shadowing","content":"","keywords":"","version":"Next"},{"title":"What is an error shadowing?‚Äã","type":1,"pageTitle":"Avoid error shadowing","url":"/best_practices/avoid_error_shadowing#what-is-an-error-shadowing","content":" Error shadowing is a hiding of the original cause of the problem.  A common use case may be always returning a 404 HTTP error code in production, even when the real code is different.  This way you make it a little bit harder for a possible attacker to find security holes in your web application.  danger A professional web attacker may easily exploit any kind of security vulnerabilities. That is why it is so important to be extremely careful. Please, constantly impove your security skills. Securing Rails Applications and OWASP: Ruby on Rails Cheat Sheet are good places to revisit from time to time.  Also it is popular to rescue low-level exceptions to encapsulate internal details from the end-user.  The following example is taken directly from the Rails codebase:  def download_chunk(key, range) instrument :download_chunk, key: key, range: range do file_for(key).download(range: range).string rescue Google::Cloud::NotFoundError raise ActiveStorage::FileNotFoundError end end   As you can see, the original exception message is dropped and not reused anywhere.  ","version":"Next","tagName":"h2"},{"title":"When does error shadowing happen with services?‚Äã","type":1,"pageTitle":"Avoid error shadowing","url":"/best_practices/avoid_error_shadowing#when-does-error-shadowing-happen-with-services","content":" Using Convenient Service, you may encounter an error shadowing as well.  But as always, any approach may have advantages and disadvantages.  To illustrate that, check the service below:  class MainService # ... def result return error(message: &quot;Something went wrong&quot;) unless sub_service_result.success? # ... success end private def sub_service_result @sub_service_result ||= SubService.result end # ... end   MainService looks innocent, but the problem starts to appear when you execute it.  result = MainService.result result.success? # =&gt; false result.message # =&gt; &quot;Something went wrong&quot;   result.message does NOT help to figure out what is actually wrong.  SubService is failing in reality, but it is NOT reflected in the outside world in any way.  If you don't want to intentionally confuse the service users or hide the internals from them, prefer to forward the original message.  class MainService # ... def result return error(message: &quot;Something went wrong (#{sub_service_result.message})&quot;) unless sub_service_result.success? # ... success end # ... end   It is also OK to immediately return SubService result when you don't need to provide any additional text to its message, since it also avoids error shadowing.  class MainService # ... def result return sub_service_result unless sub_service_result.success? # ... success end # ... end   But the best option is to utilize the step macro.  It works as the previous example under the hood and when used frequently - helps to forget about error shadowing in the context of services completely.  class MainService step SubService # ... def result # This line is removed... # ... success end # ... end   note If you are not safisfied how step automatically prevents error shadowing - consider to create a plugin to extend/modify it. ","version":"Next","tagName":"h2"},{"title":"Cast feature arguments inside entries","type":0,"sectionRef":"#","url":"/best_practices/fdd/cast_feature_arguments_inside_entries","content":"Cast feature arguments inside entries Usually, features have their own entities to represent their domain. Entry is the best place where outside-world objects can be cast into them. For example, consider the User entity for the LoginSession feature. module Features class LoginSession module Entities class User def initialize(email:, password:) @email = email @password = password end def self.cast(object) if object.instance_of?(::User) Entities::User.new(email: object.email_address, password: object.encrypted_password) else # ... end end # ... end end end end This is how an entry may convert a raw user object into feature specific entity. module Features class LoginSession include ConvenientService::Feature::Standard::Config def start(**kwargs) kwargs[:user] = Entities::User.cast(kwargs[:user]) Services::Login.result(**kwargs) end end end ","keywords":"","version":"Next"},{"title":"Steps translation table","type":0,"sectionRef":"#","url":"/basics/step_to_result_translation_table","content":"","keywords":"","version":"Next"},{"title":"No in or out‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#no-in-or-out","content":" Definition:  step AssertNodeAvailable   Translation:  def step_result @step_result ||= AssertNodeAvailable.result end   ","version":"Next","tagName":"h3"},{"title":"One in usual method‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#one-in-usual-method","content":" Definitions (equivalent):  step ValidateUncastedParams, in: :params   step ValidateUncastedParams, in: [ :params ]   Translation:  def step_result @step_result ||= ValidateUncastedParams.result( params: params ) end   ","version":"Next","tagName":"h3"},{"title":"Multiple in usual methods‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#multiple-in-usual-methods","content":" Definition:  step LogRequestParams, in: [ :request, :params ]   Translation:  def step_result @step_result ||= LogRequestParams.result( request: request, params: params ) end   ","version":"Next","tagName":"h3"},{"title":"One in alias method‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#one-in-alias-method","content":" Definitions (equivalent):  step ValidateCastedParams, in: {casted_params: :params}   step ValidateCastedParams, in: [ {casted_params: :params} ]   Translation:  def step_result @step_result ||= ValidateCastedParams.result( casted_params: params ) end   ","version":"Next","tagName":"h3"},{"title":"Multiple in alias method‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#multiple-in-alias-method","content":" Definitions:  step AuditContent, in: [ {content: :content_without_comments}, {verbose: :debug} ]   Translation:  def step_result @step_result ||= AuditContent.result( content: content_without_comments, verbose: debug ) end   ","version":"Next","tagName":"h3"},{"title":"One out usual method‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#one-out-usual-method","content":" Definitions (equivalent):  step ReadFileContent, in: :path, out: :content   step ReadFileContent, in: :path, out: [ :content ]   Translation:  def step_result @step_result ||= ReadFileContent.result( path: path ) end def content step_result.data[:content] end   ","version":"Next","tagName":"h3"},{"title":"Multiple out usual methods‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#multiple-out-usual-methods","content":" Definition:  step CastParams, in: :params, out: [ :original_params, :casted_params ]   Translation:  def step_result @step_result ||= CastParams.result( params: params ) end def original_params step_result.data[:original_params] end def casted_params step_result.data[:casted_params] end   ","version":"Next","tagName":"h3"},{"title":"One out alias method‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#one-out-alias-method","content":" Definitions (equivalent):  step FormatHeader, in: :parsed_content, out: {formatted_content: :formatted_header_content}   step FormatHeader, in: :parsed_content, out: [ {formatted_content: :formatted_header_content} ]   Translation:  def step_result @step_result ||= FormatHeader.result( parsed_content: parsed_content ) end def formatted_header_content step_result.data[:formatted_content] end   ","version":"Next","tagName":"h3"},{"title":"Multiple out alias methods‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#multiple-out-alias-methods","content":" Definition:  step ExtractParamsFromRequest, in: :request, out: [ {header_params: :request_params_from_header}, {body_params: :request_params_from_body} ]   Translation:  def step_result @step_result ||= ExtractParamsFromRequest.result( request: request ) end def request_params_from_header step_result.data[:header_params] end def request_params_from_body step_result.data[:body_params] end   ","version":"Next","tagName":"h3"},{"title":"One in raw value‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#one-in-raw-value","content":" Definitions (equivalent):  step AssertFeatureEnabled, in: {name: raw(:chat_v2)}   step AssertFeatureEnabled, in: [ {name: raw(:chat_v2)} ]   Translation:  def step_result @step_result ||= AssertFeatureEnabled.result( name: :chat_v2 ) end   ","version":"Next","tagName":"h3"},{"title":"Multiple in raw values‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#multiple-in-raw-values","content":" Definitions (equivalent):  step PrintShellCommand, in: [ {text: raw(&quot;ls -a&quot;)} {stream: raw($stdout)} ]   Translation:  def step_result @step_result ||= PrintShellCommand.result( text: &quot;ls -a&quot;, stream: $stdout ) end   info in raw values are useful for passing values, constants, methods, etc from the class scope. step PrintShellCommand, in: [ {text: raw(display_directory_structure_command)} {stream: raw($stdout)} ] def self.display_directory_structure_command &quot;ls -a&quot; end   ","version":"Next","tagName":"h3"},{"title":"One in proc method‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#one-in-proc-method","content":" Definitions (equivalent):  step RemoveDirectoryRecursively, in: {path: -&gt;{ &quot;/tmp&quot; }}   step RemoveDirectoryRecursively, in: [ {path: -&gt;{ &quot;/tmp&quot; }} ]   Translation:  def step_result @step_result ||= RemoveDirectoryRecursively.result( path: &quot;/tmp&quot; ) end   ","version":"Next","tagName":"h3"},{"title":"Multiple in proc methods‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#multiple-in-proc-methods","content":" Definition:  step CreateSoftLink, in: [ {source: -&gt;{ &quot;~/.bash_profile&quot; }}, {destination: -&gt;{ &quot;#{Dir.pwd}/bash_profile_link&quot; }} ]   Translation:  def step_result @step_result ||= CreateSoftLink.result( source: &quot;~/.bash_profile&quot;, destination: &quot;#{Dir.pwd}/bash_profile_link&quot; ) end   info in proc methods are useful for passing values, constants, methods, etc from the instance scope. step CreateSoftLink, in: [ {source: -&gt;{ &quot;~/.bash_profile&quot; }}, {destination: -&gt;{ generate_destination_path }} ] def generate_destination_path &quot;#{Dir.pwd}/bash_profile_link&quot; end   ","version":"Next","tagName":"h3"},{"title":"All-in-one example:‚Äã","type":1,"pageTitle":"Steps translation table","url":"/basics/step_to_result_translation_table#all-in-one-example","content":" Definition:  ENV[&quot;API_ONLY&quot;] = true class UpdatePost include ConvenientService::Standard::Config PERMITTED_PARAMS = [:id, :format, :title, :description, :tags, :sources] attr_reader :http_string # ... step PrepareRequestObject in: [ :http_string, {url_pattern: raw(url_pattern)}, {role: -&gt;{ admin? }}, {permitted_keys: raw(PERMITTED_PARAMS)} {defaults: -&gt;{ resolve_defaults_values }} ], out: [ :params_from_path, :params_from_body, {headers: :request_headers} ] # ... def self.url_pattern /^\\/rules\\/(?&lt;id&gt;\\d+)\\.(?&lt;format&gt;\\w+)$/ end def admin? false end def resolve_defaults_values defaults_values = {format: &quot;html&quot;, tags: [], sources: []} defaults_values[:format] = &quot;json&quot; if ENV[&quot;API_ONLY&quot;] defaults_values end # ... end   Translation:  ENV[&quot;API_ONLY&quot;] = true class UpdatePost include ConvenientService::Standard::Config PERMITTED_PARAMS = [:id, :format, :title, :description, :tags, :sources] attr_reader :http_string # ... def step_result @step_result ||= PrepareRequestObject.result( http_string: http_string, url_pattern: /^\\/rules\\/(?&lt;id&gt;\\d+)\\.(?&lt;format&gt;\\w+)$/, role: admin?, # =&gt; false permitted_keys: [:id, :format, :title, :description, :tags, :sources], defaults: resolve_defaults_values # =&gt; {format: &quot;json&quot;, tags: [], sources: []} ) end def params_from_path step_result.data[:params_from_path] end def params_from_body step_result.data[:params_from_body] end def request_headers step_result.data[:headers] end # ... def self.url_pattern /^\\/rules\\/(?&lt;id&gt;\\d+)\\.(?&lt;format&gt;\\w+)$/ end def admin? false end def resolve_defaults_values defaults_values = {format: &quot;html&quot;, tags: [], sources: []} defaults_values[:format] = &quot;json&quot; if ENV[&quot;API_ONLY&quot;] defaults_values end # ... end   note def step_result is used to express the concept. In reality, such a method is not generated by the Convenient Service under the hood. It utilizes a lower-level toolset that is out of the scope of this guide. ","version":"Next","tagName":"h3"},{"title":"Service has only one `success`","type":0,"sectionRef":"#","url":"/best_practices/service_has_only_one_success","content":"Service has only one `success` Most of the time it is relatively easy to follow this rule. Consider the following service: class BuildDisplayName include ::ConvenientService::Standard::Config attr_reader :person def initialize(person:) @person = person end def result return error(&quot;Person can't be blank&quot;) if person.blank? success(display_name: &quot;#{person.first_name} #{persom.last_name}&quot;) end end It currently has no conditional logic to build the display_name. After a while, our system started to grow and it appears that some people would like to see their pseudo in place of display names. Let's reflect on that change in the code using a naive approach: class BuildDisplayName include ::ConvenientService::Standard::Config attr_reader :person def initialize(person:) @person = person end def result return error(&quot;Person can't be blank&quot;) if person.blank? if person.has_pseudonym? success(display_name: person.pseudonym) else success(display_name: &quot;#{person.first_name} #{persom.last_name}&quot;) end end end Having two success calls inside the result is what we try to avoid. Why? It encourages future devs to write deeply nested conditionals. It interferes with the layering of information. You don't need to know the details of the implementation until it is really necessary. The code above tells you about pseudonyms too early, even if you are not interested in them. If you refactor BuildDisplayName like this: class BuildDisplayName include ::ConvenientService::Standard::Config def initialize(person:) @person = person end def result return error(&quot;Person can't be blank&quot;) if person.blank? success(display_name: display_name) end private def display_name @display_name ||= person.has_pseudonym? ? person.pseudonym : &quot;#{person.first_name} #{persom.last_name}&quot; end end Then the result describes which data it may return and when it is NOT successful, just that. Only when you are curious about how display_name is exactly built, feel free to check private methods. This is how the layering of information works in practice. Nesting is replaced by a flat ternary operator. It is time to have a look at the specs: # spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe BuildDisplayName do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(person: person) } context &quot;when building of display name is NOT successful&quot; do context &quot;when `person` is blank&quot; do let(:person) { nil } it &quot;returns `error`&quot; do expect(result).to be_error.with_message(&quot;Person can't be blank&quot;).of_service(described_class).without_step end end end context &quot;when building of display name is successful&quot; do context &quot;when `person` does NOT have pseudonym&quot; do let(:person) { Person.new(&quot;John&quot;, &quot;Doe&quot;) } it &quot;returns `success` with first name and last name as display name&quot; do expect(result).to be_success.with_data(display_name: &quot;John Doe&quot;).of_service(described_class).without_step end end context &quot;when `person` has pseudonym&quot; do let(:person) { Person.new(&quot;John&quot;, &quot;Doe&quot;, preudonym: &quot;Gorilla&quot;) } it &quot;returns `success` with pseudonym as display name&quot; do expect(result).to be_success.with_data(display_name: &quot;Gorilla&quot;).of_service(described_class).without_step end end end end end end As you can see, specs still have two contexts for successful cases and that is completely OK. Now, we are ready for the conclusion: A fact that a Service has only one success actually means that the service calls success inside result only once. But that success can still have multiple variations of data values, just like display_name in BuildDisplayName service.","keywords":"","version":"Next"},{"title":"Steps evaluation table","type":0,"sectionRef":"#","url":"/basics/steps_evaluation_table","content":"","keywords":"","version":"Next"},{"title":"Service without steps‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-without-steps","content":" Example:  class Service include ConvenientService::Standard::Config def result # Evaluated. success end end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; nil   ","version":"Next","tagName":"h3"},{"title":"Service with a step that has a success result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-a-step-that-has-a-success-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 0   ","version":"Next","tagName":"h3"},{"title":"Service with a step that has a failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-a-step-that-has-a-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :failure&gt;   Service.result.step # =&gt; &lt;Service::Step service: FailureService&gt;   Service.result.step.index # =&gt; 0   ","version":"Next","tagName":"h3"},{"title":"Service with a step that has an error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-a-step-that-has-an-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step ErrorService # Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   ","version":"Next","tagName":"h3"},{"title":"Service with a negated step that has a success result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-a-negated-step-that-has-a-success-result","content":" Example:  class Service include ConvenientService::Standard::Config not_step SuccessService # Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :failure message: &quot;Original `result` is `success`&quot;&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 0   info Negation of a success result is a failure result.  ","version":"Next","tagName":"h3"},{"title":"Service with a negated step that has a failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-a-negated-step-that-has-a-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config not_step FailureService # Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success message: &quot;Original `result` is `failure`&quot;&gt;   Service.result.step # =&gt; &lt;Service::Step service: FailureService&gt;   Service.result.step.index # =&gt; 0   info Negation of a failure result is a success result.  ","version":"Next","tagName":"h3"},{"title":"Service with a negated step that has an error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-a-negated-step-that-has-an-error-result","content":" Example:  class Service include ConvenientService::Standard::Config not_step ErrorService # Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   info The error results are semantically close to the exceptions. That is why they do not have negated results.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, all with a success result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-all-with-a-success-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # 0 - Evaluated. step SuccessService # 1 - Evaluated. step SuccessService # 2 - Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 2   ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, last with failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-last-with-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # 0 - Evaluated. step SuccessService # 1 - Evaluated. step FailureService # 2 - Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :failure&gt;   Service.result.step # =&gt; &lt;Service::Step service: FailureService&gt;   Service.result.step.index # =&gt; 2   ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, last with error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-last-with-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # 0 - Evaluated. step SuccessService # 1 - Evaluated. step ErrorService # 2 - Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 2   ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, intermediate with failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-intermediate-with-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # 0 - Evaluated. step FailureService # 1 - Evaluated. step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :failure&gt;   Service.result.step # =&gt; &lt;Service::Step service: FailureService&gt;   Service.result.step.index # =&gt; 1   info For the consecutive steps, there are no differences between the steps that have failure and error results. Both of them stop the sequence immediately and skip the rest of the steps.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, intermediate with error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-intermediate-with-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # 0 - Evaluated. step ErrorService # 1 - Evaluated. step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 1   info For the consecutive steps, there are no differences between the steps that have failure and error results. Both of them stop the sequence immediately and skip the rest of the steps.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, first with a failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-first-with-a-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. step SuccessService # 1 - Skipped. step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :failure&gt;   Service.result.step # =&gt; &lt;Service::Step service: FailureService&gt;   Service.result.step.index # =&gt; 0   info For the consecutive steps, there are no differences between the steps that have failure and error results. Both of them stop the sequence immediately and skip the rest of the steps.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple consecutive steps, first with an error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-consecutive-steps-first-with-an-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step ErrorService # 0 - Evaluated. step SuccessService # 1 - Skipped. step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   info For the consecutive steps, there are no differences between the steps that have failure and error results. Both of them stop the sequence immediately and skip the rest of the steps.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, all with a success result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-all-with-a-success-result","content":" Example:  class Service include ConvenientService::Standard::Config step SuccessService # 0 - Evaluated. or_step SuccessService # 1 - Skipped. or_step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 0   ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, first with failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-first-with-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. or_step SuccessService # 1 - Evaluated. or_step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 1   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, first with an error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-first-with-an-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step ErrorService # 0 - Evaluated. or_step SuccessService # 1 - Skipped. or_step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, first and intermediate with failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-first-and-intermediate-with-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. or_step FailureService # 1 - Evaluated. or_step SuccessService # 2 - Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 2   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, first and intermediate with error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-first-and-intermediate-with-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step ErrorService # 0 - Evaluated. or_step ErrorService # 1 - Skipped. or_step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, first with failure result, intermediate with error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-first-with-failure-result-intermediate-with-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. or_step ErrorService # 1 - Evaluated. or_step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 1   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, first with error result, intermediate with failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-first-with-error-result-intermediate-with-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step ErrorService # 0 - Evaluated. or_step FailureService # 1 - Skipped. or_step SuccessService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, all with a failure result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-all-with-a-failure-result","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. or_step FailureService # 1 - Evaluated. or_step FailureService # 2 - Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :failure&gt;   Service.result.step # =&gt; &lt;Service::Step service: FailureService&gt;   Service.result.step.index # =&gt; 2   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Service with multiple alternative steps, all with an error result‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#service-with-multiple-alternative-steps-all-with-an-error-result","content":" Example:  class Service include ConvenientService::Standard::Config step ErrorService # 0 - Evaluated. or_step ErrorService # 1 - Skipped. or_step ErrorService # 2 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 0   info For the alternative steps, only the steps with error results stop the sequence. The failure steps initiate the next available or_step.  ","version":"Next","tagName":"h3"},{"title":"Complex combination of consecutive steps, negated steps, and alternative steps without evaluated errors.‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#complex-combination-of-consecutive-steps-negated-steps-and-alternative-steps-without-evaluated-errors","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. or_step FailureService # 1 - Evaluated. or_step SuccessService # 2 - Evaluated. step SuccessService # 3 - Evaluated. and_step SuccessService # 4 - Evaluated. and_not_step FailureService # 5 - Evaluated. step FailureService # 6 - Evaluated. or_step SuccessService # 7 - Evaluated. step FailureService # 8 - Evaluated. or_step FailureService # 9 - Evaluated. or_not_step FailureService # 10 - Evaluated. or_step ErrorService # 11 - Skipped. step SuccessService # 12 - Evaluated. not_step SuccessService # 13 - Evaluated. or_step FailureService # 14 - Evaluated. or_not_step FailureService # 15 - Evaluated. or_step FailureService # 16 - Skipped. or_step ErrorService # 17 - Skipped. or_step SuccessService # 18 - Skipped. step SuccessService # 19 - Evaluated. and_step SuccessService # 20 - Evaluated. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :success&gt;   Service.result.step # =&gt; &lt;Service::Step service: SuccessService&gt;   Service.result.step.index # =&gt; 20   info The and_step directive is just an alias to the usual step. The only difference is that it can not be used as the first step.  info The and_not_step directive is just an alias to the usual not_step. The only difference is that it can not be used as the first step.  info The or_not_step directive works like the or_step, but it firstly negates its result.  ","version":"Next","tagName":"h3"},{"title":"Complex combination of consecutive steps, negated steps, and alternative steps with evaluated errors.‚Äã","type":1,"pageTitle":"Steps evaluation table","url":"/basics/steps_evaluation_table#complex-combination-of-consecutive-steps-negated-steps-and-alternative-steps-with-evaluated-errors","content":" Example:  class Service include ConvenientService::Standard::Config step FailureService # 0 - Evaluated. or_step FailureService # 1 - Evaluated. or_step SuccessService # 2 - Evaluated. step SuccessService # 3 - Evaluated. and_step SuccessService # 4 - Evaluated. and_not_step FailureService # 5 - Evaluated. step FailureService # 6 - Evaluated. or_step ErrorService # 7 - Evaluated. step FailureService # 8 - Skipped. or_step FailureService # 9 - Skipped. or_not_step FailureService # 10 - Skipped. or_step ErrorService # 11 - Skipped. step SuccessService # 12 - Skipped. not_step SuccessService # 13 - Skipped. or_step FailureService # 14 - Skipped. or_not_step FailureService # 15 - Skipped. or_step FailureService # 16 - Skipped. or_step ErrorService # 17 - Skipped. or_step SuccessService # 18 - Skipped. step SuccessService # 19 - Skipped. and_step SuccessService # 20 - Skipped. end   Outcome:  Service.result # =&gt; &lt;Service::Result status: :error&gt;   Service.result.step # =&gt; &lt;Service::Step service: ErrorService&gt;   Service.result.step.index # =&gt; 7   info The first evaluated error step is always a sequence stopper. No matter how many other steps are coming after it. No matter which exact types they have. None of them are executed, they are just skipped. In other words, the first evaluated error step is always the whole service's last evaluated step in any circumstances. ","version":"Next","tagName":"h3"},{"title":"Describe feature public interface using entries","type":0,"sectionRef":"#","url":"/best_practices/fdd/describe_feature_public_interface_using_entries","content":"Describe feature public interface using entries This way it becomes easier to get an overview of what a feature can do. Here is an example of the Gemfile feature. module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format entry :lint entry :update entry :regenerate def format # ... end def lint # ... end def update # ... end def regenerate # ... end end end Having a quick eye on the list of entries you immediately realize that there are abilities to format, lint, update, and regenerate Gemfiles. Now, check out the RequestParams feature. module Features class RequestParams include ConvenientService::Feature::Standard::Config entry :extract_from_url_path entry :extract_from_url_query entry :extract_from_body def extract_from_url_path # ... end def extract_from_url_query # ... end def extract_from_body # ... end end end The same story, once you review the entries' names, you get the idea of what the RequestParams feature is about. It gives the opportunity to extract parameters from the request body and URL path/query.","keywords":"","version":"Next"},{"title":"Skip `result` call for boolean services","type":0,"sectionRef":"#","url":"/best_practices/skip_result_call_for_boolean_services","content":"Skip `result` call for boolean services Let's check the following boolean service: class IsConnectionActive include ::ConvenientService::Standard::Config attr_reader :connection def initialize(:connection) @connection = connection end def result return error(&quot;Connection: can't be blank&quot;) if connection.blank? return failure(&quot;Connection `#{connection.id}` is NOT connected&quot;) unless connection.connected? return failure(&quot;Connection `#{connection.id}` has NO task&quot;) if connection.task.blank? return failure(&quot;Connection `#{connection.id}` task is NOT in progress&quot;) unless connection.task.in_progres? success end end A common way to run a usual service is like this: # okish result = IsConnectionActive.result(connection: connection) if result.success? ## # `result.data` is processed somehow by the end-user here... # result.data else end Most of the time you will probably work with result.data inside if result.success? branch. But that is not the case for the boolean services. Their success calls do NOT accept any data, that is why the previous chunk of code can be written in a shorter form: # better if IsConnectionActive.success?(connection: connection) else end ","keywords":"","version":"Next"},{"title":"Services with `or` conditionals","type":0,"sectionRef":"#","url":"/best_practices/services_with_or_conditionals","content":"","keywords":"","version":"Next"},{"title":"Zombie version üßü‚Äã","type":1,"pageTitle":"Services with `or` conditionals","url":"/best_practices/services_with_or_conditionals#zombie-version-","content":" # bad - zombie def result if is_super_admin_result.not_success? if has_ability_result.not_success? if is_subscription_owner_result.not_success? error( &quot;All conditions are not satisfied:&quot; + &quot; and &quot; + is_super_admin_result.message + &quot; and &quot; + has_ability_result.message + &quot; and &quot; + is_subscription_owner_result.message ) else success end else success end else success end end   Although, this code is &quot;perfect&quot; from the performance point of view and it works exactly as needed according to the requirements...  Please, do not commit it.  Just imagine what will happen with an additional fourth or fifth condition.  How can we make it simpler and more readable?  Use or_step.  SourceRSpec class CreateButton include ConvenientService::Standard::Config step CreateWebButtonFactory, in: :app, out: :button or_step CreateAndroidButtonFactory, in: :app, out: {action: :button} or_step CreateIosButtonFactory, in: :app, out: {control: :button} or_step CreateDesktopButtonFactory, in: :app, out: {knob: :button} step :result, in: :app, out: :button attr_reader :app def initialize(:app) @app = app end def result success(button: button) end end  ","version":"Next","tagName":"h3"},{"title":"What is the purpose of Standard::V1::Config?","type":0,"sectionRef":"#","url":"/faq/what_is_purpose_of_v1_config","content":"What is the purpose of Standard::V1::Config? Convenient Service is a young library in the constant process of polishing its public interface. As a result, some breaking changes may still happen. ConvenientService::Standard::V1::Config is a config that was created to delay the migration of services that were created by older Convenient Service versions. Specifically, v0.12.0 and lower.","keywords":"","version":"Next"},{"title":"Is it possible to modify the step collection from a callback?","type":0,"sectionRef":"#","url":"/faq/is_it_possible_to_modify_step_collection_from_callback","content":"Is it possible to modify the step collection from a callback? No‚ùó That is done by design. One of the main Convenient Service goals is the representation of the complex logic as a sequence of simple declarative steps. This idea is completely lost when a callback allows modification of step collection. Right after the first such mutation, you can not rely on what you see. In order to make sure, that the steps declared at the build time are actually the same at runtime, you need to check implementation of every callback. This contradicts the Clean Code definition. class Service include ConvenientService::Standard::Config step :one step :two step :three before :step do byebug steps.clear # =&gt; FrozenError end def one puts &quot;one&quot; success end def two puts &quot;two&quot; success end def three puts &quot;three&quot; success end end Service.result ","keywords":"","version":"Next"},{"title":"JSend meaning of failure and error","type":0,"sectionRef":"#","url":"/deprecations/jsend_meaning_of_failure_and_error","content":"JSend meaning of failure and error Usage of ConvenientService::Standard::V1::Config.","keywords":"","version":"Next"},{"title":"Imports and exports via dependency containers","type":0,"sectionRef":"#","url":"/deprecations/imports_and_exports_via_dependency_containers","content":"Imports and exports via dependency containers The purpose of entry is significantly simpler to explain than import/export.","keywords":"","version":"Next"},{"title":"Why failures and errors? Why not just failure or error?","type":0,"sectionRef":"#","url":"/faq/why_both_failure_and_error","content":"","keywords":"","version":"Next"},{"title":"Failure and errors have different fallbacks‚Äã","type":1,"pageTitle":"Why failures and errors? Why not just failure or error?","url":"/faq/why_both_failure_and_error#failure-and-errors-have-different-fallbacks","content":" Consider the following user story.  As a doctor I would like to see a list of the patient's allergies.  The list is received from the third-party API.  Sometimes a controller for this task may be implemented as follows.  controllers/allergies_controller.rb class AllergiesController &lt; ApplicationController # ... def index # `response` is a `Hash`. response = ApiClient.get( &quot;/allergies&quot;, params: {patient_id: allowed_patient_id} ) @allergies = response.dig(:data, :allergies) end end   And the corresponding view.  views/allergies/index.html.erb &lt;h2&gt;Allergies&lt;/h2&gt; &lt;% if @allergies.present? %&gt; &lt;% @allergies.each do |allergy| %&gt; &lt;p&gt; &lt;div&gt; Name: &lt;%= allergy[:name] %&gt; &lt;/div&gt; &lt;div&gt; Symptoms: &lt;%= allergy[:symptoms].join(&quot;, &quot;) %&gt; &lt;/div&gt; &lt;/p&gt; &lt;% end %&gt; &lt;% else %&gt; &lt;span&gt; Patient has no allergies. &lt;/span&gt; &lt;% end %&gt;   The code may look innocent from the first point of view, but the devil is in the details.  In a case, the API response has an unexpected format, response.dig(:data, :allergies) returns nil.  Then @allergies.present? is evaluated as false in the view.  As a consequence, the &quot;Patient has no allergies&quot; string is displayed in the doctor's browser.  Just try to imagine what may happen when a doctor blindly relies on the page text üò¨?  Unfortunately, a code with similar problems sometimes may be written even by senior developers üò¢.  That is the main reason of why Convenient Service differentiate failures and errors.  Sure, the lib still can NOT 100% guarantee the complete elimination of the issue.  However, it encourages the users to think about fallbacks and split the failures and errors from the beginning.  The curiosity or the confusion that people feel when they find it difficult to decide whether to use a failure or an error works as a provocation for them to open and read this article.  This way they become aware of the issue and share it with others more frequently.  Refactoring using Convenient Service is the following:  controllers/allergies_controller.rb class FetchAllergies include ::ConvenientService::Standard::Config # ... def result return error(&quot;API response does not have `data` key&quot;) unless response.has_key?(:data) return error(&quot;API response data does not have `allergies` key&quot;) unless response[:data].has_key?(:allergies) return failure(&quot;Patient `#{allowed_patient_id}` has no allergies&quot;) if response[:data][:allergies].empty? success(allergies: response[:data][:allergies]) end private def response # `response` is a `Hash`. @response ||= ApiClient.get(&quot;/allergies&quot;, params: {patient_id: allowed_patient_id}) end end   controllers/allergies_controller.rb class AllergiesController &lt; ApplicationController # ... def index @fetch_allergies_result = FetchAllergies.result(allowed_patient_id: allowed_patient_id) end end   views/allergies/index.html.erb &lt;h2&gt;Allergies&lt;/h2&gt; &lt;% if @fetch_allergies_result.success? %&gt; &lt;% @fetch_allergies_result.data[:allergies].each do |allergy| %&gt; &lt;p&gt; &lt;div&gt; Name: &lt;%= allergy[:name] %&gt; &lt;/div&gt; &lt;div&gt; Symptoms: &lt;%= allergy[:symptoms].join(&quot;, &quot;) %&gt; &lt;/div&gt; &lt;/p&gt; &lt;% end %&gt; &lt;% elsif @fetch_allergies_result.failure? %&gt; &lt;span&gt; Patient has no allergies. &lt;/span&gt; &lt;% else # @fetch_allergies_result.error? %&gt; &lt;span&gt; No allergies information available. &lt;/span&gt; &lt;div&gt; Try to refresh the page after a while. &lt;div&gt; &lt;div&gt; If the issue persists please contact the support. &lt;/div&gt; &lt;% end %&gt;   The code is more verbose, but that is the price of reliability.  Using the service goal resolution terminology, this is what we have as a summary.  @fetch_allergies_result.success? means that a patient 100% has allergies (positive service goal resolution). That is why we freely display them. @fetch_allergies_result.failure? means that a patient 100% has NO allergies (negative service goal resolution). So we are confident in the &quot;Patient has no allergies&quot; text. @fetch_allergies_result.error? means that even after service invocation, we still don't know whether a patient has allergies or not (no service goal resolution at all). Due to that, we are telling the truth that &quot;No allergies information available&quot; instead of the false-negative resolution that we had before the separation of failure and errors. ","version":"Next","tagName":"h2"},{"title":"Why errors? Why not exceptions?","type":0,"sectionRef":"#","url":"/faq/why_error_not_exception","content":"","keywords":"","version":"Next"},{"title":"Unhandled exceptions are crashing important flows for minor reasons too often‚Äã","type":1,"pageTitle":"Why errors? Why not exceptions?","url":"/faq/why_error_not_exception#unhandled-exceptions-are-crashing-important-flows-for-minor-reasons-too-often","content":" Imagine we have a travel app.  A typical apartment booking flow may look like the following.  User opens the application. User selects location, dates, guest number, etc. User books an apartment. Host accepts the booking. User pays for the apartment. And so on...  After a while, a new requirement is received to display a small discount proposals widget for the apartments that are located in the not popular regions.  Business truly and argumentably believes that such a feature will increase the conversion rate.  The region popularity detection algorithm is developed by a different team, which swears that it works as expected, but the unit tests are not finished due to other commitments.  With constant pressure from the higher management, an inexperienced developer agrees to add the widget with the subsequent release.  Once the new app version is deployed, apartment selection starts to crash, preventing the users from completing bookings.  The rest is history.  Massive panic.  Endless late-night meetings and discussions.  DevOps engineers who know how to roll back the change are on vacation.  End-users are posting negative feedback on their social media, etc.  Instead of increasing the conversion rate, it is now significantly degraded.  The moral of the story is that the new feature was added in a non fault-tolerant way.  Sure, the discount widget is a useful functionality when properly implemented.  But, it is just a tiny component in the context of the full apartment booking flow.  Thus not having a feature-specific exception handler for it is an unjustified risk.  That is why Convenient Service promotes the idea of using error results instead of regular exceptions.  They help to develop fault-tolerant systems right from the beginning.  Let's tackle a more ground-facing example, that every Ruby developer experiences from time to time.  Data and time formatting ü•≤.  A minimal code snippet to illustrate the issue is the following:  require &quot;date&quot; def format_date(string) Date.strptime(string, &quot;%Y-%m-%d&quot;) end   Once the user's browser localization format changes, the format_date method breaks the whole page by raising invalid date (Date::Error) exceptions.  format_date(&quot;2024/07/16&quot;) # =&gt; # `strptime': invalid date (Date::Error) # # Date.strptime(string, &quot;%Y-%m-%d&quot;) # ^^^^^^^^^^^^^^^^^^   At the same time, a corresponding service encloses unhandled exceptions by converting them into error results.  require &quot;convenient_service&quot; ConvenientService::Dependencies.require_rescues_result_unhandled_exceptions class FormatDate include ConvenientService::Standard::Config attr_reader :string middlewares :result do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end def initialize(string:) @string = string end def result formatted_date = Date.strptime(string, &quot;%Y-%m-%d&quot;) success(formatted_date: formatted_date) end end   Technically speaking, it creates so-called exception boundaries.  result = FormatDate.result(string: &quot;2024/07/16&quot;) # =&gt; # &lt;FormatDate::Result status: :error data_keys: [:exception] message: &quot;Date::Error: # ... #   As a consequence, only a single service has an unpredicted mistake, but since its negative effect is isolated, the rest of the system stays functional.  Due to the fact that unhandled exceptions can not leak outside error results boundaries, the code becomes fault-tolerant by default.  info Currently, the RescuesResultUnhandledExceptions plugin is not included in the Standard configuration. End-users have the ability to decide by themselves whether to add it or not. For example, the best practice says to use it for development and production environments. This way you can learn how the plugin works during development and have a calm and healthy sleep when the code is released. But for the testing environment, it is still beneficial to not auto rescue exceptions to find them faster.  caution This article demonstrates the concept that there is a possibility of an automated fallback for exceptions. However, developers still need to reasonably predict the edge cases and describe them explicitly in order to have more explanatory error messages. So, the properly finished FormatDate service is written below. class FormatDate include ConvenientService::Standard::Config attr_reader :string middlewares :result do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end def initialize(string:) @string = string end def result success(date_time: ::DateTime.strptime(string, format)) rescue ::Date::Error error(&quot;String `#{string}` does NOT follow date time `#{format}`&quot;) end end  ","version":"Next","tagName":"h2"},{"title":"Why `case/when` does NOT work with just result codes?","type":0,"sectionRef":"#","url":"/faq/why_case_when_does_not_work_with_jus_result_codes","content":"Why `case/when` does NOT work with just result codes? Sometimes it may feel idiomatic to check the result code in the following way: # wrong if result.not_success? case result.code # `result.code` returns fancy object when :full_queue notify_devops when :duplicated_job notify_devs else # ... end end Although this snippet looks very appealing, it won't work as expected. A lot of Ruby folks often have an assumption that a value of case is compared with a value of when. case value === when value In other words, the case/when from example above can be transformed to if/else like so: # wrong if result.not_success? if result.code === :full_queue notify_devops elsif result.code === :duplicated_job notify_devs else # ... end end But, that is NOT correct. In reality, the value of when is always compared with the value of case. when value === case value Let's write the proper transformation: # okish if result.not_success? if :full_queue === result.code notify_devops elsif :duplicated_job === result.code notify_devs else # ... end end Symbol#=== is just an alias to Symbol#==. There is no way to hook into any behavior like with strings (String#=== calls to_str on its argument). As a result, just case result.code is not enough. But once you use case result.code.to_sym, the natural Ruby charm is back. # ok if result.not_success? case result.code.to_sym when :full_queue notify_devops when :duplicated_job notify_devs else # ... end end ","keywords":"","version":"Next"},{"title":"Why to use Convenient Service?","type":0,"sectionRef":"#","url":"/faq/why_to_use_convenient_service","content":"Why to use Convenient Service? This page provides a non-complete and unsorted catalog of possible motivations to utilize Convenient Service in your project. Some of them are specific to Convenient Service, some others are applicable to any service object implementations. For now, those motivations are structured as a list of topics. After a while, all of them will have their corresponding articles. Separate classes for services give isolated scopes for private methods. Separate classes for services give isolated scopes for caching intermediate calculations. Separate classes for services allow to avoid passing huge lists of parameters to methods. Separate classes for services encourage single responsibility. Services allow to express complex conditional logic as sequences of steps. Service steps describe processes/flows/algorithms in a declarative way. Services are easy to test. Service tests structure is reproducible. Services are easy to stub. Services are like functions, so patterns from functional programming may be applied to them. or steps encourage to think about fallbacks from the beginning. The failure and error separation encourages to think about fallbacks from the beginning. The FaultTolerance configuration automatically catches unhandled exceptions. Service results give the exact reason of what went wrong. Service results give a unified interface for all kinds of outcomes. Folders with services provide quick overviews of possible operations. Convenient Service is intuitive. Convenient Service is simple. Convenient Service follows the learn once, use everywhere principle. Convenient Service discourages inheritance. Convenient Service is a DSL for advanced control flow. Convenient Service is easy to extend. Convenient Service is feature-rich. Convenient Service is focused. Convenient Service is user-friendly. Convenient Service is well-maintained. To be continued...","keywords":"","version":"Next"},{"title":"Standard::V1::Config","type":0,"sectionRef":"#","url":"/glossary/advanced/standard_v1","content":"Standard::V1::Config ConvenientService::Standard::V1::Config is an outdated service configuration. It was created as a reaction to the breaking change introduced between ConvenientService v0.13.0 and v0.14.0 versions. Its development is currently stopped and it won't receive any updates, except critical backports. This config already lacks of new plugins for fallbacks and extended ROP concepts. And this list will grow up over time. If you have any old services that are using ConvenientService::Standard::V1::Config, please don't worry too much. Luckily, the migration process is pretty strightforward.","keywords":"","version":"Next"},{"title":"Proxy Middleware","type":0,"sectionRef":"#","url":"/glossary/advanced/proxy_middleware","content":"Proxy Middleware A proxy middleware is a kind of middleware that may skip calling the next middleware in a chain. CachesReturnValue is a good example. module ConvenientService module Common module Plugins module CachesReturnValue class Middleware &lt; Core::MethodChainMiddleware # ... def next(*args, **kwargs, &amp;block) key = cache.keygen(:return_values, method, *args, **kwargs, &amp;block) cache.fetch(key) { chain.next(*args, **kwargs, &amp;block) } end # ... end end end end end When the cache does NOT contain any value by key, it calls the next middleware in the chain and stores its return value. When the cache already contains a value by key, it does NOT trigger the next middleware at all. That is why this middleware is considered proxy middleware. In contrast, decorator middlewares always call chain.next. note cache.fetch in CachesReturnValue has the same semantics as Ruby's Hash#fetch.","keywords":"","version":"Next"},{"title":"Decorator Middleware","type":0,"sectionRef":"#","url":"/glossary/advanced/decorator_middleware","content":"Decorator Middleware A decorator middleware is a kind of middleware that always calls the next middleware in a chain. HasCallbacks is a good example. module ConvenientService module Common module Plugins module HasCallbacks class Middleware &lt; Core::MethodChainMiddleware # ... def next(...) entity.callbacks.for([:before, method]).each { |callback| callback.call_in_context(entity) } original_value = chain.next(...) entity.callbacks.for([:after, method]).reverse_each { |callback| callback.call_in_context(entity, original_value) } original_value end # ... end end end end end It triggers before callbacks, then chain.next(...), and later after callbacks. There are no conditionals that may skip chain.next(...) invocation. That is why this middleware is considered decorator middleware. In contrast, proxy middlewares may not call chain.next if needed.","keywords":"","version":"Next"},{"title":"Clean Code","type":0,"sectionRef":"#","url":"/glossary/clean_code","content":"Clean Code When: The author's intention is obvious.In less than 10 minutes.With minimal context.Without diving into implementation.Without running that code. caution By the Convenient Service custom definition.","keywords":"","version":"Next"},{"title":"Boolean Service","type":0,"sectionRef":"#","url":"/glossary/boolean_service","content":"Boolean Service Boolean service is a service that confirms/denies the concrete assumption. Boolean service is a service that answers to the specific question. Boolean service is a service whose success result has no data. success result from the boolean service confirms the assumption stated in its name. In other words, it answers positively to the question. failure result from the boolean service tells why exactly the assumption is NOT accurate. In other words, it answers negatively to the question + provides the reason. error result explains why there is no even hypothetical opportunity to confirm/deny the assumption. In other words, it gives no answer to the question at all. Here are some examples of such services: class IsEmployeeFree attr_reader :employee def initialize(employee:) @employee = employee end def result return error(&quot;Employee can't be blank&quot;) if employee.blank? return failure(&quot;Employee `#{employee.id}` has task `#{employee.tasks.find(&amp;:in_progress?).id}` in progress&quot;) if employee.tasks.any?(&amp;:in_progress?) success end end IsEmployeeFree assumes that an employee is available. The following command either confirms or denies that assumption. IsEmployeeFree.success?(employee: employee) class IsTaskUnassigned attr_reader :task def initialize(task:) @task = task end def result return error(&quot;Task can't be blank&quot;) if task.blank? return failure(&quot;Task `#{task.id}` has employee `#{task.employee}`&quot;) if task.employee.present? success end end IsTaskUnassigned asks a question - is a task not assigned to anyone? The expression below answers it either positively or negatively. IsEmployeeFree.success?(employee: employee) Also as with any other type of service, the boolean service can be triggered via the result method or a step: result = IsEmployeeFree.result(employee: employee) class AssignTaskToEmployee include ConvenientService::Standard::Config attr_reader :task, :employee step IsTaskUnassigned, in: :task step IsEmployeeFree, in: :employee def initialize(task:, employee:) @task = task @employee = employee end def result task.employee = employee saved = task.save return failure(&quot;Employee `#{employee.id}` is NOT saved to task `#{task.id}`&quot;) unless saved success end end ","keywords":"","version":"Next"},{"title":"How to debug the lib?","type":0,"sectionRef":"#","url":"/guides/advanced/debugging/how_to_debug_lib","content":"How to debug the lib? Convenient Service has already more than 5000 unit and integration tests. That is not the end, more specs are constantly added to cover even the craziest cases. But since it is relatively a new library something unpredicatable may still happen. Prefer to create a GitHub issue, when you encounter unexpected behavior. However, if you are curious and enthusiastic enough, you can always try to dive deep and debug the &quot;nifty&quot; inner parts by yourself. First of all, navigate to the directory with a project that uses Convenient Service as a dependency. cd your_project In other words, you have it in your project Gemfile like so: Gemfile gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Make sure Convenient Service is installed. bundle install Open the gem source. Set the EDITOR env variable to your favorite code editing tool. The command below uses VS Code. EDITOR=code bundle open convenient_service Select any file you need and place a debugger call in it. The following example utilizes byebug. Start your project (irb console, Rails server, RSpec suite, Rake tasks) to trigger the code that seems to be broken. Happy debugging! danger Do not forget to erase the debugger call once finished debugging. caution binding.pry is an amazing instrument, but is NOT a debugger, it is a REPL. REPL has a completely different purpose, it can enhance the debugger, but not replace it. A casual REPL does not support even half of the possibilities that a mature debugger provides. Just to name some of them, line-by-line debugging, up and down stack navigation, dynamic breakpoints, etc. Don't like byebug since it does not highlight the syntax ü§¶? Then this gist is for you. Still don't like byebug? Use binding.break - a modern debugger developed by the Ruby core team.","keywords":"","version":"Next"},{"title":"Entry","type":0,"sectionRef":"#","url":"/glossary/fdd/entry","content":"Entry Entry is a single part of the feature's public interface. Let's check the following feature class. module Application module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do |path:| Services::Format.result(path: path) end entry :lint do |path:| Services::Lint.result(path: path) end end end end After a brief overview, you should start to have a high-level understanding of the goal of the Gemfile feature and what to do with it in practice. In this particular case, two abilities are available: Formatting of a Gemfile (entry :format). Linting of a Gemfile (entry :lint). Calling of an entry is as simple as: # Somewhere inside your codebase. App::Features::Gemfile.format(path: &quot;Gemfile&quot;) App::Features::Gemfile.lint(path: &quot;Gemfile&quot;) That's why people are often thinking about entries as something really close to Ruby's regular class methods. ## # The actual entry. # entry :format do |path:| Services::Format.result(path: path) end ## # Just a mental concept to imagine entries as wrappers over class methods (under the hood they are something not so straightforward, but this is a topic for a different story). # def self.format(path:) Services::Format.result(path: path) end Eventually, a list of entries may and must be considered as a Facade in front of the complex system. tip While having a code review of a new (or existing) feature, prefer to check its list of entries at the very beginning. This is the way to quickly get a summary of the feature and its main purpose. In other words, to get so-called &quot;minimal context&quot;. After that, the intention of the internal feature services may become more obvious (hopefully üôÇ). tip In order to find all feature triggers, just search for entries invocations using your favorite code editor.","keywords":"","version":"Next"},{"title":"How to print library logs?","type":0,"sectionRef":"#","url":"/guides/advanced/logging/how_to_print_lib_logs","content":"","keywords":"","version":"Next"},{"title":"Log levels‚Äã","type":1,"pageTitle":"How to print library logs?","url":"/guides/advanced/logging/how_to_print_lib_logs#log-levels","content":" It is possible to configure internal library logging by using the CONVENIENT_SERVICE_LOGGER_LEVEL env variable.  It is defaulting to info, which is why the majority of the logs are skipped most of the time.  But you can modify this behavior by setting a different severity level.  Just place the env variable in front of the command that starts your Ruby process which utilizes Convenient Service.  For example:  CONVENIENT_SERVICE_LOGGER_LEVEL=debug bundle exec rails console   Since the Convenient Service logger is based on the Ruby stdlib Logger, it supports the same levels.  Here is the screenshot straight from its official docs.    warning When your project uses Ruby stdlib Logger with a version older than 1.3.0, then log levels as words are not supported yet. Pass numbers in such cases. CONVENIENT_SERVICE_LOGGER_LEVEL=0 bundle exec rails console   ","version":"Next","tagName":"h2"},{"title":"Colored logs‚Äã","type":1,"pageTitle":"How to print library logs?","url":"/guides/advanced/logging/how_to_print_lib_logs#colored-logs","content":" If you have Ruby Paint gem as a dependency, and it is required, then CONVENIENT_SERVICE_LOGGER_ENABLE_COLORS env variable activates coloring like so:  CONVENIENT_SERVICE_LOGGER_LEVEL=0 CONVENIENT_SERVICE_LOGGER_ENABLE_COLORS=true bundle exec rails console   ","version":"Next","tagName":"h2"},{"title":"Configuration via script‚Äã","type":1,"pageTitle":"How to print library logs?","url":"/guides/advanced/logging/how_to_print_lib_logs#configuration-via-script","content":" Convenient Service logger can be accessed inside any Ruby source as well.  For example:  ConvenientService.logger.level = Logger::INFO  ","version":"Next","tagName":"h2"},{"title":"How to access result attributes without checking its status?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_access_result_attributes_without_checking_its_status","content":"","keywords":"","version":"Next"},{"title":"Use Result#unsafe_data, Result#unsafe_message, Result#unsafe_code‚Äã","type":1,"pageTitle":"How to access result attributes without checking its status?","url":"/guides/debugging/how_to_access_result_attributes_without_checking_its_status#use-resultunsafe_data-resultunsafe_message-resultunsafe_code","content":"   ","version":"Next","tagName":"h2"},{"title":"Even better, use shorter aliases Result#ud, Result#um, Result#uc‚Äã","type":1,"pageTitle":"How to access result attributes without checking its status?","url":"/guides/debugging/how_to_access_result_attributes_without_checking_its_status#even-better-use-shorter-aliases-resultud-resultum-resultuc","content":"  ","version":"Next","tagName":"h2"},{"title":"How to migrate from `Standard::V1`?","type":0,"sectionRef":"#","url":"/guides/advanced/deprecations/how_to_migrate_from_standard_v1","content":"How to migrate from `Standard::V1`? Consider the following old service that is using the outdated ConvenientService::Standard::V1::Config. class AssertFileNotEmpty include ConvenientService::Standard::V1::Config attr_reader :path def initialize(path:) @path = path end def result return failure(path: &quot;Path is \\`nil\\`&quot;) if path.nil? return failure(path: &quot;Path is empty&quot;) if path.empty? return error(&quot;File is empty at path \\`#{path}\\`&quot;) if ::File.zero?(path) success end end Its specs may look like this: require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results include ConvenientService::RSpec::Matchers::IncludeModule let(:result) { described_class.result(path: path) } example_group &quot;modules&quot; do subject { described_class } it { is_expected.to include_module(ApplicationService::Config) } end example_group &quot;class methods&quot; do describe &quot;.result&quot; do context &quot;when assertion that file exists is NOT successful&quot; do context &quot;when `path` is NOT valid&quot; do context &quot;when `path` is `nil`&quot; do let(:path) { nil } it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is `nil`&quot;).of_service(described_class).without_step end end context &quot;when `path` is empty&quot; do let(:path) { &quot;&quot; } it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is empty&quot;).of_service(described_class).without_step end end end context &quot;when file with `path` does NOT exist&quot; do let(:path) { &quot;non_existing_path&quot; } it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;File with path `#{path}` does NOT exist&quot;).of_service(described_class).without_step end end end context &quot;when assertion that file exists is successful&quot; do ## # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection. # let(:tempfile) { Tempfile.new } let(:path) { tempfile.path } it &quot;returns `success`&quot; do expect(result).to be_success.of_service(described_class).without_step end end end end end In order to migrate it, we need to perform four actions: Rename the outdated configuration to the modern one. class AssertFileNotEmpty # before include ConvenientService::Standard::V1::Config # after include ConvenientService::Standard::Config # ... end Rename failures and errors results inside the source code. class AssertFileNotEmpty # ... # before def result return failure(path: &quot;Path is \\`nil\\`&quot;) if path.nil? return failure(path: &quot;Path is empty&quot;) if path.empty? return error(&quot;File is empty at path \\`#{path}\\`&quot;) if ::File.zero?(path) success end # after def result return error(&quot;Path is \\`nil\\`&quot;) if path.nil? return error(&quot;Path is empty&quot;) if path.empty? return failure(&quot;File is empty at path \\`#{path}\\`&quot;) if ::File.zero?(path) success end end caution This update should NOT be &quot;blind&quot;. Make sure failures and errors are used according to their meanings. Rename failures and errors results inside the specs. require &quot;spec_helper&quot; RSpec.describe AssertFileExists do # ... # before it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is `nil`&quot;).of_service(described_class).without_step end # after it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;Path is `nil`&quot;).of_service(described_class).without_step end # before it &quot;returns `failure` with `data`&quot; do expect(result).to be_failure.with_data(path: &quot;Path is empty&quot;).of_service(described_class).without_step end # after it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;Path is empty&quot;).of_service(described_class).without_step end # before it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;File with path `#{path}` does NOT exist&quot;).of_service(described_class).without_step end # after it &quot;returns `failure` with `message`&quot; do expect(result).to be_failure.with_message(&quot;File with path `#{path}` does NOT exist&quot;).of_service(described_class).without_step end # ... end caution Again, please, ensure that failures and errors are used according to their meanings. Otherwise, this renaming makes no sense. Repeat the same procedure for the rest services that are using ConvenientService::Standard::V1::Config. danger Do not mix services with the modern and outdated configurations. For example, that is possible with steps. Instead, update all outdated services at once or delay this refactoring for the better times. If you structure your services as isolated features, then refactor the whole feature.","keywords":"","version":"Next"},{"title":"How to access result original service?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_access_result_original_service","content":"How to access result original service? The Result#service method returns the service instance that created its result. For example: class Service include ConvenientService::Standard::Config def result success end end result = Service.result # =&gt; &lt;Service::Result status: :success&gt; result.service # =&gt; &lt;Service&gt; When the result is bubbled up from a deeply nested step, the Result#service method returns a top-level organizer instance. Let's see it in practice: class TwoLevelsNestedService include ConvenientService::Standard::Config def result success end end class OneLevelNestedService include ConvenientService::Standard::Config step TwoLevelsNestedService end class Service include ConvenientService::Standard::Config step OneLevelNestedService end result = Service.result # =&gt; &lt;Service::Result status: :success&gt; result.service # =&gt; &lt;Service&gt; Here, the TwoLevelsNestedService creates a success result. Later this result is processed by steps from the OneLevelNestedService and Service services. That is why it becomes the Service overall result. result.service # =&gt; &lt;Service&gt; Sometimes it may be useful to access the original service instance, e.g. for debugging purposes. For that reason the Result#original_service method is available. result.original_service # =&gt; &lt;TwoLevelsNestedService&gt; ","keywords":"","version":"Next"},{"title":"How to check whether the result comes from an unhandled exception?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_check_whether_result_comes_from_unhandled_exception","content":"How to check whether the result comes from an unhandled exception? warning The functionality described on this page is available from v0.20. The Result#from_unhandled_exception? and Result#exception methods answer this question. Consider the following regular service. class Service include ConvenientService::Standard::Config include ConvenientService::FaultTolerance::Config def result success end end It uses the FaultTolerance configuration to automatically rescue all unhandled exceptions and convert them to error results. In this example, it just returns a success. result = Service.result # =&gt; &lt;Service::Result status: :success&gt; So when we query whether the result is from an unhandled exception or not it gives us false. result.from_unhandled_exception? # =&gt; false And result.unhandled_exception returns nil respectively. result.unhandled_exception # =&gt; nil Let's have a look at other service. class OtherService include ConvenientService::Standard::Config include ConvenientService::FaultTolerance::Config def result 16 / 0 success end end It intentionally divides 16 by 0 to cause an unhandled exception. When we invoke the OtherService result, that exception is automatically rescued by the FaultTolerance configuration and converted into error. result = OtherService.result # =&gt; &lt;OtherService::Result status: :error data_keys: [:exception] message: &quot;ZeroDivisionError...&quot;&gt; Now from_unhandled_exception returns true. result.from_unhandled_exception? # =&gt; true And result.unhandled_exception gives access to the original Ruby exception. result.unhandled_exception # =&gt; #&lt;ZeroDivisionError: divided by 0&gt; warning The FaultTolerance configuration rescues only StandardError descendants, not direct Exception descendants, since they are reserved by Ruby.","keywords":"","version":"Next"},{"title":"How to call a method skipping its middlewares?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_call_method_skipping_its_middlewares","content":"How to call a method skipping its middlewares? warning The functionality described on this page is available from v0.20. For some rare cases, it may be useful to have a way to call a method skipping all its middlewares. Consider the following example. class Service include ConvenientService::Standard::Config def result success end end To make it more illustrative, let's add a simple middleware that just prints some text before and after calling the original result. class Middleware &lt; ConvenientService::MethodChainMiddleware def next(...) puts &quot;Before calling `#{method}`...&quot; value = chain.next(...) puts &quot;After calling `#{method}`...&quot; value end end This is how it can be registered. class Service include ConvenientService::Standard::Config middlewares :result, scope: :class do use Middleware end def result success end end So now, when we invoke Service.result, additional logs are printed. result = Service.result # Before calling result... # After calling result... # =&gt; &lt;Service::Result status: :success&gt; But there is still a possibility to call it without middlewares like so: result = Service.result_without_middlewares # =&gt; &lt;Service::Result status: :success&gt; note When the original method ends with ?, like success?, the corresponding skipping method is success_without_middlewares?. The same rule is applicable for methods with trailing !. bar! -&gt; bar_without_middlewares!. danger Keep in mind that the ability to skip middlewares is present just for debugging purposes. There are NO common use cases for the production business code with it.","keywords":"","version":"Next"},{"title":"How to find result parents?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_find_result_parents","content":"","keywords":"","version":"Next"},{"title":"Use Result#parents‚Äã","type":1,"pageTitle":"How to find result parents?","url":"/guides/debugging/how_to_find_result_parents#use-resultparents","content":"  ","version":"Next","tagName":"h2"},{"title":"How to find result step?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_find_result_step","content":"","keywords":"","version":"Next"},{"title":"Use Result#step‚Äã","type":1,"pageTitle":"How to find result step?","url":"/guides/debugging/how_to_find_result_step#use-resultstep","content":"  ","version":"Next","tagName":"h2"},{"title":"How to rescue all result unhandled exceptions?","type":0,"sectionRef":"#","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions","content":"","keywords":"","version":"Next"},{"title":"Use RescuesResultUnhandledExceptions plugin‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#use-rescuesresultunhandledexceptions-plugin","content":" danger RescuesResultUnhandledExceptions plugin intentionally rescues only StandardErrors, not Exceptions.  info RescuesResultUnhandledExceptions plugin is especially useful for the Fault Tolerant production environments.  caution RescuesResultUnhandledExceptions plugin is NOT included in the Standard config by default. It is up to the end-users to decide whether it is needed for thier applications or not.  ","version":"Next","tagName":"h2"},{"title":"Option 1: Modify config to rescue results in all services‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#option-1-modify-config-to-rescue-results-in-all-services","content":"   ConvenientService::Dependencies.require_rescues_result_unhandled_exceptions   module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config middlewares :result, scope: :class do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end end end end end   class Service include ApplicationService::Config def result raise StandardError, &quot;exception message&quot; end end   ","version":"Next","tagName":"h3"},{"title":"Option 2: Modify service to rescue results in a single service‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#option-2-modify-service-to-rescue-results-in-a-single-service","content":"   ConvenientService::Dependencies.require_rescues_result_unhandled_exceptions   module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config end end end end   class Service include ApplicationService::Config middlewares :result, scope: :class do use ConvenientService::Plugins::Service::RescuesResultUnhandledExceptions::Middleware end def result raise StandardError, &quot;exception message&quot; end end   ","version":"Next","tagName":"h3"},{"title":"Result with exception becomes an error‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#result-with-exception-becomes-an-error","content":"   info Convenient Service core team strongly believes that it is a responsibility of a developer to predict all possible exceptions reasonably. That is why the result is an error, not a failure.  result = Service.result   result.success?   puts result.message   ","version":"Next","tagName":"h2"},{"title":"Result has access to the original exception object‚Äã","type":1,"pageTitle":"How to rescue all result unhandled exceptions?","url":"/guides/exception_handling/how_to_rescue_all_result_unhandled_exceptions#result-has-access-to-the-original-exception-object","content":" info result.data[:exception] is Ruby's StandardError object that inherits from Exception.    result.data[:exception]   result.data[:exception].class   result.data[:exception].message   result.data[:exception].backtrace.to_a.take(10)   result.data[:exception].cause  ","version":"Next","tagName":"h2"},{"title":"How to debug services via callbacks?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_debug_services_via_callbacks","content":"","keywords":"","version":"Next"},{"title":"Use after result‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-after-result","content":" after :result do |result| binding.pry end   ","version":"Next","tagName":"h2"},{"title":"Use after step‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-after-step","content":" ## # Step is Result-like duck. # after :step do |step| byebug end   ","version":"Next","tagName":"h2"},{"title":"Use around result‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-around-result","content":" after :result do |chain| puts &quot;before&quot; result = chain.yield p &quot;after&quot; end   ","version":"Next","tagName":"h2"},{"title":"Use after step‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#use-after-step-1","content":" ## # Step is Result-like duck. # after :step do |step| binding.break step = chain.yield print &quot;after&quot; end   ","version":"Next","tagName":"h2"},{"title":"Real-world example‚Äã","type":1,"pageTitle":"How to debug services via callbacks?","url":"/guides/debugging/how_to_debug_services_via_callbacks#real-world-example","content":" # frozen_string_literal: true module Services class AssertNpmPackageAvailable include ConvenientService::Standard::Config attr_reader :name step :validate_name step Services::AssertNodeAvailable step Services::RunShell, in: {command: -&gt; { &quot;npm list #{name} --depth=0 &gt; /dev/null 2&gt;&amp;1&quot; }} after :result do |result| binding.pry end after :step do |step| byebug end def initialize(name:) @name = name end private def validate_name return error(&quot;Name is `nil`&quot;) if name.nil? return error(&quot;Name is empty&quot;) if name.empty? success end end end  ","version":"Next","tagName":"h2"},{"title":"Setup in Minitest","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_minitest","content":"Setup in Minitest Currently Convenient Service does not have Minitest extentions üò¢. But they are planned for subsequent releases ü•π. Consequently, the setup process is pretty much the same as for the regular Ruby project. Happy testing!","keywords":"","version":"Next"},{"title":"Setup in RSpec","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_rspec","content":"Setup in RSpec As always, add a new entry to your Gemfile as the first step. gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Then run bundle to install the gem. bundle install Add the following line to your spec_helper.rb or rails_helper.rb. ConvenientService::Dependencies.require_rspec_extentions To ensure Convenient Service RSpec extentions are properly loaded, define a quick service, for example: class Service include ConvenientService::Standard::Config def result success end end Create the specs for it. RSpec.describe Service do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result } context &quot;when `Service` is successful&quot; do it &quot;returns `success`&quot; do expect(result).to be_success.of_service(described_class).with_data.without_step end end end end end Finally, run them. bundle exec rspec spec/service_spec.rb That's it. Happy testing!","keywords":"","version":"Next"},{"title":"Setup in a Ruby project","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_ruby","content":"Setup in a Ruby project As always, add a new entry to your Gemfile as the first step. gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Then run bundle to install the gem. bundle install Once finished, require the gem. require &quot;convenient_service&quot; To ensure the lib is properly loaded you can define the following service. class Service include ConvenientService::Standard::Config def result success end end And run it by the command below. Service.result That's it. Happy coding!","keywords":"","version":"Next"},{"title":"Setup in a Rails project","type":0,"sectionRef":"#","url":"/guides/setup/how_to_set_up_in_rails","content":"Setup in a Rails project As always, add a new entry to your Gemfile as the first step. gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot; Then run bundle to install the gem. bundle install To mimic the classic Rails folder structure, you may consider creating app/services directory like so: mkdir -p app/services But feel free to select other directory if you like. app/services is chosen for a demonstration since it is autoloaded by Rails. Place a configuration file into it. A common name may be application_service/config.rb. mkdir -p app/services/application_service &amp;&amp; touch app/services/application_service/config.rb This example utilizes Standard or Rails configs, but you can also pick any other predefined configuration, create customization, or even have multiple configs. StandardRails app/services/application_service/config.rb module ApplicationService module Config include ConvenientService::Config included do include ConvenientService::Standard::Config end end end Now you have everything ready to create fancy services for your application. (Do not forget to include config into them üôÇ) StandardRails app/services/print_what_cow_says.rb class PrintWhatCowSays include ApplicationService::Config attr_reader :text def initialize(text: &quot;Hello World!&quot;) @text = text end def result puts template(text) success end private ## # Copied with ‚ù§Ô∏è from https://github.com/gaborbata/rosetta-cow # def template(text) cloud = &lt;&lt;~HEREDOC #{border(text, &quot;_&quot;)} &lt; #{text} &gt; #{border(text, &quot;-&quot;)} HEREDOC cow = &lt;&lt;~'HEREDOC'.split(&quot;\\n&quot;).map { |line| &quot; &quot; * 10 + line }.join(&quot;\\n&quot;) \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || HEREDOC cloud + cow end def border(text, char) char * (text.length + 2) end end That's it. Happy coding!","keywords":"","version":"Next"},{"title":"How to use entries?","type":0,"sectionRef":"#","url":"/guides/fdd/usage/how_to_create_and_invoke_entries","content":"","keywords":"","version":"Next"},{"title":"How to create an entry?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-create-an-entry","content":" There are two ways to do it - block and method forms.  This is how it can be done using the block form.  module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do Services::Format.result(path: &quot;#{::Dir.pwd}/Gemfile&quot;) end end end   The following code snippet demonstrates the equivalent method form.  module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format def format Services::Format.result(path: &quot;#{::Dir.pwd}/Gemfile&quot;) end end end   ","version":"Next","tagName":"h2"},{"title":"How to define arguments for entries?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-define-arguments-for-entries","content":" Since entries are built on the top of the regular Ruby blocks and methods you are able to utilize the techniques that you already know.  Here are some examples of how to define positional and keyword arguments.  The block form:  module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do |path, verbose: false| Services::Format.result(path: path, verbose: verbose) end end end   The method form:  module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format def format(path, verbose: false) Services::Format.result(path: path, verbose: verbose) end end end   Entries with variable arguments list may look like as follows.  The block form:  module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format do |*args, **kwargs, &amp;block| path = args.first verbose = block ? block.call : kwargs[:verbose] Services::Format.result(path: path, verbose: verbose) end end end   The method form:  module Features class Gemfile include ConvenientService::Feature::Standard::Config entry :format def format(*args, **kwargs, &amp;block) path = args.first verbose = block ? block.call : kwargs[:verbose] Services::Format.result(path: path, verbose: verbose) end end end   ","version":"Next","tagName":"h2"},{"title":"How to invoke an entry?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-invoke-an-entry","content":" No matter whether an entry was defined by a block or by a method, its invocation is the same, e.g:  Features::Gemfile.format   Features::Gemfile.format(path, verbose: true)   Features::Gemfile.format(*args, **kwargs, &amp;block)   ","version":"Next","tagName":"h2"},{"title":"How to add a middleware for all entries?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-add-a-middleware-for-all-entries","content":" Check the following feature.  module Features class SomeFeature include ConvenientService::Feature::Standard::Config entry :some_entry_without_arguments entry :some_entry_with_arguments def some_entry_without_arguments puts &quot;Entry `some_entry_without_arguments` called.&quot; end def some_entry_with_arguments(*args, **kwargs, &amp;block) puts &quot;Entry `some_entry_with_arguments` called.&quot; end end end   It has two entries that are displaying some text on the screen.  For example:  Features::SomeFeature.some_entry_without_arguments # &quot;Entry `some_entry_without_arguments` called.&quot; # =&gt; nil   Features::SomeFeature.some_entry_with_arguments # &quot;Entry `some_entry_with_arguments` called.&quot; # =&gt; nil   Now, let's define a simple middleware.  class TestMiddleware &lt; ConvenientService::MethodMiddleware def next(entry_name, *args, **kwargs, &amp;block) puts &quot;`TestMiddleware` called for entry `#{entry_name}` with args `#{args.inspect}`, kwargs `#{kwargs.inspect}` and block `#{block.inspect}`.&quot; chain.next(entry_name, *args, **kwargs, &amp;block) end end   It logs the entry name and its arguments.  Then it triggers the original entry behaviour.  In order to register a middleware for all entries inside the particular feature, use the middlewares :entry directive.  module Features class SomeFeature include ConvenientService::Feature::Standard::Config middlewares :entry do use TestMiddleware end entry :some_entry_without_arguments entry :some_entry_with_arguments def some_entry_without_arguments puts &quot;Entry `some_entry_without_arguments` called.&quot; end def some_entry_with_arguments(*args, **kwargs, &amp;block) puts &quot;Entry `some_entry_with_arguments` called.&quot; end end end   Now the TestMiddleware is executed before any entry invocation.  This is how it looks in practice.  Features::SomeFeature.some_entry_without_arguments # &quot;`TestMiddleware` called for entry `some_entry_without_arguments` with args `[]`, kwargs `{}` and block `nil`.&quot; # &quot;Entry `some_entry_without_arguments` called.&quot; # =&gt; nil   Features::SomeFeature.some_entry_with_arguments(:foo, foo: :bar) { :foo } # &quot;`TestMiddleware` called for entry `some_entry_with_arguments` with args `[:foo]`, kwargs `{:foo=&gt;:bar}` and block `#&lt;Proc:0x00000001227756c8.&gt;`.&quot; # &quot;Entry `some_entry_with_arguments` called.&quot; # =&gt; nil   ","version":"Next","tagName":"h2"},{"title":"How to add a middleware for the specific entry?‚Äã","type":1,"pageTitle":"How to use entries?","url":"/guides/fdd/usage/how_to_create_and_invoke_entries#how-to-add-a-middleware-for-the-specific-entry","content":" The process is almost the same as with the addition of a middleware for all entries.  But the arguments list does not start with positional entry_name.  info It is still possible to access entry_name via method method üôÇ.  class TestMiddleware &lt; ConvenientService::MethodMiddleware def next(*args, **kwargs, &amp;block) puts &quot;`TestMiddleware` called for entry `#{method}` with args `#{args.inspect}`, kwargs `#{kwargs.inspect}` and block `#{block.inspect}`.&quot; chain.next(*args, **kwargs, &amp;block) end end   The registration directive contains the specific entry name.  module Features class SomeFeature include ConvenientService::Feature::Standard::Config middlewares :some_entry do use TestMiddleware end entry :some_entry entry :some_other_entry def some_entry(first_positional_argument, second_positional_argument) puts &quot;Entry `some_entry` called.&quot; end def some_other_entry puts &quot;Entry `some_other_entry` called.&quot; end end end   Thus the TestMiddleware is executed only before specific entry invocation.  Features::SomeFeature.some_entry(:foo, :bar) # &quot;`TestMiddleware` called for entry `some_entry` with args `[:foo, :bar]`, kwargs `{}` and block `nil`.&quot; # &quot;Entry `some_entry` called.&quot; # =&gt; nil   All the other entries stay unaffected.  Features::SomeFeature.some_other_entry # &quot;Entry `some_other_entry` called.&quot; # =&gt; nil  ","version":"Next","tagName":"h2"},{"title":"How to test a regular service?","type":0,"sectionRef":"#","url":"/guides/testing/how_to_test_regular_service","content":"","keywords":"","version":"Next"},{"title":"How to test a regular service with RSpec?‚Äã","type":1,"pageTitle":"How to test a regular service?","url":"/guides/testing/how_to_test_regular_service#how-to-test-a-regular-service-with-rspec","content":" First of all, let's create a spec file.  Imagine the original service is stored in app/services/assert_file_exists.rb.  Then its specs are usually living in spec/services/assert_file_exists_spec.rb by convention.  This is a quick command of how to create it.  mkdir -p spec/services &amp;&amp; touch spec/services/assert_file_exists_spec.rb   As the next step, we are going to require a spec_helper and add a top-level describe with the service class into it.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do end   Then, we introduce a so-called example group for the class methods.  info RSpec example_group and context are just aliases.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do example_group &quot;class methods&quot; do end end   It may seem redundant to define such an example group, but it is already kind of a pattern in specs for services created by the Convenient Servive.  You will see the real benefit of it once we review the testing of more complex services.  Coming back to the AssertFileExists, most of the time we interact with it using its result class method, which is why we add a corresponding context for it.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do example_group &quot;class methods&quot; do context &quot;.result&quot; do end end end   Next, when looking from the most narrow perspective, a service is either successful or not successful.  So we reflect that point with two more contexts.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do example_group &quot;class methods&quot; do describe &quot;.result&quot; do context &quot;when `AssertFileExists` is NOT successful&quot; do end context &quot;when `AssertFileExists` is successful&quot; do end end end end   Also Convenient Service provides some ready-to-use custom RSpec matchers to verify service results.  They can be included as follows.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do context &quot;when `AssertFileExists` is NOT successful&quot; do end context &quot;when `AssertFileExists` is successful&quot; do end end end end   Now, we have just built the basic service specs boilerplate code.  It will be almost the same in most of the cases, so feel free to come back to this page and copy this template whenever you test a new service.  info Specs boilerplate generators are planned for the future Convenient Service versions. bundle exec rails generate convenient_service service AssertFileExists # create lib/services/assert_file_exists.rb # invoke rspec # create spec/lib/services/assert_file_exists_spec.rb   Having the boilerplate already set, let's recall the AssertFileExists source to decide which exact tests we need to implement.  class AssertFileExists include ConvenientService::Standard::Config attr_reader :path def initialize(path:) @path = path end def result return error(&quot;Path is `nil`&quot;) if path.nil? return error(&quot;Path is empty&quot;) if path.empty? return failure(&quot;File with path `#{path}` does NOT exist&quot;) unless ::File.exist?(path) success end end   This is how an it example can be added for the case when path is nil.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `AssertFileExists` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do let(:path) { nil } it &quot;returns `error`&quot; do expect(result).to be_error.with_message(&quot;Path is `nil`&quot;) end end end context &quot;when `AssertFileExists` is successful&quot; do end end end end   We have utilized RSpec let and described_class to define the service result.  After that we verified it by a custom matcher be_error and its with_message chaining.  info The be_error matcher also has and_message, with_code, and and_code chainings.  An it for the case when path is an empty string is very similar.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `AssertFileExists` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do let(:path) { nil } it &quot;returns `error`&quot; do expect(result).to be_error.with_message(&quot;Path is `nil`&quot;) end end context &quot;when `path` is empty&quot; do let(:path) { nil } it &quot;returns `error`&quot; do expect(result).to be_error.with_message(&quot;Path is empty&quot;) end end end context &quot;when `AssertFileExists` is successful&quot; do end end end end   info You may be curious, why custom matchers? expect(result).to be_error.with_message(&quot;Path is empty&quot;) Instead of RSpec built-in alternatives? expect(result).to be_error? expect(result.message).to eq(&quot;Path is empty&quot;) Usage of the custom matchers helps avoid paying too much attention to unnecessary technical details when they are not so important. For example, it is common to forget that expect(result.message) raises an exception since message is accessed before the result status is checked. Moreover result.message is not a string, it is a string-like object, so even when the status is already checked, expect(result.message).to eq(&quot;Path is empty&quot;) will still not work.  The failure when the file does not exist may be checked as follows.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `AssertFileExists` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do... end context &quot;when `path` is empty&quot; do... end context &quot;when file with `path` does NOT exist&quot; do let(:path) { &quot;non_existing_path&quot; } it &quot;returns `failure`&quot; do expect(result).to be_failure.with_message(&quot;File with path `#{path}` does NOT exist&quot;) end end end context &quot;when `AssertFileExists` is successful&quot; do end end end end   info The be_failure matcher also has and_message, with_code, and and_code chainings.  And finally, the success case.  spec/services/assert_file_exists_spec.rb require &quot;spec_helper&quot; RSpec.describe AssertFileExists do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `AssertFileExists` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do... end context &quot;when `path` is empty&quot; do... end context &quot;when file with `path` does NOT exist&quot; do... end end context &quot;when `AssertFileExists` is successful&quot; do ## # NOTE: Tempfile uses its own `let` in order to prevent its premature garbage collection. # let(:tempfile) { Tempfile.new } let(:path) { tempfile.path } it &quot;returns `success`&quot; do expect(result).to be_success.without_data end end end end end   info The be_success matcher also has with_data chaining.  As you can see, there is nothing extraordinary in writing specs for the regular Convenient Service services.  Custom matchers like be_success.without_data, be_failure.with_message, be_error.with_code are intuitive.  The enclosing boilerplate blocks like example_group &quot;class methods&quot;, describe &quot;.result&quot;, context &quot;when `Service` is successful&quot; are straightforward.  So once you get familiar with them - reading or adding new service specs becomes a simple routine. ","version":"Next","tagName":"h2"},{"title":"How to skip internal library frames in the debugger session?","type":0,"sectionRef":"#","url":"/guides/debugging/how_to_skip_internal_library_frames_in_debugger_session","content":"How to skip internal library frames in the debugger session? First of all, let's visualize the problem using the minimal reproducible example. In order to do it we are going to create a new test file. touch test.rb Place a simple service into it. require &quot;convenient_service&quot; class Service include ConvenientService::Standard::Config step :foo step :bar step :baz def foo success end def bar success end def baz success end end result = Service.result if result.success? puts &quot;OK&quot; else puts result.message end And run it. ruby test.rb So far so good. Now, let's add a debugger statement to the first step. We are using ruby/debug in this example since it is the only debugger that supports skipping of frames at the moment when this article was initially written. require &quot;convenient_service&quot; require &quot;debug&quot; class Service include ConvenientService::Standard::Config step :foo step :bar step :baz def foo binding.break success end def bar success end def baz success end end result = Service.result if result.success? puts &quot;OK&quot; else puts result.message end When we rerun the test file the debugger pauses the execution. [9, 18] in test.rb 9| step :bar 10| 11| step :baz 12| 13| def foo =&gt; 14| binding.break 15| 16| success 17| end 18| =&gt;#0 Service#foo at test.rb:14 #1 [C] Method#call at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/can_be_method_step/can_be_executed/middleware.rb:40 # and 66 frames (use `bt' command for all frames) It is currently at the beginning of the foo step. Let's try to navigate to the bar step using only the next debugger command as we usually do when we are debugging regular classes and methods. (rdbg) next [11, 20] in test.rb 11| step :baz 12| 13| def foo 14| binding.break 15| =&gt; 16| success 17| end 18| 19| def bar 20| success =&gt;#0 Service#foo at test.rb:16 #1 [C] Method#call at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/can_be_method_step/can_be_executed/middleware.rb:40 # and 66 frames (use `bt' command for all frames) The first next &quot;moved the execution&quot; from line 14 to line 16. (rdbg) next [12, 21] in test.rb 12| 13| def foo 14| binding.break 15| 16| success =&gt; 17| end 18| 19| def bar 20| success 21| end =&gt;#0 Service#foo at test.rb:17 #=&gt; &lt;Service::Result status: :success&gt; #1 [C] Method#call at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/can_be_method_step/can_be_executed/middleware.rb:40 # and 66 frames (use `bt' command for all frames The second next shows the calculated return value. (rdbg) next [36, 45] in ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/can_be_method_step/can_be_executed/middleware.rb 36| return method.call(**input_values) if params.has_rest_kwargs? 37| 38| return method.call(**input_values.slice(*params.named_kwargs_keys)) if params.named_kwargs_keys.any? 39| 40| method.call =&gt; 41| end 42| 43| ## 44| # @return [Method, nil] 45| # =&gt;#0 ConvenientService::Service::Plugins::CanHaveSteps::Entities::Step::Plugins::CanBeMethodStep::CanBeExecuted::Middleware#call_method(method=#&lt;Method: Service#foo() test.rb:13&gt;) at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/can_be_method_step/can_be_executed/middleware.rb:41 #=&gt; &lt;Service::Result status: :success&gt; #1 ConvenientService::Service::Plugins::CanHaveSteps::Entities::Step::Plugins::CanBeMethodStep::CanBeExecuted::Middleware#next at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/can_be_method_step/can_be_executed/middleware.rb:24 # and 64 frames (use `bt' command for all frames) This is where the party is started. The third next stepped into the internal library code, which is good. It would do the same with any other library. (rdbg) next [54, 63] in ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/core/entities/config/entities/method_middlewares/entities/middlewares/chain/concern/instance_methods.rb 54| # https://ruby-doc.org/core-2.7.0/doc/keywords_rdoc.html 55| # 56| # TODO: Enforce to always pass args, kwargs, block. 57| # 58| __send__(:next, *@__env__[:args], **@__env__[:kwargs], &amp;@__env__[:block]) =&gt; 59| end 60| 61| ## 62| # @return [Class, Object] 63| # =&gt;#0 ConvenientService::Core::Entities::Config::Entities::MethodMiddlewares::Entities::Middlewares::Chain::Concern::InstanceMethods#call(env={:args=&gt;[], :kwargs=&gt;{}, :block=&gt;nil, :en...) at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/core/entities/config/entities/method_middlewares/entities/middlewares/chain/concern/instance_methods.rb:59 #=&gt; &lt;Service::Result status: :success&gt; #1 ConvenientService::Core::Entities::Config::Entities::MethodMiddlewares::Entities::Middlewares::Chain::Entities::MethodChain#next(args=[], kwargs={}, block=nil) at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/core/entities/config/entities/method_middlewares/entities/middlewares/chain/entities/method_chain.rb:47 # and 62 frames (use `bt' command for all frames) The fourth next stepped deeper. (rdbg) next [43, 52] in ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/core/entities/config/entities/method_middlewares/entities/middlewares/chain/entities/method_chain.rb 43| # @internal 44| # TODO: Enforce to always pass args, kwargs, block. 45| # 46| def next(*args, **kwargs, &amp;block) 47| stack.call(env.merge(args: args, kwargs: kwargs, block: block)) =&gt; 48| end 49| 50| ## 51| # @param other [ConvenientService::Core::Entities::Config::Entities::MethodMiddlewares::Entities::Chain, Object] 52| # @return [Boolean] =&gt;#0 ConvenientService::Core::Entities::Config::Entities::MethodMiddlewares::Entities::Middlewares::Chain::Entities::MethodChain#next(args=[], kwargs={}, block=nil) at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/core/entities/config/entities/method_middlewares/entities/middlewares/chain/entities/method_chain.rb:48 #=&gt; &lt;Service::Result status: :success&gt; #1 ConvenientService::Service::Plugins::CanHaveSteps::Entities::Step::Plugins::RaisesOnNotResultReturnValue::Middleware#next at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/raises_on_not_result_return_value/middleware.rb:19 # and 61 frames (use `bt' command for all frames) The fifth next continues the diving. (rdbg) next [16, 25] in ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/raises_on_not_result_return_value/middleware.rb 16| intended_for any_method, entity: :step 17| 18| def next(...) 19| original_result = chain.next(...) 20| =&gt; 21| return original_result if commands.is_result?(original_result) 22| 23| ::ConvenientService.raise Exceptions::ReturnValueNotKindOfResult.new(step: entity, result: original_result) 24| end 25| end =&gt;#0 ConvenientService::Service::Plugins::CanHaveSteps::Entities::Step::Plugins::RaisesOnNotResultReturnValue::Middleware#next at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/service/plugins/can_have_steps/entities/step/plugins/raises_on_not_result_return_value/middleware.rb:21 #1 ConvenientService::Core::Entities::Config::Entities::MethodMiddlewares::Entities::Middlewares::Chain::Concern::InstanceMethods#call(env={:args=&gt;[], :kwargs=&gt;{}, :block=&gt;nil, :en...) at ~/.asdf/installs/ruby/3.3.3/lib/ruby/gems/3.3.0/gems/convenient_service-0.19.1/lib/convenient_service/core/entities/config/entities/method_middlewares/entities/middlewares/chain/concern/instance_methods.rb:58 # and 60 frames (use `bt' command for all frames) We hope you already got the idea. Sometimes it can take more than 50 next repetitions to navigate from one step to another. That is happening since Convenient Service core is heavily using middleware chains under the hood. Any solution has its benefits and drawbacks. Middleware chains are simple to extend, but they may cause deep call stacks. Luckily, some debuggers like ruby/debug provide a way to skip call stack frames that match regular expressions. require &quot;convenient_service&quot; require &quot;debug&quot; require &quot;pathname&quot; (DEBUGGER__::CONFIG[:skip_path] ||= []).concat([ConvenientService.root.to_s, &quot;forwardable&quot;]) class Service include ConvenientService::Standard::Config step :foo step :bar step :baz def foo binding.break success end def bar success end def baz success end end result = Service.result if result.success? puts &quot;OK&quot; else puts result.message end When we retry the debugging session the first 2 next command outputs are the same as they were before. [12, 21] in test.rb 12| step :bar 13| 14| step :baz 15| 16| def foo =&gt; 17| binding.break 18| 19| success 20| end 21| =&gt;#0 Service#foo at test.rb:17 #67 &lt;main&gt; at test.rb:31 (rdbg) next [14, 23] in test.rb 14| step :baz 15| 16| def foo 17| binding.break 18| =&gt; 19| success 20| end 21| 22| def bar 23| success =&gt;#0 Service#foo at test.rb:19 #67 &lt;main&gt; at test.rb:31 (rdbg) next [15, 24] in test.rb 15| 16| def foo 17| binding.break 18| 19| success =&gt; 20| end 21| 22| def bar 23| success 24| end =&gt;#0 Service#foo at test.rb:20 #=&gt; &lt;Service::Result status: :success&gt; #67 &lt;main&gt; at test.rb:31 (rdbg) next [22, 31] in test.rb 22| def bar 23| success 24| end 25| 26| def baz =&gt; 27| success 28| end 29| end 30| 31| result = Service.result =&gt;#0 Service#baz at test.rb:27 #66 &lt;main&gt; at test.rb:31 The third next skips all block-listed internal call stack frames. (DEBUGGER__::CONFIG[:skip_path] ||= []).concat([ConvenientService.root.to_s, &quot;forwardable&quot;]) A big win, exactly what we need üí™. But why it immediately navigate to the baz, not the bar step üòê? That is something that is out of our control for now... Maybe an upgrade to the newer version of ruby/debug may resolve the issue soon ü•∫.","keywords":"","version":"Next"},{"title":"How to create and invoke services?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_create_and_invoke_services","content":"","keywords":"","version":"Next"},{"title":"How to create a service?‚Äã","type":1,"pageTitle":"How to create and invoke services?","url":"/guides/usage/how_to_create_and_invoke_services#how-to-create-a-service","content":" Create a class, include some Convenient Service configuration, define the result method üôÇ.  Here is the minimal example.  class Service include ConvenientService::Standard::Config def result success end end   ","version":"Next","tagName":"h2"},{"title":"How to invoke a service?‚Äã","type":1,"pageTitle":"How to create and invoke services?","url":"/guides/usage/how_to_create_and_invoke_services#how-to-invoke-a-service","content":" There a two ways to do it.  First one - using the class method result.  result = Service.result   Second one - using the instance method result.  service = Service.new result = service.result   info Most of the time you will utilize the class method variant (Service.result). But keep in my mind, that allocating a service instance may be useful when it is needed to delay result calculation. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/index","content":"","keywords":"","version":"Next"},{"title":"‚ùó‚ùó‚ùó WARNING ‚ùó‚ùó‚ùó‚Äã","type":1,"pageTitle":"Introduction","url":"/index#-warning-","content":" This library is under heavy development. Most of the public API is polished, but it still may be subject to change. It has already been successfully used in production environments for more than a year, but the first major version is planned for the second quarter of 2025. Use the current version at your own risk. Ruby 2.7+, JRuby 9.4+ (TruffleRuby support is planned as well). Thanks.  ","version":"Next","tagName":"h2"},{"title":"Quick Links‚Äã","type":1,"pageTitle":"Introduction","url":"/index#quick-links","content":" Check out TL;DR. Visit the All-in-One Presentation to get a quick overview. Read the API docs.    Copyright (c) 2022 - 2025 Marian Kostyk.   ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/installation","content":"","keywords":"","version":"Next"},{"title":"Bundler‚Äã","type":1,"pageTitle":"Installation","url":"/installation#bundler","content":" Add the following line to your Gemfile:  gem &quot;convenient_service&quot;, &quot;~&gt; 0.19.1&quot;   And then run:  bundle install   ","version":"Next","tagName":"h2"},{"title":"Without Bundler‚Äã","type":1,"pageTitle":"Installation","url":"/installation#without-bundler","content":" Execute the command below:  gem install convenient_service -v 0.19.1   info Convenient Service follows the Semantic Versioning standard. ","version":"Next","tagName":"h2"},{"title":"Requirements","type":0,"sectionRef":"#","url":"/requirements","content":"","keywords":"","version":"Next"},{"title":"Recommended‚Äã","type":1,"pageTitle":"Requirements","url":"/requirements#recommended","content":" Ruby 3+  ","version":"Next","tagName":"h2"},{"title":"Minimal‚Äã","type":1,"pageTitle":"Requirements","url":"/requirements#minimal","content":" Ruby 2.7  note Ruby 3+ provides some advanced features that are used internally to optimize performance. ","version":"Next","tagName":"h2"},{"title":"How to test a service with steps?","type":0,"sectionRef":"#","url":"/guides/testing/how_to_test_service_with_steps","content":"","keywords":"","version":"Next"},{"title":"How to test a service with steps using RSpec?‚Äã","type":1,"pageTitle":"How to test a service with steps?","url":"/guides/testing/how_to_test_service_with_steps#how-to-test-a-service-with-steps-using-rspec","content":" We are already aware of the service specs boilerplate, so we will just copy it from the previous guide.  require &quot;spec_helper&quot; RSpec.describe ReadFileContent do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do context &quot;when `ReadFileContent` is NOT successful&quot; do end context &quot;when `ReadFileContent` is successful&quot; do end end end end   The process of writing it examples for the method steps is very similar to what we do with regular services.  We also apply be_success, be_failure, be_error matchers and their chainings like with_data, and_data, with_message, and_message, with_code, and_code.  Let's add specs for the validate_path step.  require &quot;spec_helper&quot; RSpec.describe ReadFileContent do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `ReadFileContent` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do let(:path) { nil } it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;Path is `nil`&quot;).of_step(:validate_path) end end context &quot;when `path` is empty&quot; do let(:path) { &quot;&quot; } it &quot;returns `error` with `message`&quot; do expect(result).to be_error.with_message(&quot;Path is empty&quot;).of_step(:validate_path) end end end context &quot;when `ReadFileContent` is successful&quot; do end end end end   They look familiar but with one new addition - the of_step chaining.  It allows us to confirm that the returned result originates from the concrete step.  info Regular services does not have steps. To emphasize that in specs without_step chaining can be used. context &quot;when `AssertFileNotEmpty` is successful&quot; do # ... it &quot;returns `success`&quot; do expect(result).to be_success.without_data.without_step end end   In turn, the process of writing it examples for the service steps is different from what we do with regular services.  Why? Because we can rely on the fact the corresponding step service already has its own specs.  What does it give us in practice? We can change our focus.  Let's demonsrate it with the AssertFileExists step.  From the ReadFileContent point of view, it is redundant to verify every single possible result, data, message, and code variation for the AssertFileExists step.  The corresponding AssertFileExists service already has its dedicated and comprehensive specs that we developed in the previous article.  So it is not efficient to duplicate them in multiple places.  Instead, we need to pay attention to what is specific from the ReadFileContent perspective:  When the AssertFileExists service is NOT successful, then the flow is stopped. Otherwise, it is continued with the next step.  Let's reflect that behaviour in the specs.  require &quot;spec_helper&quot; RSpec.describe ReadFileContent do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `ReadFileContent` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do... end context &quot;when `path` is empty&quot; do... end context &quot;when `AssertFileExists` is NOT successful&quot; do let(:path) { &quot;not_existing_path&quot; } it &quot;returns intermediate step result&quot; do expect(result).to be_not_success.of_step(AssertFileExists) end end end context &quot;when `ReadFileContent` is successful&quot; do end end end end   As you can see, we just took a path that passes the verify_path step but makes the AssertFileExists step not succeed.  Also, we used the be_not_success matcher and of_step chaining to verify the returned result.  It is NOT actually important for the organizer if that result is a failure or error.  But it is essential for it to know whether to proceed with the flow.  info The be_not_failure and be_not_error matchers also exist, but they are used in very rare cases.  For the AssertFileNotEmpty service step the new spec is very similar.  require &quot;spec_helper&quot; RSpec.describe ReadFileContent do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `ReadFileContent` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do... end context &quot;when `path` is empty&quot; do... end context &quot;when `AssertFileExists` is NOT successful&quot; do... end context &quot;when `AssertFileNotEmpty` is NOT successful&quot; do let(:temfile) { Tempfile.new } let(:path) { temfile.path } it &quot;returns intermediate step result&quot; do expect(result).to be_not_success.of_step(AssertFileNotEmpty) end end end context &quot;when `ReadFileContent` is successful&quot; do end end end end   Input path is taken in a way to pass the validate_path and AssertFileExist steps, but to stop the flow in AssertFileNotEmpty step.  danger The idea of switching the focus and omitting duplicated specs only makes sense when the step-corresponding service is fully tested by its own specs. Otherwise, it becomes the organizer's responsibility to verify all its internal results. That violates the &quot;Tell, Don't Ask&quot; principle, making the organizer specs significantly harder to maintain.  And finally, the success case.  require &quot;spec_helper&quot; RSpec.describe ReadFileContent do include ConvenientService::RSpec::Matchers::Results example_group &quot;class methods&quot; do describe &quot;.result&quot; do let(:result) { described_class.result(path: path) } context &quot;when `ReadFileContent` is NOT successful&quot; do context &quot;when `path` is `nil`&quot; do... end context &quot;when `path` is empty&quot; do... end context &quot;when `AssertFileExists` is NOT successful&quot; do... end context &quot;when `AssertFileNotEmpty` is NOT successful&quot; do... end end context &quot;when `ReadFileContent` is successful&quot; do let(:temfile) { Tempfile.new.tap { |tempfile| tempfile.write(content) }.tap(&amp;:close) } let(:path) { temfile.path } let(:content) { &quot;some content&quot; } it &quot;returns `success` with content&quot; do expect(result).to be_success.with_data(content: content).of_step(:result) end end end end end   As a summary, once you learn of how to properly define and utilize the &quot;returns intermediate step result&quot; specs, the testing of services with steps becomes an ordinary &quot;boring&quot; day-to-day activity. ","version":"Next","tagName":"h2"},{"title":"How to use service results?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_use_results","content":"","keywords":"","version":"Next"},{"title":"Which result types/statuses are available?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#which-result-typesstatuses-are-available","content":" There are only 3 available statuses for service results.  The success status is when the service goal is resolved positively.  The failure status is when a service goal is resolved negatively.  The error status is when the service goal is not resolved. Additional moves are required to get a failure or success instead.  ","version":"Next","tagName":"h2"},{"title":"How to create success result?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-create-success-result","content":" Just call the success instance method and return it from result.  class Service include ConvenientService::Standard::Config def result success end end   ","version":"Next","tagName":"h2"},{"title":"How to pass data to success result?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-pass-data-to-success-result","content":" To be explicit, you may use the data keyword.  It accepts a hash with Symbol keys and any values.  Like in the service below.  class Service include ConvenientService::Standard::Config def result success(data: {foo: :bar, baz: :qux}) end end   But it is more common to omit it.  class Service include ConvenientService::Standard::Config def result success(foo: :bar, baz: :qux) end end   ","version":"Next","tagName":"h2"},{"title":"How to access success result data?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-access-success-result-data","content":" Utilize round brackes [] on the result data object.  result = Service.result if result.success? result.data[:foo] # =&gt; bar end   info A self-explanatory exception is raised when data is accessed before the status is checked. result = Service.result result.data[:foo] # =&gt; Raises exception since result status is NOT checked... That is by design. The intention is to encourage developers to think about fallbacks from the beginning. For example, to define reasonable else. if result.success? result.data[:foo] # =&gt; bar else # Fallback. end Or to check for failure and error as well. if result.success? result.data[:foo] # =&gt; bar elsif result.failure? # Some fallback. else # result.error? # Some other fallback. end   info A self-explanatory exception is raised when a missing data key is accessed. result = Service.result if result.success? result.data[:missing_key] # =&gt; Raises exception since data has NO value by `:missing_key` key... end That is also by design. The intention is to highligh typos during development, so that they are fixed earlier.  ","version":"Next","tagName":"h2"},{"title":"How to create failure or error results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-create-failure-or-error-results","content":" failures and errors have similar public interface.  That is why it makes sence to explain them together.  So in order to create a failure or error - invoke the corresponding instance method, pass a message to it, and return its value from result.  This is an example for failure.  class Service include ConvenientService::Standard::Config def result failure(message: &quot;Some business rule is NOT satisfied&quot;) end end   This is how to create error.  class Service include ConvenientService::Standard::Config def result error(message: &quot;Something forbided service goal to be resolved&quot;) end end   The message keyword can be omitted.  def result failure(&quot;Some business rule is NOT satisfied&quot;) end   def result error(&quot;Something forbided service goal to be resolved&quot;) end   ","version":"Next","tagName":"h2"},{"title":"How to access failure or error result message?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-access-failure-or-error-result-message","content":" Utilize the result message object.  result = Service.result if result.success? # ... elsif result.failure? result.message # =&gt; &quot;Some business rule is NOT satisfied&quot; else # result.error? result.message # =&gt; &quot;Something forbided service goal to be resolved&quot; end   info A self-explanatory exception is raised when message is accessed before the status is checked. result = Service.result result.message # =&gt; Raises exception since result status is NOT checked... The motivation is to discourage checks like if result.message.empty?.  ","version":"Next","tagName":"h2"},{"title":"How to check result status?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-check-result-status","content":" Check the comprehensive list of commands below.  To make them more demonstrative, let's introduce the following minimalistic services.  class SuccessService include ConvenientService::Standard::Config def result success end end   SuccessService always returns success.  class FailureService include ConvenientService::Standard::Config def result failure end end   FailureService always returns failure.  class ErrorServices include ConvenientService::Standard::Config def result error end end   ErrorServices always returns error.  Having that information status checkers work as follows:  SuccessService.result.success? # =&gt; true FailureService.result.success? # =&gt; false ErrorService.result.success? # =&gt; false   SuccessService.result.failure? # =&gt; false FailureService.result.failure? # =&gt; true ErrorService.result.failure? # =&gt; false   SuccessService.result.error? # =&gt; false FailureService.result.error? # =&gt; false ErrorService.result.error? # =&gt; true   Also not counterparts are available.  SuccessService.result.not_success? # =&gt; false FailureService.result.not_success? # =&gt; true ErrorService.result.not_success? # =&gt; true   SuccessService.result.not_failure? # =&gt; true FailureService.result.not_failure? # =&gt; false ErrorService.result.not_failure? # =&gt; true   SuccessService.result.not_error? # =&gt; true FailureService.result.not_error? # =&gt; true ErrorService.result.not_error? # =&gt; false   For people who like to save every keyboard stroke - a shorter equivalent is available for success.  It is just ok.  SuccessService.result.ok? # =&gt; true FailureService.result.ok? # =&gt; false ErrorService.result.ok? # =&gt; false   And the opposite for it.  SuccessService.result.not_ok? # =&gt; false FailureService.result.not_ok? # =&gt; true ErrorService.result.not_ok? # =&gt; true   ","version":"Next","tagName":"h2"},{"title":"How to check for specific failure or error?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-check-for-specific-failure-or-error","content":" No. You don't need to match regular expressions by yourself.  Something like result.message.to_s.match?(/Business Rule/) is NOT the way to go.  Please, consider the code keyword.  Here is a quick demonstration.  class Service include ConvenientService::Standard::Config attr_reader :number def initialize(number:) @number = number end def result return error(message: &quot;Message for `foo`&quot;, code: :foo) if number == 1 return error(message: &quot;Message for `bar`&quot;, code: :bar) if number == 2 return failure(message: &quot;Message for `baz`&quot;, code: :baz) if number == 3 return failure(message: &quot;Message for `qux`&quot;, code: :qux) if number == 4 success end end   Depending on the input number, the service above returns various failures and errors.  A shorter form is also available.  def result return error(&quot;Message for `foo`&quot;, :foo) if number == 1 return error(&quot;Message for `bar`&quot;, :bar) if number == 2 return failure(&quot;Message for `baz`&quot;, :baz) if number == 3 return failure(&quot;Message for `qux`&quot;, :qux) if number == 4 success end   This is how you can differentiate those failures and errors on the calling code.  result = Service.result(number: 4) if result.success? # ... elsif result.failure? if result.code.to_sym == :baz result.message # =&gt; &quot;Message for `baz`&quot; elsif result.code.to_sym == :qux result.message # =&gt; &quot;Message for `qux`&quot; else # ... end else # result.error? if result.code.to_sym == :foo result.message # =&gt; &quot;Message for `foo`&quot; elsif result.code.to_sym == :bar result.message # =&gt; &quot;Message for `bar`&quot; else # ... end end   Sure, this snippet is not the prettiest, but currently, there is NO alternative.  Optimization like the following (API is still subject to change) is planned for the subsequent Convenient Service releases.  result = Service.result(number: 4) result.respond_to do |status| status.success { } status.failure(code: :baz) { } status.failure(code: :qux) { } status.error(code: :foo) { } status.error(code: :bar) { } status.unexpected { } end   ","version":"Next","tagName":"h2"},{"title":"When to use success results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#when-to-use-success-results","content":" When you have a 100% guarantee that the service's desired outcome is achieved.  tip In other words, all business rules are satisfied and the service's actual operation is completed.  ","version":"Next","tagName":"h2"},{"title":"When to use failure results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#when-to-use-failure-results","content":" When you have a 100% guarantee that the service's desired outcome is NOT achieved.  tip In other words, some business rule is NOT satisfied.  ","version":"Next","tagName":"h2"},{"title":"When to use error results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#when-to-use-error-results","content":" When you don't have any guarantee that the service's desired outcome was even tried to be completely achieved.  tip In other words, some business rule check is NOT completed or the service's actual operation is NOT completed.  ","version":"Next","tagName":"h2"},{"title":"How to decide between success, failure, and error results?‚Äã","type":1,"pageTitle":"How to use service results?","url":"/guides/usage/how_to_use_results#how-to-decide-between-success-failure-and-error-results","content":" Let's consider the following service.  class AddRole include ConvenientService::Standard::Config attr_reader :user, :role_name def initialize(user:, role_name:) @user = user @role_name = role_name end def result return error(&quot;User is blank&quot;) if user.blank? return error(&quot;Role name is blank&quot;) if role_name.blank? return failure(&quot;User(#{user.id}) already has `#{role_name}` role&quot;) if user.has_role?(role_name) # Business rule. return failure(&quot;User(#{user.id}) reputation is too low for `#{role_name}` role&quot;) if user.reputation.low? &amp;&amp; role_name == :admin # Business rule. user.add_role(role_name) # Service actual operation. success rescue DB::ConnectionTimeout =&gt; exception error(&quot;DB connection is lost due to `#{exception.message}`&quot;) end end   As its name states, the AddRole service is responsible for the addition of a role to a particular user.  Thus successfully added role is its service goal.  AddRole can be easily invoked like so:  result = AddRole.result(user: User.find(1), role_name: :admin)   When the success result is returned, you are confident that the role is added.  result.success? # =&gt; true   When the failure result is returned, you are confident that the role is NOT added.  result.failure? # =&gt; true   As a significant bonus, you immediately receive the exact logical reason that clearly explains what forbade the role addition.  For this concrete service, it is the fact that the user already has the passed role.  result.message # =&gt; &quot;User(1) already has `admin` role&quot;   Or the fact that the user's reputation is too low for the admin role.  result.message # =&gt; &quot;User(1) reputation is too low for `admin` role&quot;   So you can quickly report that reason to the interested people without additional debugging sessions.  When the error result is returned, you obtain NO new information about the service goal.  result.error? # =&gt; true   As you had NO idea whether it was possible or impossible to add the role before running the service.  The same question remains open and unresolved after executing the service.  Strictly speaking, the error result notifies that the only way to get the reliable service goal outcome is to rerun the service with changed inputs or to retry later.  AddRole has multiple errors.  The first two of them are unsatisfied input validations.  result.message # =&gt; &quot;User is blank&quot;   result.message # =&gt; &quot;Role name is blank&quot;   Usually, they indicate that a developer (service user) who was invoking the service made a mistake by providing incorrect inputs.  That is why they should be changed before rerunning the service.  The last one is a database exception.  result.message # =&gt; &quot;DB connection is lost due to `Default timeout exceeded`&quot;   Such an error may show that the runtime infrastructure is not stable.  That is why retrying again later may be an option.  Similarly to failures, errors also have messages that clearly explain the reasons for what went wrong.  But, this time they are just hints about where to proceed with debugging, not the reliable facts about service goal resolution. ","version":"Next","tagName":"h2"},{"title":"My plugin is added to the config, but its middleware is never called","type":0,"sectionRef":"#","url":"/troubleshooting/added_config_but_middleware_never_called","content":"My plugin is added to the config, but its middleware is never called Some plugins are order-dependent. For example, CanHaveConnectedSteps has a middleware for the instance result method in the Standard config. middlewares :result do # ... use Plugins::Service::CanHaveConnectedSteps::Middleware # ... end If your plugin enhances the instance result method as well, you may be affected by CanHaveConnectedSteps. How? Let's check its source. module ConvenientService module Service module Plugins module CanHaveConnectedSteps class Middleware &lt; Core::MethodChainMiddleware def next(...) return chain.next(...) if entity.steps.none? # ... entity.steps.result end # ... end end end end end It works as a proxy middleware. When a service has no steps, CanHaveConnectedSteps just calls what is next in the middleware chain, by chain.next(...). Otherwise, it returns the last completed step result. Let's place, e.g. HasJSendResultParamsValidations::UsingActiveModelValidations plugin after CanHaveConnectedSteps in your application service config. module ApplicationService module Config include ConvenientService::Concern included do include ConvenientService::Standard::Config # ... middlewares :result do use ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware end end end end This way HasJSendResultParamsValidations::UsingActiveModelValidations is never called for services with steps. To fix that, locate it before CanHaveConnectedSteps like so: module ApplicationService module Config include ConvenientService::Concern included do |service_class| service_class.class_exec do include ConvenientService::Standard::Config # ... middlewares :result do insert_before \\ ConvenientService::Plugins::Service::CanHaveConnectedSteps::Middleware, ConvenientService::Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware end end end end end Apart from insert_before, insert_after, insert_after_each, insert_before_each, replace, and delete are also available.","keywords":"","version":"Next"},{"title":"`AmazingPrintInspect` does not colorize","type":0,"sectionRef":"#","url":"/troubleshooting/amazing_print_inspect_does_not_colorize","content":"`AmazingPrintInspect` does not colorize Consider a service that includes the AmazingPrintInspect configuration. Here is a minimal example. ConvenientService::Dependencies.require_amazing_print_inspect class Service include ::ConvenientService::Standard::Config include ::ConvenientService::AmazingPrintInspect::Config def result success(foo: :bar, baz: :qux) end end When it is called from the console like IRB. Service.result The result should be pretty-printed by amazing_print. But it actually outputs some &quot;weird escape characters&quot; ^[[0;37m, ^[[0m, or ^[[0;33m like in the screenshot below. After a deep diving into IRB source code, it was figured out that the issue may be caused by the upgrade of the Reline gem from Ruby std lib. To be more precise, the Reline::Unicode.escape_for_print method now has more escaping rules. One of them replaces 0x1B.ord to ^[. That is why the coloring becomes broken. There is one workaround to avoid the issue. Check the following monkey patch. class Reline::Unicode def self.escape_for_print(str) str end end Once it is applied, the output is colorized as expected. danger Currently, it is not known which exact problem was solved by the Reline developers by introducing additional escape rules. We are preparing to open a GitHub issue to ask. Consequently, although the suggested monkey patch looks safe, we can not estimate its possible negative effect. Use it at your own risk.","keywords":"","version":"Next"},{"title":"I18n.translate wrong number of arguments","type":0,"sectionRef":"#","url":"/troubleshooting/i18n_translate_wrong_number_of_arguments","content":"I18n.translate wrong number of arguments Failure/Error: @errors ||= entity.tap(&amp;:valid?).errors.messages.transform_values(&amp;:first) ArgumentError: wrong number of arguments (given 2, expected 0..1) # /usr/local/bundle/gems/i18n-1.12.0/lib/i18n.rb:210:in `translate' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/naming.rb:190:in `human' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/errors.rb:424:in `generate_message' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/errors.rb:454:in `normalize_message' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/errors.rb:298:in `add' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validations/presence.rb:7:in `validate_each' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validator.rb:152:in `block in validate' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validator.rb:149:in `each' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validator.rb:149:in `validate' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:426:in `block in make_lambda' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:198:in `block (2 levels) in halting' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:606:in `block (2 levels) in default_termi nator' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:605:in `catch' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:605:in `block in default_terminator' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:199:in `block in halting' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:513:in `block in invoke_before' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:513:in `each' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:513:in `invoke_before' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:131:in `run_callbacks' # /usr/local/bundle/gems/activesupport-5.2.8.1/lib/active_support/callbacks.rb:816:in `_run_validate_callbacks' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validations.rb:409:in `run_validations!' # /usr/local/bundle/gems/activemodel-5.2.8.1/lib/active_model/validations.rb:339:in `valid?' # ./lib/convenient_service/service/plugins/has_result_params_validations/using_active_model_validations/middleware.rb:28 :in `errors' # ./lib/convenient_service/service/plugins/has_result_params_validations/using_active_model_validations/middleware.rb:10 :in `next' This exception may happen when HasJSendResultParamsValidations::UsingActiveModelValidations plugin is used in an environemnt with Ruby 3+ and Rails 5. It is caused by separation of positional and keyword arguments in Ruby 3.0. Check correct Delegation with Ruby 2.6, 2.7 and 3.0 and I18n.translate for more details. Currenty, there is no a simple workaround for it. Actually, you may choose any of the following two options: Upgrade to Rails 6 or higher. Or remove HasJSendResultParamsValidations::UsingActiveModelValidations plugin from config (do not forget to remove validates calls as well). concerns do delete Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Concern end middlewares :result do delete Plugins::Service::HasJSendResultParamsValidations::UsingActiveModelValidations::Middleware end ","keywords":"","version":"Next"},{"title":"`AwesomePrintInspect` does not colorize","type":0,"sectionRef":"#","url":"/troubleshooting/awesome_print_inspect_does_not_colorize","content":"`AwesomePrintInspect` does not colorize Consider a service that includes the AwesomePrintInspect configuration. Here is a minimal example. ConvenientService::Dependencies.require_awesome_print_inspect class Service include ::ConvenientService::Standard::Config include ::ConvenientService::AwesomePrintInspect::Config def result success(foo: :bar, baz: :qux) end end When it is called from the console like IRB. Service.result The result should be pretty-printed by awesome_print. But it actually outputs some &quot;weird escape characters&quot; ^[[0;37m, ^[[0m, or ^[[0;33m like in the screenshot below. After a deep diving into IRB source code, it was figured out that the issue may be caused by the upgrade of the Reline gem from Ruby std lib. To be more precise, the Reline::Unicode.escape_for_print method now has more escaping rules. One of them replaces 0x1B.ord to ^[. That is why the coloring becomes broken. There is one workaround to avoid the issue. Check the following monkey patch. class Reline::Unicode def self.escape_for_print(str) str end end Once it is applied, the output is colorized as expected. danger Currently, it is not known which exact problem was solved by the Reline developers by introducing additional escape rules. We are preparing to open a GitHub issue to ask. Consequently, although the suggested monkey patch looks safe, we can not estimate its possible negative effect. Use it at your own risk.","keywords":"","version":"Next"},{"title":"TL;DR","type":0,"sectionRef":"#","url":"/tldr","content":"","keywords":"","version":"Next"},{"title":"More examples‚Äã","type":1,"pageTitle":"TL;DR","url":"/tldr#more-examples","content":" Source Code\tRSpec Specslib/convenient_service/examples\tspec/lib/convenient_service ","version":"Next","tagName":"h2"},{"title":"How to use service steps?","type":0,"sectionRef":"#","url":"/guides/usage/how_to_use_steps","content":"","keywords":"","version":"Next"},{"title":"Which types of steps are available?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#which-types-of-steps-are-available","content":" The two criteria currently categorize steps.  By action: service and method steps. By control flow: and, or, not steps.  ","version":"Next","tagName":"h2"},{"title":"How to define a service step?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-define-a-service-step","content":" You can register existing services as steps of other services using the step directive.  Let's have a look at it in practice.  Having the Service service.  class Service include ConvenientService::Standard::Config def result success end end   We can use it as a step of the OtherService service in the following way.  class OtherService include ConvenientService::Standard::Config step Service end   This code works almost the same as:  class OtherService include ConvenientService::Standard::Config def result Service.result end end   That is why for a single-step service the usage of steps may not seem very beneficial.  So consider a more complex example.  Now we have 3 services.  class FooService include ConvenientService::Standard::Config def result success end end   class BarService include ConvenientService::Standard::Config def result success end end   class BazService include ConvenientService::Standard::Config def result success end end   The HostService uses them as steps.  class HostService include ConvenientService::Standard::Config step FooService step BarService step BazService end   Rough HostService equivalent without steps may be implemented as follows:  class HostService include ConvenientService::Standard::Config def result foo_result = FooService.result return foo_result unless foo_result.success? bar_result = BarService.result return bar_result unless bar_result.success? BazService.result end end   As you can see, steps allow us to eliminate at least 2 assignments and 2 if-conditionals for this particular example.  Sure, those assignments and if-conditionals are still performed under the hood, but it is no longer a developer's responsibility to manage them.  Now the benefit of steps becomes more obvious, but that is not the only benefit.  Other guides are going to demonstrate the additional simplifications.  ","version":"Next","tagName":"h2"},{"title":"How to define a method step?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-define-a-method-step","content":" Any method can be a step.  The only requirement is that it must return a result.  For example:  class Service include ConvenientService::Standard::Config step :foo def foo success end end   ","version":"Next","tagName":"h2"},{"title":"What is the result of a service with steps?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#what-is-the-result-of-a-service-with-steps","content":" Consider the following service.  class Service include ConvenientService::Standard::Config step :foo step :bar step :baz def foo success end def bar success end def baz success end end   When all steps are successful, the overall service result is the last step result.  result = Service.result # =&gt; &lt;Service::Result status: :success&gt;   result.step # =&gt; &lt;Service::Step method: :baz&gt;   Let's check some other service.  class OtherService include ConvenientService::Standard::Config step :foo step :bar step :baz def foo success end def bar failure(&quot;Message from `bar`&quot;) # `error(&quot;Message from `bar`&quot;)` also stops the sequence. end def baz raise &quot;Not raised exception&quot; success end end   When any step is NOT successful, the overall service result is that NOT successful step result.  result = OtherService.result # =&gt; &lt;OtherService::Result status: :failure&gt;   result.step # =&gt; &lt;OtherService::Step method: :bar&gt;   It is important to note that the remaining steps are NOT even evaluated.  That is why the exception from baz was not raised.  ","version":"Next","tagName":"h2"},{"title":"What is an organizer?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#what-is-an-organizer","content":" Organizer is a service with steps.  It is also worth mentioning that services without steps are often referred to as regular services.  ","version":"Next","tagName":"h2"},{"title":"How to pass arguments to steps?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-pass-arguments-to-steps","content":" Use the in option of the step directive.  Here is a quick example.  The NestedService accepts two keyword arguments - :first_kwarg, and :second_kwarg.  class NestedService include ConvenientService::Standard::Config attr_reader :first_kwarg, :second_kwarg def initialize(:first_kwarg, :second_kwarg) @first_kwarg = first_kwarg @second_kwarg = second_kwarg end def result puts &quot;first_kwarg: `#{first_kwarg}`&quot; puts &quot;second_kwarg: `#{second_kwarg}`&quot; success end end   This is how the in option is utilized in order to pass them as step inputs.  class Service include ConvenientService::Standard::Config step NestedService, in: [:first_kwarg, :second_kwarg] def first_kwarg :foo end def second_kwarg :bar end end   As you can see below, the corresponding methods' return values are passed as :first_kwarg and :second_kwarg to the NestedService step when we call the organizer.  For this particular case, it is :foo and :bar respectively.  result = Service.result # &quot;first_kwarg: `:foo`&quot; # &quot;second_kwarg: `:bar`&quot; # =&gt; &lt;Service::Result status: :success&gt;   In order to simplify the understanding of the step inputs, let's have a closer look at this specific line.  step NestedService, in: [:first_kwarg, :second_kwarg]   Whenever you have trouble with its meaning, please, remember that it can be mentally translated like so:  def first_step_result @first_step_result ||= NestedService.result( first_kwarg: first_kwarg, second_kwarg: second_kwarg ) end   That is why it is important to have corresponding instance methods defined for step inputs in the organizer class.  More examples of the in option usage may be found in the so-called translation table.  ","version":"Next","tagName":"h2"},{"title":"How to access step result data?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-access-step-result-data","content":" Use the out option of the step directive.  Here is a short example.  The NestedService returns a success with data that has two keys - :first_data_key, and :second_data_key.  class NestedService include ConvenientService::Standard::Config def result success(first_data_key: :baz, second_data_key: :qux) end end   This is how the out option is utilized in order to access them as step outputs.  class Service include ConvenientService::Standard::Config step NestedService, out: [:first_data_key, :second_data_key] step :result def result puts &quot;first_data_key: `#{first_data_key}`&quot; puts &quot;second_data_key: `#{second_data_key}`&quot; success end end   Step result data values become available via the first_data_key and second_data_key instance methods.  For this particular case, they return :baz and :qux, the same values that were passed to the original success in the NestedService service.  result = Service.result # &quot;first_data_key: `:baz`&quot; # &quot;second_data_key: `:qux`&quot; # =&gt; &lt;Service::Result status: :success&gt;   In order to simplify the understanding of the step outputs, let's have a closer look at this specific line.  step NestedService, out: [:first_data_key, :second_data_key]   Whenever you have trouble with its meaning, please, remember that it can be mentally translated like so:  def first_step_result @first_step_result ||= NestedService.result end def first_data_key first_step_result.data[:first_data_key] end def second_data_key first_step_result.data[:second_data_key] end   Having this information, avoid defining instance methods with the same names as step outputs in the organizer class.  Otherwise, your methods will be silently overridden.  More examples of the out option usage may be found in the so-called translation table.  ","version":"Next","tagName":"h2"},{"title":"How to create a step input alias?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-create-a-step-input-alias","content":" There are cases when the organizer service does not have the corresponding method defined with the same name as a step input.  Or that method is already reserved for some other purpose and can not be reused.  Consider the example, when the RemoveNilElements service expects the elements keyword argument as its input.  class RemoveNilElements include ConvenientService::Standard::Config attr_reader :elements def initialize(elements:) @elements = elements end def result success(filtered_elements: elements.compact) end end   The PrepareCollection service tries to register RemoveNilElements as its step.  class PrepareCollection include ConvenientService::Standard::Config step RemoveNilElements, in: [:elements] def collection [42, nil, &quot;foo&quot;] end end   Since it does not have the elements method defined, the usual in: [:elements] declaration won't work.  But it has the collection method instead.  In order to utilize its return value as the :elements input, the PrepareCollection should be updated as follows.  class PrepareCollection include ConvenientService::Standard::Config step RemoveNilElements, in: [{elements: :collection}] def collection [42, nil, &quot;foo&quot;] end end   Now, the in option contains a hash {elements: :collection} that can be read as &quot;Pass elements to step as collection&quot;.  tip As a rule of thumb, try to memorize that the alias is always on the right side of the hash üòé.  Traditionally, to simplify the understanding of the steps-related stuff, input aliases this time, let's have a closer look at the step directive again.  step RemoveNilElements, in: [{elements: :collection}]   Whenever you have trouble with its meaning, please, remember that it can be mentally translated like so:  def first_step_result @first_step_result ||= RemoveNilElements.result(elements: collection) end   As you can see, creating an input alias is just passing a different method return value to the underlying service.  More examples of the in option aliases usage may be found in the so-called translation table.  ","version":"Next","tagName":"h2"},{"title":"How to create a step output alias?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-create-a-step-output-alias","content":" There are cases when the organizer service already has the corresponding method defined with the same name as a step output.  That method is probably reserved for some other purpose so it is not supposed to be redefined.  Consider the example, when the RemoveNilElements service returns the filtered_elements key as its output.  class RemoveNilElements include ConvenientService::Standard::Config attr_reader :elements def initialize(elements:) @elements = elements end def result success(filtered_elements: elements.compact) end end   The PrepareCollection service tries to register RemoveNilElements as its step.  class PrepareCollection include ConvenientService::Standard::Config step RemoveNilElements, in: [:elements], out: [:filtered_elements] def elements [42, nil, &quot;foo&quot;] end def filtered_elements elements - [&quot;foo&quot;] end end   Since it already has the filtered_elements method defined, the usual out: [:filtered_elements] declaration overrides its return value.  Whenever you call filtered_elements before the RemoveNilElements step is executed, it returns [42, nil] (raises an exception for versions lower than v0.20).  But when you invoke it after the RemoveNilElements step is run, it returns [42, &quot;foo&quot;].  Sometimes such behavior is expected, but typically we don't want to lose access to the original filtered_elements implementation.  That is why there is an ability to define output aliases.  Let's utilize one in the PrepareCollection service.  class PrepareCollection include ConvenientService::Standard::Config step RemoveNilElements, in: [:elements], out: [{:filtered_elements: :filtered_collection}] def elements [42, nil, &quot;foo&quot;] end def filtered_elements elements - [&quot;foo&quot;] end end   The out option contains a hash {:filtered_elements: :filtered_collection} that can be read as &quot;Retrieve filtered_elements from step as filtered_collection&quot;.  Now, the additional filtered_collection method is defined that is fully independent of filtered_elements.  tip As a rule of thumb, try to memorize that the alias is always on the right side of the hash üòé.  As always, to simplify the understanding of the steps-related stuff, output aliases this time, let's have a closer look at the step directive.  step RemoveNilElements, in: [:elements], out: [{:filtered_elements: :filtered_collection}]   Whenever you have trouble with its meaning, please, remember that it can be mentally translated like so:  def first_step_result @first_step_result ||= RemoveNilElements.result(elements: elements) end def filtered_collection @filtered_collection ||= first_step_result.data[:filtered_elements] end   As you can see, creating an output alias is just retrieving a different key value from the underlying step result.  More examples of the out option aliases usage may be found in the so-called translation table.  ","version":"Next","tagName":"h2"},{"title":"How to pass a dynamic value as a step input?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#how-to-pass-a-dynamic-value-as-a-step-input","content":" Let's consider the following service.  class Service # ... step EscapeRegexp, in: [:pattern] out: [:escaped] # ... end   We need to pass either ENV[&quot;PATH_PATTERN&quot;] or ENV[&quot;PATH_GLOB&quot;] to the EscapeRegexp step as the pattern argument.  As you may already guessed that is achievable by defining a corresponding instance method.  class Service # ... step EscapeRegexp, in: [:pattern] out: [:escaped] # ... def pattern ENV[&quot;PATH_PATTERN&quot;] || ENV[&quot;PATH_GLOB&quot;] end end   This is what you would usually do most of the time.  When the pattern method is reserved for some other purpose in your organizer service, there is always a possibility of using an alias.  class Service # ... step EscapeRegexp, in: [{pattern: :template}] out: [:escaped] # ... def template ENV[&quot;PATH_PATTERN&quot;] || ENV[&quot;PATH_GLOB&quot;] end end   In this example the template method return value is passed as the pattern argument.  But sometimes it may feel redundant or unnatural to define a dedicated method for such a simple task.  That is why there are two additional ways to dynamically pass a value as a step input:  Using a raw step input argument. Using a proc step input argument.  ","version":"Next","tagName":"h2"},{"title":"What is a raw step input argument?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#what-is-a-raw-step-input-argument","content":" Here is a quick example.  step EscapeRegexp, in: [{pattern: raw(ENV[&quot;PATH_PATTERN&quot;] || ENV[&quot;PATH_GLOB&quot;]) }], out: [:escaped]   This is how the step call is &quot;translated&quot; to regular service invocation under the hood:  def step_result @step_result ||= EscapeRegexp.result(pattern: ENV[&quot;PATH_PATTERN&quot;] || ENV[&quot;PATH_GLOB&quot;]) end   Since raw is just a class method you can pass to it anything from the enclosing class scope.  The value is forwarded without any intermediate processing.  step EscapeRegexp, in: [{pattern: raw(any_class_method)}], out: [:escaped]   ","version":"Next","tagName":"h2"},{"title":"What is a proc step input argument?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#what-is-a-proc-step-input-argument","content":" Here is a quick example.  step EscapeRegexp, in: [{pattern: -&gt; { ENV[&quot;PATH_PATTERN&quot;] || ENV[&quot;PATH_GLOB&quot;] }}], out: [:escaped]   Similarly to raw, the proc form also does not additionally process the passed value, but it is evaluated in the instance scope instead of the class scope.  So you can access any service instance methods in it.  step EscapeRegexp, in: [{pattern: -&gt; { any_instance_method }}], out: [:escaped]   ","version":"Next","tagName":"h2"},{"title":"What is a not_step?‚Äã","type":1,"pageTitle":"How to use service steps?","url":"/guides/usage/how_to_use_steps#what-is-a-not_step","content":" Once your codebase starts to grow, you will notice that it contains a lot of so-called boolean services.  The following list demonstrates some common names.  IsAdmin. HasAccessRights ShouldGrantPermission. AssertPolicySatisfied. EnsureEligibleForRemoval. ConfirmRuleApplied. WasPreviouslyChecked. And so on...  Usually, such services are utilized as the precondition steps in organizers.  class PlayAudio include ConvenientService::Standard::Config # ... step AssertFormatSupported, in: :audio step EnsureDriverUpgraded, in: :format step ConfirmMaxSizeNotExceeded, in: :size # ... step :result def result # ... end end   After a while it is just a matter of time when some of those preconditions are required to be used in some other contexts, but in the negated form.  In other words, negative counterparts are created.  IsAdmin -&gt; IsNotAdmin. HasAccessRights -&gt; DoesNotHaveAccessRights. ShouldGrantPermission -&gt; ShouldNotGrantPermission. AssertPolicySatisfied -&gt; RefutePolicySatisfied. EnsureEligibleForRemoval -&gt; EnsureNotEligibleForRemoval. ConfirmRuleApplied -&gt; DenyRuleApplied. WasPreviouslyChecked -&gt; WasNotPreviouslyChecked. And so on...  A majority of the time those services have very similar implementations.  The only difference is that success and failure results are switched.  For example, consider the AssertFormatSupported service.  class AssertFormatSupported include ConvenientService::Standard::Config attr_reader :audio def initialize(audio:) @audio = audio end def result return error(&quot;Audio is nil&quot;) if audio.nil? if !supported_formats.include?(audio.format) return failure(&quot;Audio `#{audio.name}` format `#{audio.format}` is NOT supported&quot;) end success end end   Its opposite service RefuteFormatSupported has a slighlty distinctive definition.  class RefuteFormatSupported include ConvenientService::Standard::Config attr_reader :audio def initialize(audio:) @audio = audio end def result return error(&quot;Audio is nil&quot;) if audio.nil? if supported_formats.include?(audio.format) return failure(&quot;Audio `#{audio.name}` format `#{audio.format}` is supported&quot;) end success end end   If you look precisely, only ! and NOT are removed compared to the original AssertFormatSupported service.  As a consequence, it may seem not logical to maintain two almost identical solutions.  That is why the not_step directive is available.  It works similarly to the regular step directive.  It also has in and out options, supports alias, raw, and proc input arguments, etc, but it calls the negated_result under the hood.  Having that said, a not_step usage like in the following snippet:  class Service include ConvenientService::Standard::Config not_step AssertFormatSupported, in: :audio # ... end   Can be mentally translated to:  def first_step_result @first_step_result ||= AssertFormatSupported.negated_result(audio: audio) end   When the original result returns success, the negated_result returns failure.  When the original result returns failure, the negated_result returns success.  The error is always an error, so both the original result and negated_result return the same status.  Thus, the not_step directive (and negated_result) eliminates the need to maintain the opposite services when negated implementations are almost identical to the original. ","version":"Next","tagName":"h2"}],"options":{"languages":["en"],"id":"default"}}