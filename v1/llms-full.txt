# Installation

import { version } from '../../custom/constants';
import { CodeBlock } from '../../custom/components/codeBlock';

There are multiple installation methods. Pick the one that best fits your needs.

## Bundler

Add the following line to your Gemfile:

<CodeBlock lang="ruby" code={`gem "convenient_service", "~> ${version}"`} />

And then run:

```bash
bundle install
```

## Without Bundler

Execute the command below:

<CodeBlock lang="bash" code={`gem install convenient_service -v ${version}`} />

<Callout>
  Convenient Service follows the [Semantic Versioning](https://semver.org/) standard.
</Callout>


# Requirements

import { Callout } from 'fumadocs-ui/components/callout';

Convenient Service has exactly the same public API and behavior for all supported Ruby versions.

## Recommended

* [Ruby 3.0 or higher](https://ruby-lang.org/en/documentation/installation/#asdf-vm).

## Minimal

* [Ruby 2.7](https://ruby-lang.org/en/documentation/installation/#asdf-vm).

<Callout>
  Ruby 3+ provides some [advanced features](https://rubyreferences.github.io/rubychanges/3.0.html) that are used internally to optimize performance.
</Callout>


# TL;DR

> I have no time to read tons of docs. <br />
> Just show me an example use case and I'll quickly craft something similar ðŸ˜Ž.
>
> â€” A lazy and productive developer.

```ruby
# Any source code in the project.
def read_file_content(path)
  result = ReadFileContent.result(path: path)

  if result.success?
    ##
    # Service tried to read the file content and completed it.
    #
    result.data[:content] # File content.
  elsif result.failure?
    ##
    # Service tried to read file content, but did NOT complete it due to some expected reason.
    #
    App.logger.warn { result.message.to_s }

    "" # Fallback value or any other reasonable fallback behavior.
  else # result.error?
    ##
    # Service NOT even tried to complete reading of file content due to validation issue or exception.
    #
    App.logger.error { result.message.to_s }

    raise VerboseException, result.message.to_s # Self-explanatory exception or any other reasonable exception handling behavior.
  end
end
```

```ruby
gem "convenient_service", "1.0.0"
```

<Tabs groupId="config" items={["Standard", "Rails", "Dry", "Custom"]}>
  <Tab value="Standard" default>
    ```ruby
    require "convenient_service"
    ```
  </Tab>

  <Tab value="Rails">
    ```ruby
    require "active_model" # NOTE: Minimal `active_model` version - `5.2.0`.

    require "convenient_service"

    require "convenient_service/extras/standard/config/options/active_model_attribute_assignment"
    require "convenient_service/extras/standard/config/options/active_model_attributes"
    require "convenient_service/extras/standard/config/options/active_model_validations"
    ```
  </Tab>

  <Tab value="Dry">
    ```ruby
    require "dry-initializer" # NOTE: Minimal `dry-initializer` version - `3.0.0`.
    require "dry-validation" # NOTE: Minimal `dry-validation` version - `1.5.0`.

    require "convenient_service"

    require "convenient_service/extras/standard/config/options/dry_initializer"
    require "convenient_service/extras/standard/config/options/dry_validation"
    ```
  </Tab>

  <Tab value="Custom">
    ```ruby
    require "active_model" # NOTE: Minimal `active_model` version - `5.2.0`.
    require "dry-initializer" # NOTE: Minimal `dry-initializer` version - `3.0.0`.
    require "awesome_print" # NOTE: Minimal `awesome_print` version - `1.0.0`.

    require "convenient_service"

    require "convenient_service/extras/standard/config/options/active_model_validations"
    require "convenient_service/extras/standard/config/options/dry_initializer"
    require "convenient_service/extras/standard/config/options/awesome_print_inspect" if Rails.env.development? || Rails.env.test?
    ```
  </Tab>
</Tabs>

<Tabs groupId="config" items={["Standard", "Rails", "Dry", "Custom"]}>
  <Tab value="Standard" default>
    ```ruby
    module ApplicationService
      module Config
        include ConvenientService::Config

        included do
          include ConvenientService::Standard::Config
        end
      end
    end
    ```
  </Tab>

  <Tab value="Rails">
    ```ruby
    module RailsService
      module Config
        include ConvenientService::Config

        included do
          include ConvenientService::Standard::Config
            .with(
              :active_model_attribute_assignment,
              :active_model_attributes,
              :active_model_attributes
            )
        end
      end
    end
    ```
  </Tab>

  <Tab value="Dry">
    ```ruby
    module DryService
      module Config
        include ConvenientService::Concern

        included do
          include ConvenientService::Standard::Config
            .with(
              :using_dry_initializer,
              :using_dry_validation
            )
        end
      end
    end
    ```
  </Tab>

  <Tab value="Custom">
    ```ruby
    module CustomService
      module Config
        include ConvenientService::Config

        included do
          include ConvenientService::Standard::Config
            .with(
              :using_dry_initializer,
              :using_active_model_validations
              awesome_print_inspect: Rails.env.local?
            )
            .without(
              fault_tolerance: Rails.env.test?
            )
        end
      end
    end
    ```
  </Tab>
</Tabs>

<Tabs groupId="config" items={["Standard", "Rails", "Dry", "Custom"]}>
  <Tab value="Standard" default>
    ```ruby
    class AssertFileExists
      include ApplicationService::Config

      attr_reader :path

      def initialize(path:)
        @path = path
      end

      def result
        return error("Path is `nil`") if path.nil?
        return error("Path is empty") if path.empty?

        return failure("File does not exist at path `#{path}`") unless File.exist?(path)

        success
      end
    end
    ```
  </Tab>

  <Tab value="Rails">
    ```ruby
    class AssertFileExists
      include RailsService::Config

      attribute :path, :string

      validates :path, presence: true

      def result
        return failure("File does not exist at path `#{path}`") unless File.exist?(path)

        success
      end
    end
    ```
  </Tab>

  <Tab value="Dry">
    ```ruby
    class AssertFileExists
      include DryService::Config

      option :path

      contract do
        schema do
          required(:path).value(:string)
        end
      end

      def result
        return failure("File does not exist at path `#{path}`") unless File.exist?(path)

        success
      end
    end
    ```
  </Tab>

  <Tab value="Custom">
    ```ruby
    class AssertFileExists
      include CustomService::Config

      option :path

      validates :path, presence: true

      def result
        return failure("File does not exist at path `#{path}`") unless File.exist?(path)

        success
      end
    end
    ```
  </Tab>
</Tabs>

```ruby
result = AssertFileExists.result(path: "Gemfile")
```

<Tabs groupId="config" items={["Standard", "Rails", "Dry", "Custom"]}>
  <Tab value="Standard" default>
    ```ruby
    class AssertFileNotEmpty
      include ApplicationService::Config

      attr_accessor :path

      def initialize(path:)
        @path = path
      end

      def result
        return error("Path is `nil`") if path.nil?
        return error("Path is empty") if path.empty?

        return failure("File is empty at path `#{path}`") if File.zero?(path)

        success
      end
    end
    ```
  </Tab>

  <Tab value="Rails">
    ```ruby
    class AssertFileNotEmpty
      include RailsService::Config

      attribute :path, :string

      validates :path, presence: true

      def result
        return failure("File is empty at path `#{path}`") if File.zero?(path)

        success
      end
    end
    ```
  </Tab>

  <Tab value="Dry">
    ```ruby
    class AssertFileNotEmpty
      include DryService::Config

      option :path

      contract do
        schema do
          required(:path).value(:string)
        end
      end

      def result
        return failure("File is empty at path `#{path}`") if File.zero?(path)

        success
      end
    end
    ```
  </Tab>

  <Tab value="Custom">
    ```ruby
    class AssertFileNotEmpty
      include CustomService::Config

      option :path

      validates :path, presence: true

      def result
        return failure("File is empty at path `#{path}`") if File.zero?(path)

        success
      end
    end
    ```
  </Tab>
</Tabs>

```ruby
result = AssertFileNotEmpty.result(path: "Gemfile")
```

<Tabs groupId="config" items={["Standard", "Rails", "Dry", "Custom"]}>
  <Tab value="Standard" default>
    ```ruby
    class ReadFileContent
      include ApplicationService::Config

      attr_reader :path

      step :validate_path
      step AssertFileExists, in: :path
      step AssertFileNotEmpty, in: :path
      step :result, in: :path, out: :content

      def initialize(path:)
        @path = path
      end

      def result
        success(content: File.read(path))
      end

      private

      def validate_path
        return error("Path is `nil`") if path.nil?
        return error("Path is empty") if path.empty?

        success
      end
    end
    ```
  </Tab>

  <Tab value="Rails">
    ```ruby
    class ReadFileContent
      include RailsService::Config

      attribute :path, :string

      validates :path, presence: true

      step AssertFileExists, in: :path
      step AssertFileNotEmpty, in: :path
      step :result, in: :path, out: :content

      def result
        success(content: File.read(path))
      end
    end
    ```
  </Tab>

  <Tab value="Dry">
    ```ruby
    class ReadFileContent
      include DryService::Config

      option :path

      contract do
        schema do
          required(:path).value(:string)
        end
      end

      step AssertFileExists, in: :path
      step AssertFileNotEmpty, in: :path
      step :result, in: :path, out: :content

      def result
        success(content: File.read(path))
      end
    end
    ```
  </Tab>

  <Tab value="Custom">
    ```ruby
    class ReadFileContent
      include CustomService::Config

      option :path

      validates :path, presence: true

      step AssertFileExists, in: :path
      step AssertFileNotEmpty, in: :path
      step :result, in: :path, out: :content

      def result
        success(content: File.read(path))
      end
    end
    ```
  </Tab>
</Tabs>

```ruby
result = ReadFileContent.result(path: "Gemfile")
```

See more [examples](https://github.com/marian13/convenient_service/tree/main/lib/convenient_service/examples) with [specs](https://github.com/marian13/convenient_service/tree/main/spec/lib/convenient_service/examples) in the Convenient Service [repo](https://github.com/marian13/convenient_service).


# Errors

Now, it is time to describe each result type in more detail. Let's start with *errors*.

## What is an error?

*Error* is a result type caused either by the wrong input data (*validation error*) or by the exceptional behaviour (*exception error*).

In some cases, it may be a validation rule violation, unsatisfied [assertion](https://wiki.c2.com/?ReplaceCommentWithAssertion), or unmet precondition based on the service arguments.

It is a responsibility of a developer/service user to provide correct inputs.

Otherwise, there is no sense in even starting any service processing.

Also errors are often semantically close to the [exceptions](https://ruby-doc.org/core-2.7.0/Exception.html).

In other words, service errors are frequently located at the same places where [exceptions](https://ruby-doc.org/core-2.7.0/Exception.html) are [raised/rescued](https://ruby-doc.com/docs/ProgrammingRuby/html/tut_exceptions.html) in the reqular methods.

<Callout>
  Exceptional behaviour like HTTP connection issues, database inconsistencies, timeouts, etc are also errors.
</Callout>

Check out the following example:

```ruby
class EnsureFeatureActive
  # ...
  def initialize(name:)
    @name = name
  end

  def result
    return error("Feature name can NOT be `nil`") if name.nil?
    return error("Unknown feature `#{name}`") unless Feature.exist?(name: name)

    # ... Tricky and non trivial logic to ensure that feature is active...
  rescue Feature::Exceptions::ConnectionTimeout => exception
    return error("Feature `#{name}` connection timeout due to `#{exception.message}`")
  end
end
```

And this is how it can be triggerred:

```ruby
result = EnsureFeatureActive.result(name: "Fancy feature")

if result.error?
  # `result.message` is a string-like object with error reason.
  result.message
end
```

There is no point to involve all the heavy machinery when the feature name is `nil`.

Why do we need to waste any expensive resources if the feature name is unknown?

Can we guarantee whether the feature is actually active when a connection timeout happens?

So, the one of the purposes of the error result is to say that the callers need to make adjustments in their code/config/dependency, not the service authors.


# Failures

import { docsLinkUrlWithPrefix } from '../../../custom/links'

Having an overview of errors, let's discuss the meaning of failures.

## What is a failure?

Errors prevent the achievement of the service goal due to unsatisfied validations or exceptions.

At the same time, *failures* prevent the achievement of the service goal due to business reasons.

That is why is so vital to use meaningful names for services.

For instance, when the aim is <u>to order a bus ticket</u>, call it - `OrderBusTicket`.

So when the service is invoked, but the ticket is not ordered for some logical business reason, it should be treated as a failure.

Why?

Business reason is not an error, since the input is valid, the environment is stable, but the service goal is still not achieved.

Please, read the following code snippet carefully to get the idea.

```ruby
class OrderBusTicket
  # ...
  def result
    return error("Bus is nil") if bus.nil?
    return error("Bus `#{bus.number}` is NOT valid") unless bus.has_valid_number?

    return failure("Bus has no available seats") if bus.full?
    return failure("Bus trip is postponed") if Trip.for_bus(bus).postponed?

    ticket = BusTerminal.issue_ticket(bus)

    success(ticket: ticket)
  rescue => exception
    error("Ticket order for bus `#{name}` is not completed due to `#{exception.message}`")
  end
end
```

And this is how it can be triggerred:

```ruby
result = OrderBusTicket.result(bus: bus)

if result.failure?
  # `result.message` is a string-like object with failure reason.
  result.message
end
```

When the bus is `nil` we can not even try to order a ticket.

When the bus does not have a valid number, we can not even try to order a ticket.

When an exception is raised, we can not complete the ticket order due to the technical issue.

Hence errors are returned for those cases.

But once all the validation preconditions are met and exceptions are avoided, the ticket can still not be ordered for business reasons.

This is the place when failures come into play.

The lack of available seats or the trip delay are examples of business reasons.

Just accept the fact that at the given moment in time, there is no possibility to order a ticket for that specific bus.

But the crucial point is that a failure is a strong and reliable explainer of why the desired effect hasn't happened.

That is one of the key difference between errors and failures.

Errors give you <Link href={docsLinkUrlWithPrefix("basics/service_goals#service-goal-resolutions")}>no service goal resolution</Link> at all.

While failures provide a stable negative service goal resolution that is a <Link href={docsLinkUrlWithPrefix("faq/why_both_failure_and_error")}>strong foundation for the subsequent decision-making</Link>.


# Basics

import { docsLinkUrlWithPrefix } from "../../../custom/links"

<Cards>
  <Card href={docsLinkUrlWithPrefix("basics/services")} title="Services">
    What is a service?
  </Card>

  <Card href={docsLinkUrlWithPrefix("basics/results")} title="Results">
    What is a result?
  </Card>

  <Card href={docsLinkUrlWithPrefix("basics/result_types")} title="Result Types">
    Which result types are available?
  </Card>
</Cards>


# Result Types

## Success, failure, and error

The are 3 types of results in Convenient Service - `success`, `failure`, and `error`.

The simplest way to explain them is based on a comparison to the regular methods.

Therefore, the definition may be the following:

* The `success` results are returned from services exactly at the same cases when the expected values are returned from the regular methods.

* The `failure` results are returned from services exactly at the same cases when the fallback values are returned from the regular methods.

* The `error` results are returned from services exactly at the same cases when the exceptions are raised from the regular methods.

So, basically, the main difference between the `failure` and `error` results is whether to continue or stop the process when something is not successful just like between fallbacks and exceptions in the regular methods.

<Callout>
  For boolean methods "fallback" values are `false` and `nil`.
</Callout>

<Callout>
  For void methods "fallbacks" are returns before the desired side-effect is applied.
</Callout>

## Results in the wild

Let's check some real-world examples of the methods with both fallbacks and exceptions and see how they may look like with Convenient Service results.

* [Context#context\_superclass](https://github.com/hanami/hanami/blob/v2.3.1/lib/hanami/extensions/view/context.rb#L36) method taken from [Hanami](http://github.com/hanami/hanami).

  <Tabs items={["Original", "With Results"]}>
    <Tab value="Original" default>
      ```ruby
      def context_superclass(slice)
        return Hanami::View::Context if Hanami.app.equal?(slice)

        begin
          slice.inflector.constantize(
            slice.inflector.camelize("#{slice.app.slice_name.name}/views/context")
          )
        rescue NameError => e
          raise e unless %i[Views Context].include?(e.name)

          Hanami::View::Context
        end
      end
      ```
    </Tab>

    <Tab value="With Results">
      ```ruby
      def context_superclass(slice)
        return failure("Hanami app is equal to slice `#{slice}`") if Hanami.app.equal?(slice)

        begin
          success(superclass: slice.inflector.constantize(
            slice.inflector.camelize("#{slice.app.slice_name.name}/views/context")
          ))
        rescue NameError => e
          return error("Name `#{e.name}` does NOT include `Views` or `Context`") unless %i[Views Context].include?(e.name)

          failure("Invalid name `#{e.name}`")
        end
      end
      ```
    </Tab>
  </Tabs>

* [CommentVisitor#process?](https://github.com/rails/rails/blob/v8.1.1/tools/rdoc-to-md#L120) method taken from [Rails](https://github.com/rails/rails).

  <Tabs items={["Original", "With Results"]}>
    <Tab value="Original" default>
      ```ruby
      def process?(comments)
        return false if comments.empty?

        if comments.any?(&:trailing?)
          return false if comments.all?(&:trailing?)

          raise "only some comments are trailing?"
        end

        true
      end
      ```
    </Tab>

    <Tab value="With Results">
      ```ruby
      def process?(comments)
        return failure("Comments are empty") if comments.empty?

        if comments.any?(&:trailing?)
          return failure("All comments are trailing") if comments.all?(&:trailing?)

          return error("only some comments are trailing?")
        end

        success
      end
      ```
    </Tab>
  </Tabs>

* [ResponseBuilder#perform](https://github.com/chatwoot/chatwoot/blob/v4.7.0/app/builders/csat_surveys/response_builder.rb#L4) method taken from [Chatwood](https://github.com/chatwoot/chatwoot).

  <Tabs items={["Original", "With Results"]}>
    <Tab value="Original" default>
      ```ruby
      def perform
        raise 'Invalid Message' unless message.input_csat?

        conversation = message.conversation
        rating = message.content_attributes.dig('submitted_values', 'csat_survey_response', 'rating')
        feedback_message = message.content_attributes.dig('submitted_values', 'csat_survey_response', 'feedback_message')

        return if rating.blank?

        process_csat_response(conversation, rating, feedback_message)
      end
      ```
    </Tab>

    <Tab value="With Results">
      ```ruby
      def perform
        return error("Invalid Message") unless message.input_csat?

        conversation = message.conversation
        rating = message.content_attributes.dig('submitted_values', 'csat_survey_response', 'rating')
        feedback_message = message.content_attributes.dig('submitted_values', 'csat_survey_response', 'feedback_message')

        return failure("Rating is blank") if rating.blank?

        success(csat_survey_response: process_csat_response(conversation, rating, feedback_message))
      end
      ```
    </Tab>
  </Tabs>

* [Entry#extract](https://gitlab.com/gitlab-org/gitlab/-/blob/v18.5.0-ee/lib/safe_zip/entry.rb?ref_type=tags#L27) method taken from [GitLab](https://gitlab.com/gitlab-org/gitlab).

  <Tabs items={["Original", "With Results"]}>
    <Tab value="Original" default>
      ```ruby
      def extract
        # do not extract if file is not part of target directory or target file
        return false unless matching_target_directory || matching_target_file

        # do not overwrite existing file
        raise SafeZip::Extract::AlreadyExistsError, "File already exists #{zip_entry.name}" if exist?

        create_path_dir

        if zip_entry.file?
          extract_file
        elsif zip_entry.directory?
          extract_dir
        elsif zip_entry.symlink?
          extract_symlink
        else
          raise SafeZip::Extract::UnsupportedEntryError, "File #{zip_entry.name} cannot be extracted"
        end
      rescue SafeZip::Extract::Error
        raise
      rescue Zip::EntrySizeError => e
        raise SafeZip::Extract::EntrySizeError, e.message
      rescue StandardError => e
        raise SafeZip::Extract::ExtractError, e.message
      end
      ```
    </Tab>

    <Tab value="With Results">
      ```ruby
      def extract
        # do not extract if file is not part of target directory or target file
        return failure("file is not part of target directory or target file") unless matching_target_directory || matching_target_file

        # do not overwrite existing file
        return error("File already exists #{zip_entry.name}", :already_exists_error) if exist?

        create_path_dir

        if zip_entry.file?
          success(entry: extract_file)
        elsif zip_entry.directory?
          success(entry: extract_dir)
        elsif zip_entry.symlink?
          success(entry: extract_symlink)
        else
          return error("File #{zip_entry.name} cannot be extracted", :unsupported_entry_error)
        end
      rescue SafeZip::Extract::Error
        return error("Extract error", :extract_error)
      rescue Zip::EntrySizeError => e
        return error("Entry size error `#{e.message}`", :entry_size_error)
      rescue StandardError => e
        return error("Extract error `#{e.message}`", :extract_error)
      end
      ```
    </Tab>
  </Tabs>

* [DistributedCache#defer\_get\_set](https://github.com/discourse/discourse/blob/v3.5.2/lib/distributed_cache.rb#L16) from [Discourse](https://github.com/discourse/discourse).

  <Tabs items={["Original", "With Results"]}>
    <Tab value="Original" default>
      ```ruby
      def defer_get_set(k, &block)
        raise TypeError if !Rails.env.production? && !k.is_a?(String)

        return self[k] if hash.key? k
        value = block.call
        self.defer_set(k, value)
        value
      end
      ```
    </Tab>

    <Tab value="With Results">
      ```ruby
      def defer_get_set(k, &block)
        return error("Production Rails env or key is NOT string") if !Rails.env.production? && !k.is_a?(String)

        return success(value: self[k]) if hash.key? k
        value = block.call
        self.defer_set(k, value)
        success(value: value)
      end
      ```
    </Tab>
  </Tabs>

After a careful review of all those methods:

* Can you see a common pattern of how people decide between fallbacks and exceptions?

* Does this pattern look uniformly reproducible?

* Can you explain it to the beginner devs so that they can apply it the same way all the time?

That is why Convenient Service try to use the notion of the service goals.


# Results

## Motivation behind results

[Usually](https://www.toptal.com/ruby-on-rails/rails-service-objects-tutorial), the service exposes a sole public method, let it be `call` for this case.

```ruby
class Service
  def call
    # ...
  end
end
```

Since Ruby is a [dynamic language](https://en.wikipedia.org/wiki/Dynamic_programming_language), `call` may return any type of value.

Sometimes it is advantageous, for things like [Duck Typing](https://en.wikipedia.org/wiki/Duck_typing), [Abstract Factories](https://refactoring.guru/design-patterns/abstract-factory), [Null Objects](https://sourcemaking.com/design_patterns/null_object), etc.

But occasionally it may also become problematic.

For example, you can not implement a unified way to check whether the value was calculated correctly (as it was intended by its author).

```ruby
value = service.call

if value.any? # When an array.
if value.cover?(0...100) # Range.
if value.match(/^[0-9]*$/) # Regexp.
if value.dig(:user, :address) # Hash.
if value.nozero? # Integer....
```

<Callout>
  Someone may consider [Object#blank?](https://api.rubyonrails.org/classes/Object.html#method-i-blank-3F) and its opposite [Object#present?](https://api.rubyonrails.org/classes/Object.html#method-i-present-3F) from [ActiveSupport](https://guides.rubyonrails.org/active_support_core_extensions.html) as an attempt, but they detect [truthiness](https://stackoverflow.com/a/20663389/12201472) in the Rails sense.
</Callout>

Also it is common to forget to verify if the returned value is actually what you need:

```ruby
hash = service.call

hash.merge(other_hash)
# Expected a merge, but it raises since hash is nil...
```

[Convenient Service](/) suggests utilizing Result objects as a way to overcome the problems listed above.

Practically speaking, to return results from all services.

To express this idea, let's create a different public method instead of `call` and name it `result`.

```ruby
class Service
  def result
    # ...
  end
end
```

Now, we have the following invocation:

```ruby
result = service.result

if result.success?
  result.data
else
  result.message
end
```

## So what is a Result? Its benefits?

*Result* is a data structure that satisfies the following properties:

* Firstly, it has a consolidated way to detect its state (`success?`, `failure?`, `error?`, and their counterparts with `not` like `not_success?`).

* Secondly, when the result is successful, you can be 100% sure that its data is correct, no additional verifications are needed (the notion of correctness is defined by the service author).

* Moveover, results induce you to always check them, before accessing their attributes, otherwise an exception is raised.

* Also, when something goes wrong, the result contains a description of the reason (`result.message`), which simplifies finding the source of the problem.


# Service goals

To get an idea of the result types better, let's introduce an auxiliary term - *service goal*.

## What is a service goal?

The *service goal* is the desired effect of an action/operation.

What does it mean in practise?

Imagine the service below:

```ruby
class FindUser
  # ...

  def initialize(user_id:)
    @user_id = user_id
  end

  def result
    # ...
  end
end
```

Its desired effect is the found user record.

Simple and straightforward.

So, if you are a developer who wants to utilize this service, the only reason why you would decide to do it is to get the user record.

Thus the following conclusion can be made.

We always invoke a service to achieve some concrete goal defined by the service author.

In other words, we call a service to resolve some specific problem stated by the service name.

## Service goal resolutions

Let's come back to the `FindUser` service and add some basic implementation for it.

```ruby
class FindUser
  include ConvenientService::Standard::Config

  def initialize(user_id:)
    @user_id = user_id
  end

  def result
    return error("User id in NOT an integer") unless user_id.instance_of?(Integer)

    user = User.find_by(id: user_id)

    return failure("NO user with id `#{user_id}`") unless user

    success(user: user)
  end
end
```

```ruby
result = FindUser.result(user_id: user_id)
# => `success`, `failure` or `error`.
```

As you can see, it may return one of the three possible result types that represent different resolutions.

Each of them has a specific meaning.

The `success` result communicates to its caller the positive service goal resolution, since the found user record is returned as expected.

The `failure` result provides the negative resolution, because the user record does not exist in database.

The `error` result gives no resolution at all, since the service no even tried to complete the user lookup.


# Services

## What is a service?

*Service* is an object that does only one operation, [nothing more, nothing less](https://ludwig.guru/s/nothing+more+and+nothing+less).

Service may usually be implemented as follows:

```ruby
class Service
  def call
    # ...
  end
end
```

It has a single public method, often named [`call`](https://blog.eq8.eu/article/ruby-call-method.html) or `run`, `process`, `perform`, `execute`, etc, that is used to invoke its logic.

```ruby
service = Service.new

service.call
```

## Why do we need services?

> Hang on a minute!  According to the definition above, a service is almost the same as a regular function/method. Why do we need a new concept?
>
> â€” A curious developer

Usual Ruby methods may solve similar problems as services most of the time.

Moreover, when it is possible to achieve the task only by using plain methods, it is almost always preferable.

As a result, services should NOT be considered competitors or replacements for methods, they are additions to them.

It is like a new option in the development toolbox.

You have primitives, methods, classes, etc, and now there is an ability to use a service.

For example, removing duplicates from an array can be implemented in multiple ways, you decide whether to utilize an [array](https://www.geeksforgeeks.org/remove-duplicates-sorted-array/?ref=lbp), [hash](https://www.geeksforgeeks.org/remove-duplicates-from-unsorted-array-using-map-data-structure/?ref=lbp) or a [set](https://www.geeksforgeeks.org/remove-duplicates-from-unsorted-array-using-set-data-structure/), depending on your environment limitations.

The same case is with services. Just use them when you feel they bring advantages compared to other approaches.


# Frequently Asked Questions

import { docsLinkUrlWithPrefix } from "../../../custom/links"

<Cards>
  <Card href={docsLinkUrlWithPrefix("faq/why_both_failure_and_error")} title="Why both failures and errors?">
    Why not just failure or error?
  </Card>
</Cards>


# Why both failures and errors?

## Failures and errors often can not be handled identically

Consider the following user story.

*As a dispatcher I would like to see a list of aerodromes.*

The list is received from the third-party API.

Sometimes a controller for this task may be implemented as follows.

```ruby title="controllers/aerodromes_controller.rb"
class AerodromesController < ApplicationController
  # ...
  def index
    # `response` is a `Hash`.
    response = ApiClient.get(
      "/aerodromes",
      params: {region_id: permitted_region_id}
    )

    @aerodromes = response.dig(:data, :aerodromes)
  end
end
```

And the corresponding view.

```erb title="views/aerodromes/index.html.erb"
<h2>Aerodromes</h2>

<% if @aerodromes.present? %>
  <% @aerodromes.each do |aerodrome| %>
    <p>
      <div>
        Name: <%= aerodrome[:name] %>
      </div>
      <div>
        Location: <%= aerodrome[:location] %>
      </div>
    </p>
  <% end %>
<% else %>
  <div>
    Region has no aerodromes.
  </div>
<% end %>
```

The code may look innocent from the first point of view, but the devil is in the details.

In a case, the API response has an unexpected format, `response.dig(:data, :aerodromes)` returns `nil`.

Then `@aerodrome.present?` is evaluated as `false` in the view.

As a consequence, the `"Region has no aerodromes."` string is displayed in the dispatcher's screen.

That is why the real dispatchers have a lot of altermative sources of information. But the concept of the concern should be clear now.

Unfortunately, a code with similar problems sometimes may be written even by experienced developers ðŸ˜¢.

That is one of the main reasons of why Convenient Service differentiate [failures](basics/failures) and [errors](/basics/errors).

Sure, the lib still can NOT 100% guarantee the complete elimination of the issue.

However, it encourages the users to think about fallbacks and split the failures and errors from the beginning.

The curiosity or the confusion that people feel when they find it difficult to decide whether to use a [failure](/basics/failures) or an [error](/basics/errors) works as a provocation for them to open and read this article.

This way they become aware of the issue and share it with others more frequently.

Refactoring using Convenient Service is the following:

```ruby title="controllers/aerodromes_controller.rb"
class FetchAerodromes
  include ConvenientService::Standard::Config
  # ...
  def result
    return error("API response does not have `data` key") unless response.has_key?(:data)
    return error("API response data does not have `aerodromes` key") unless response[:data].has_key?(:aerodromes)

    return failure("Region `#{permitted_region_id}` has no aerodromes.") if response[:data][:aerodromes].empty?

    success(aerodromes: response[:data][:aerodromes])
  end

  private

  def response
    # `response` is a `Hash`.
    @response ||= ApiClient.get("/aerodromes", params: {region_id: permitted_region_id})
  end
end
```

```ruby title="controllers/aerodromes_controller.rb"
class AerodromesController < ApplicationController
  # ...
  def index
    @fetch_aerodromes_result = FetchAerodromes.result(permitted_region_id: permitted_region_id)
  end
end
```

```erb title="views/aerodromes/index.html.erb"
<h2>Aerodromes</h2>

<% if @fetch_aerodromes_result.success? %>
  <% @fetch_aerodromes_result.data[:aerodromes].each do |aerodrome| %>
    <p>
      <div>
        Name: <%= aerodrome[:name] %>
      </div>
      <div>
        Location: <%= aerodrome[:location] %>
      </div>
    </p>
  <% end %>
<% elsif @fetch_aerodromes_result.failure? %>
  <div>
    Region has no aerodromes.
  </div>
<% else # @fetch_aerodromes_result.error? %>
  <div>
    No aerodromes information available.
  </div>
  <div>
    Try to refresh the page after a while.
  <div>
  <div>
    If the issue persists please contact the support.
  </div>
<% end %>
```

The code is more verbose, but that is the price of reliability.

Using the [service goal resolution terminology](/basics/service_goals), this is what we have as a summary.

* `@fetch_aerodromes_result.success?` means that a region 100% has aerodromes (positive service goal resolution).

  So that we can display them.

* `@fetch_aerodromes_result.failure?` means that a region 100% has NO aerodromes (negative service goal resolution).

  Therefore we are confident in the "Region has no aerodromes" text.

* `@fetch_aerodromes_result.error?` means that even after service invocation, we still don't know whether a region has aerodromes or not (no service goal resolution at all).

  Due to that, we are telling the truth that "No aerodromes information available" instead of the false-negative resolution that we had before the separation of failures and errors.
